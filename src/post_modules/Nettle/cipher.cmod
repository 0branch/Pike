/* -*- c -*-
|| This file is part of Pike. For copyright information see COPYRIGHT.
|| Pike is distributed under GPL, LGPL and MPL. See the file COPYING
|| for more information.
*/

#include "global.h"
#include "interpret.h"
#include "svalue.h"
#include "array.h"
#include "operators.h"
#include "threads.h"

/* For this_object() */
#include "object.h"
#include "module_support.h"

#include "nettle_config.h"

#ifdef HAVE_LIBNETTLE

DECLARATIONS

#include "nettle.h"

#include <nettle/aes.h>
#include <nettle/arcfour.h>
#ifdef HAVE_NETTLE_BLOWFISH_DECRYPT
#include <nettle/blowfish.h>
#endif
#ifdef HAVE_NETTLE_CAMELLIA_H
#include <nettle/camellia.h>
#endif
#include <nettle/des.h>
#include <nettle/cast128.h>
#ifdef HAVE_NETTLE_SERPENT_DECRYPT
#include <nettle/serpent.h>
#endif
#include <nettle/twofish.h>
#include "idea.h"
#include <nettle/nettle-meta.h>

#include <stdio.h>
#include <stdarg.h>

#if 0
static void
werror(const char *format, ...)
{
  va_list args;

  va_start(args, format);
  vfprintf(stderr, format, args);
  va_end(args);
}
#else
#define werror(x)
#endif

/*! @module Nettle
 */

/* Calls Pike_error on errors */ 
typedef void (*pike_nettle_set_key_func)(void *ctx,
					 ptrdiff_t length, const char *key,
					 /* Force means to use key even if it is weak */
					 int force);

#ifdef HAVE_NETTLE_CRYPT_FUNC_IS_POINTER
typedef nettle_crypt_func crypt_func;
#else
/* Nettle 2.0 */
typedef nettle_crypt_func *crypt_func;
#endif

struct pike_cipher
{
  const char *name;
  
  unsigned context_size;

  unsigned block_size;

  /* Suggested key size; other sizes are sometimes possible. */
  unsigned key_size;

  pike_nettle_set_key_func set_encrypt_key;
  pike_nettle_set_key_func set_decrypt_key;

  crypt_func encrypt;
  crypt_func decrypt;
};

#define _PIKE_CIPHER(name, NAME) {		\
  #name,					\
  sizeof(struct name##_ctx),			\
  NAME##_BLOCK_SIZE,				\
  NAME##_KEY_SIZE,				\
  pike_##name##_set_encrypt_key,		\
  pike_##name##_set_decrypt_key,		\
  (crypt_func) name##_encrypt,			\
  (crypt_func) name##_decrypt,			\
}

/*! @class Cipher
 *!
 *! Represents information about a cipher algorithm, such as
 *! name, key size, and block size.
 */
PIKECLASS Cipher
{
  /*! @decl inherit __builtin.Nettle.Cipher
   */
  INHERIT "__builtin.Nettle.Cipher";

  CVAR const struct pike_cipher *meta;
  
  /*! @decl string(0..255) name(void)
   *!
   *! @returns
   *!   A human readable name for the algorithm.
   */
  PIKEFUN string(0..255) name()
    optflags OPT_TRY_OPTIMIZE;
  {
    if (!THIS->meta)
      Pike_error("Cipher not properly initialized.\n");

    push_text(THIS->meta->name);
  }

  /*! @decl int(0..) key_size()
   *!
   *! @returns
   *!   The recommended key size for the cipher.
   */
  PIKEFUN int(0..) key_size()
    optflags OPT_TRY_OPTIMIZE;
  {
    if (!THIS->meta)
      Pike_error("Cipher not properly initialized.\n");

    push_int(THIS->meta->key_size);
  }
  
  /*! @decl int(0..) block_size()
   *!
   *! @returns
   *!   The block size of the cipher (1 for stream ciphers).
   */
  PIKEFUN int(0..) block_size()
    optflags OPT_TRY_OPTIMIZE;
  {
    if (!THIS->meta)
      Pike_error("Cipher not properly initialized.\n");

    push_int(THIS->meta->block_size);
  }

  INIT
  {
    THIS->meta = NULL;
  }

  /*! @class State
   *!
   *! Base class for cipher contexts.
   */
  PIKECLASS State
    program_flags PROGRAM_USES_PARENT|PROGRAM_NEEDS_PARENT;
  {
    DOCSTART() @decl inherit Cipher::State
    DOCEND()

    EXTRA
    {
      /* Perform an inherit of the State class (if any) that our parent
       * may contain via its inherit of __builtin.Nettle.Hash.
       */
      struct program *parent_prog = Pike_compiler->previous->new_program;
      struct object *parent_obj = Pike_compiler->previous->fake_object;
      int parent_State_fun_num =
	really_low_find_shared_string_identifier(MK_STRING("State"),
						 parent_prog,
						 SEE_PROTECTED|SEE_PRIVATE);
      if (parent_State_fun_num >= 0) {
	struct program *parent_State_prog =
	  low_program_from_function(parent_obj, parent_State_fun_num);
	if (parent_State_prog) {
	  low_inherit(parent_State_prog, 0,
		      parent_State_fun_num +
		      parent_prog->inherits[1].identifier_level,
		      1 + 42, 0, NULL);
	}
      }
    }

    CVAR crypt_func crypt;
    CVAR void *ctx;
    CVAR int key_size;

    /* FIXME: Create should copy state from the other object, if
     * provided. */

#define GET_INFO()	((struct Cipher_struct *)parent_storage(1))

    /* Generate a random string of length @[size] on top of the stack. */
    static void low_make_key(INT32 size)
    {
      push_text("Crypto.Random");
      SAFE_APPLY_MASTER("resolv",1);
      if(TYPEOF(Pike_sp[-1]) != T_OBJECT)
	Pike_error("Failed to resolv Crypto.Random.\n");
      push_int(size);
      apply(Pike_sp[-2].u.object, "random_string", 1);
      stack_swap();
      pop_stack();
    }

    /*! @decl State set_encrypt_key(string key, void|int force)
     *!
     *! Initializes the object for encryption. The @[key] memory will be
     *! cleared before released.
     *!
     *! @seealso
     *!   @[set_decrypt_key], @[crypt]
     */
    PIKEFUN object set_encrypt_key(string key, void|int force)
      optflags OPT_SIDE_EFFECT;
      rawtype tFunc(tStr8 tOr(tInt01, tVoid), tObjImpl_CIPHER_STATE_ID);
    {
      struct Cipher_struct *info = GET_INFO();
      assert(info);

      if (!THIS->ctx || !info->meta)
	Pike_error("CipherState not properly initialized.\n");

      NO_WIDE_STRING(key);
      key->flags |= STRING_CLEAR_ON_EXIT;
      info->meta->set_encrypt_key(THIS->ctx, key->len, key->str,
				  force ? force->u.integer : 0);

      THIS->crypt = info->meta->encrypt;
      THIS->key_size = key->len;

      push_object(this_object());
    }

    /*! @decl State set_decrypt_key(string key, void|int force)
     *!
     *! Initializes the object for decryption. The @[key] memory will be
     *! cleared before released.
     *!
     *! @seealso
     *!   @[set_encrypt_key], @[crypt]
     */
    PIKEFUN object set_decrypt_key(string key, void|int force)
      optflags OPT_SIDE_EFFECT;
      rawtype tFunc(tStr8 tOr(tInt01, tVoid), tObjImpl_CIPHER_STATE_ID);
    {
      struct Cipher_struct *info = GET_INFO();
      assert(info);
      
      if (!THIS->ctx || !info->meta)
	Pike_error("CipherState not properly initialized.\n");

      NO_WIDE_STRING(key);
      key->flags |= STRING_CLEAR_ON_EXIT;
      info->meta->set_decrypt_key(THIS->ctx, key->len, key->str,
				  force ? force->u.integer : 0);
      THIS->crypt = info->meta->decrypt;
      THIS->key_size = key->len;

      push_object(this_object());
    }

    /*! @decl string(0..255) make_key()
     *!
     *! Generate a key by calling @[Crypto.Random.random_string] and
     *! initialize this object for encryption with that key.
     *!
     *! @returns
     *!   The generated key. The key memory will be cleared before
     *!   released.
     *!
     *! @seealso
     *!   @[set_encrypt_key]
     */
    PIKEFUN string(0..255) make_key()
      optflags OPT_EXTERNAL_DEPEND;
    {
      struct Cipher_struct *info = GET_INFO();
      assert(info);

      low_make_key(info->meta->key_size);

      /* FIXME: There should be a check for weak keys so this never throws. */
      stack_dup();
      Pike_sp[-1].u.string->flags |= STRING_CLEAR_ON_EXIT;
      f_Cipher_State_set_encrypt_key(1);
      pop_stack();
    }

    /*! @decl string(0..255) crypt(string data)
     *!
     *! Encrypts or decrypts data, using the current key. Neither the
     *! input nor output data is automatically memory scrubbed,
     *! unless @[String.secure] has been called on them.
     *!
     *! @param data
     *!   For block ciphers, data must be an integral number of blocks.
     *!
     *! @returns
     *!   The encrypted or decrypted data.
     */
    PIKEFUN string(0..255) crypt (string data)
      optflags OPT_EXTERNAL_DEPEND | OPT_SIDE_EFFECT;
    {
      struct Cipher_struct *info = GET_INFO();
      struct pike_string *s;
      assert(info);

      if (!THIS->ctx || !THIS->crypt|| !info->meta)
	Pike_error("CipherState not properly initialized.\n");

      NO_WIDE_STRING(data);

      if (data->len % info->meta->block_size)
	Pike_error("Data must be an integral number of blocks.\n");

      s = begin_shared_string(data->len);
      THIS->crypt(THIS->ctx, data->len, (uint8_t *)s->str,
                  (const uint8_t *)data->str);
      s = end_shared_string(s);
      push_string(s);
    }

    /*! @decl string(0..255) name(void)
     *!
     *! @returns
     *!   A human readable name for the algorithm.
     *!
     *! @note
     *!   The default implementation just calls @[Cipher::name()]
     *!   in the parent.
     */
    PIKEFUN string(0..255) name()
      optflags OPT_TRY_OPTIMIZE;
    {
      apply_external(1, f_Cipher_name_fun_num, args);
    }

    /*! @decl int(0..) key_size(void)
     *!
     *! @returns
     *!   The actual key size for this cipher.
     */
    PIKEFUN int(0..) key_size()
      optflags OPT_TRY_OPTIMIZE;
    {
      RETURN THIS->key_size;
    }

    /*! @decl int(0..) block_size(void)
     *!
     *! @returns
     *!   The block size for this cipher.
     *!
     *! @note
     *!   The default implementation just calls @[Cipher::block_size()]
     *!   in the parent.
     */
    PIKEFUN int(0..) block_size()
      optflags OPT_TRY_OPTIMIZE;
    {
      apply_external(1, f_Cipher_block_size_fun_num, args);
    }

    INIT
    {
      THIS->ctx = NULL;
      THIS->crypt = NULL;
      THIS->key_size = 0;
    }

    EXIT
    {
      if (THIS->ctx && Pike_fp->current_object->prog)
      {
	struct Cipher_struct *info = GET_INFO();
	assert(info);
	assert(info->meta);
	memset(THIS->ctx, 0, info->meta->context_size);
      }
    }
  }
  /*! @endclass State */

}
/*! @endclass Cipher
 */

static void
pike_aes_set_encrypt_key(void *ctx,
			 ptrdiff_t length, const char *key,
			 int UNUSED(force))
{
  if (length == 16 || length == 24 || length == 32)
    aes_set_encrypt_key(ctx, length, (const uint8_t *)key);
  else
    Pike_error("AES: Bad keysize for AES.\n");
}

static void
pike_aes_set_decrypt_key(void *ctx,
			 ptrdiff_t length, const char *key,
			 int UNUSED(force))
{
  if (length == 16 || length == 24 || length == 32)
    aes_set_decrypt_key(ctx, length, (const uint8_t *)key);
  else
    Pike_error("AES: Bad keysize for AES.\n");
}

#cmod_define PIKE_NAME AES
#cmod_define NETTLE_NAME aes
#cmod_include "cipher.H"
#cmod_undef PIKE_NAME
#cmod_undef NETTLE_NAME

static void
pike_arcfour_set_key(void *ctx,
		     ptrdiff_t length, const char *key,
		     int UNUSED(force))
{
  if (length < ARCFOUR_MIN_KEY_SIZE || length > ARCFOUR_MAX_KEY_SIZE)
    Pike_error("ARCFOUR: Bad keysize for ARCFOUR.\n");

  arcfour_set_key(ctx, length, (const uint8_t *)key);
}
#define pike_arcfour_set_encrypt_key pike_arcfour_set_key
#define pike_arcfour_set_decrypt_key pike_arcfour_set_key
#define arcfour_encrypt arcfour_crypt
#define arcfour_decrypt arcfour_crypt
#define ARCFOUR_BLOCK_SIZE 1

#cmod_define PIKE_NAME ARCFOUR
#cmod_define NETTLE_NAME arcfour
#cmod_include "cipher.H"
#cmod_undef PIKE_NAME
#cmod_undef NETTLE_NAME

#ifdef HAVE_NETTLE_BLOWFISH_DECRYPT

static void
pike_blowfish_set_key(void *ctx,
		      ptrdiff_t length, const char *key,
		      int UNUSED(force))
{
  if (length < BLOWFISH_MIN_KEY_SIZE || length > BLOWFISH_MAX_KEY_SIZE)
    Pike_error("BLOWFISH: Bad keysize for BLOWFISH.\n");
  if (!blowfish_set_key(ctx, length, (const uint8_t *)key))
    Pike_error("BLOWFISH: Key is weak (and force flag is currently ignored).\n");
}
#define pike_blowfish_set_encrypt_key pike_blowfish_set_key
#define pike_blowfish_set_decrypt_key pike_blowfish_set_key

#cmod_define PIKE_NAME BLOWFISH
#cmod_define NETTLE_NAME blowfish
#cmod_include "cipher.H"
#cmod_undef PIKE_NAME
#cmod_undef NETTLE_NAME

#endif	/* HAVE_NETTLE_BLOWFISH_DECRYPT */

#ifdef CAMELLIA_KEY_SIZE

static void
pike_camellia_set_encrypt_key(void *ctx,
			      ptrdiff_t length, const char *key,
			      int UNUSED(force))
{
  if (length < CAMELLIA_MIN_KEY_SIZE || length > CAMELLIA_MAX_KEY_SIZE)
    Pike_error("CAMELLIA: Bad keysize for CAMELLIA.\n");
  camellia_set_encrypt_key(ctx, length, (const uint8_t *)key);
}

static void
pike_camellia_set_decrypt_key(void *ctx,
			      ptrdiff_t length, const char *key,
			      int force)
{
  if (length < CAMELLIA_MIN_KEY_SIZE || length > CAMELLIA_MAX_KEY_SIZE)
    Pike_error("CAMELLIA: Bad keysize for CAMELLIA.\n");
  camellia_set_decrypt_key(ctx, length, (const uint8_t *)key);
}

#define camellia_encrypt camellia_crypt
#define camellia_decrypt camellia_crypt

#cmod_define PIKE_NAME CAMELLIA
#cmod_define NETTLE_NAME camellia
#cmod_include "cipher.H"
#cmod_undef PIKE_NAME
#cmod_undef NETTLE_NAME

#endif	/* CAMELLIA_KEY_SIZE */

static void
pike_cast128_set_key(void *ctx,
		     ptrdiff_t length, const char *key,
		     int UNUSED(force))
{
  if (length < CAST128_MIN_KEY_SIZE || length > CAST128_MAX_KEY_SIZE)
    Pike_error("CAST128_info: Bad keysize for CAST128.\n");

  cast128_set_key(ctx, length, (const uint8_t *)key);
}
#define pike_cast128_set_encrypt_key pike_cast128_set_key
#define pike_cast128_set_decrypt_key pike_cast128_set_key

#cmod_define PIKE_NAME CAST128
#cmod_define NETTLE_NAME cast128
#cmod_include "cipher.H"
#cmod_undef PIKE_NAME
#cmod_undef NETTLE_NAME

static void
pike_des_set_key(void *c,
		 ptrdiff_t length, const char *key,
		 int force)
{
  struct des_ctx *ctx = (struct des_ctx *) c;
  if (length != 8)
    Pike_error("DES_INFO: Bad keysize for DES.\n");

  if (!des_set_key(ctx, (const uint8_t *)key))
  {
#ifndef DES_WEAK_KEY
    /* Nettle 2.1 and later. */
    if (!force)
      Pike_error("DES_INFO: Key is weak.\n");
#else
    /* Nettle 2.0 and earlier. */
    switch (ctx->status)
    {
    case DES_WEAK_KEY:
      if (force)
	/* Use key anyway */
	ctx->status = DES_OK;
      else
	Pike_error("DES_INFO: Key is weak.\n");
      break;
      
    case DES_BAD_PARITY:
      /* FIXME: I don't think this should be visible in the user
       * interface, the parity bits should just be ignored. */
      Pike_error("DES_INFO: Key has bad parity.\n");
    default:
      Pike_error("DES_INFO: Unexpected error, please send a bug report.\n");
    }
#endif
  }
}

#define pike_des_set_encrypt_key pike_des_set_key
#define pike_des_set_decrypt_key pike_des_set_key

/*! @class DES
 *!
 *! Implementation of the Data Encryption Standard (DES) crypto algorithm.
 *!
 */
PIKECLASS DES
{
  /*! @decl inherit Cipher
   */
  INHERIT Cipher;

  INIT
    {
      static const struct pike_cipher pike_des = _PIKE_CIPHER(des, DES);
      /* FIXME: Ought to traverse the inherit graph for
       *        the current program.
       */
      struct Cipher_struct *cipher;
      ASSIGN_CURRENT_STORAGE(cipher, struct Cipher_struct, 1,
			     Cipher_program);
      cipher->meta = &pike_des;
    }

  /*! @decl string fix_parity(string key)
   *! Sets the last bit in every byte in @[key] to reflect the parity.
   *! If a seven byte key is used, it will be expanded into eight
   *! bytes. If a key longer than eight characters is used, it will
   *! be truncated to eight characters.
   */
  PIKEFUN string(0..255) fix_parity(string(0..255) key)
  {
    uint8_t buf[8];

    NO_WIDE_STRING(key);

    if(key->len < 7)
      Pike_error("Key must be at least 7 characters.\n");

    if(key->len == 7) {
      buf[0] = key->str[0]&254;
      buf[1] = (key->str[0]&1)<<7 | (key->str[1]>>1 & 126);
      buf[2] = (key->str[1]&3)<<6 | (key->str[2]>>2 & 62);
      buf[3] = (key->str[2]&7)<<5 | (key->str[3]>>3 & 30);
      buf[4] = (key->str[3]&15)<<4 | (key->str[4]>>4 & 14);
      buf[5] = (key->str[4]&31)<<3 | (key->str[5]>>5 & 6);
      buf[6] = (key->str[5]&63)<<2 | (key->str[6]>>6 & 2);
      buf[7] = (key->str[6]&127)<<1;
    }
    else
      MEMCPY(buf, key->str, 8);

    des_fix_parity(8, buf, buf);
    RETURN make_shared_binary_string((char *)buf, 8);
  }

  /*! @class State
   *!
   *! State for DES encyption
   */
  PIKECLASS State
    program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT;
  {
    DOCSTART() @decl inherit Cipher::State
    DOCEND()

    EXTRA
    {
      /* Perform an inherit of the Cipher.State class that our parent
       * contains via its inherit of Cipher.
       */
      struct program *parent_prog = Pike_compiler->previous->new_program;
      struct object *parent_obj = Pike_compiler->previous->fake_object;
      int parent_State_fun_num =
	really_low_find_shared_string_identifier(MK_STRING("State"),
						 parent_prog,
						 SEE_PROTECTED|SEE_PRIVATE);
      if (parent_State_fun_num >= 0) {
	struct program *parent_State_prog =
	  low_program_from_function(parent_obj, parent_State_fun_num);
	if (parent_State_prog) {
	  low_inherit(parent_State_prog, 0,
		      parent_State_fun_num +
		      parent_prog->inherits[1].identifier_level,
		      1 + 42, 0, NULL);
	}
      }
    }

    CVAR struct des_ctx des;

    INIT
    {
      struct Cipher_State_struct *state;
      ASSIGN_CURRENT_STORAGE(state, struct Cipher_State_struct, 1,
			     Cipher_State_program);
      state->ctx = &THIS->des;
    }

    PIKEFUN string(0..255) make_key()
    {
      struct Cipher_struct *info = GET_INFO();
      struct Cipher_State_struct *state;
      ASSIGN_CURRENT_STORAGE(state, struct Cipher_State_struct, 1,
			     Cipher_State_program);
      assert(info);

      low_make_key(info->meta->key_size);
      f_DES_fix_parity(1);

      /* FIXME: There should be a check for weak keys so this never throws. */
      info->meta->set_encrypt_key(state->ctx, Pike_sp[-1].u.string->len,
				  Pike_sp[-1].u.string->str, 0);

      state->crypt = info->meta->encrypt;
      state->key_size = Pike_sp[-1].u.string->len;
    }

    /*! @decl string fix_parity(string key)
     *! Sets the last bit in every byte in @[key] to reflect the parity.
     *! If a seven byte key is used, it will be expanded into eight
     *! bytes. If a key longer than eight characters is used, it will
     *! be truncated to eight characters.
     */
    PIKEFUN string(0..255) fix_parity(string(0..255) key)
    {
      apply_external(1, f_DES_fix_parity_fun_num, args);
    }
  /*! @endclass State */

}
/*! @endclass DES */

void f_DES3_fix_parity(INT32);

static void
pike_des3_set_key(void *c,
		  ptrdiff_t length, const char *key,
		  int force)
{
  struct des3_ctx *ctx = (struct des3_ctx *) c;
  int i;
  char nkotb[24];

  switch( length ) {
  case 7+7:
    push_string(make_shared_binary_string(key, length));
    push_text("1234567");
    f_add(2);
    f_DES3_fix_parity(1);

    MEMCPY(nkotb, Pike_sp[-1].u.string->str, 8+8);
    pop_stack();

    key = nkotb;
    length = 8+8;
    /* fallthrough */
  case 8+8:
    push_string(make_shared_binary_string(key, length));
    push_string(make_shared_binary_string(key, length));
    push_int(0);
    push_int(7);
    o_range();
    f_add(2);

    MEMCPY(nkotb, Pike_sp[-1].u.string->str, 8+8+8);
    pop_stack();

    key = nkotb;
    length = 8+8+8;
    break;

  case 7+7+7:
    push_string(make_shared_binary_string(key, length));
    f_DES3_fix_parity(1);
    MEMCPY(nkotb, Pike_sp[-1].u.string->str, 8+8+8);
    pop_stack();

    key = nkotb;
    length = 8+8+8;
    break;

  case 8+8+8:
    break;

  default:
    Pike_error("DES3_INFO: Bad keysize for DES3.\n");
    break;
  }

  /* The hack of resetting ctx->status to use a weak key doesn't
   * currently work with nettle's des3_set_key function. So we set the
   * individual keys by ourself. */
  for (i = 0; i<3; i++, key += DES_KEY_SIZE)
    if (!des_set_key(&ctx->des[i], (const uint8_t *)key))
    {
#ifndef DES_WEAK_KEY
      /* Nettle 2.1 and later. */
      if (!force)
	Pike_error("DES3_INFO: Key is weak.\n");
#else
      /* Nettle 2.0 and earlier. */
      switch (ctx->des[i].status)
      {
      case DES_WEAK_KEY:
	if (force)
	  /* Use key anyway */
	  ctx->des[i].status = DES_OK;
	else
	  Pike_error("DES3_INFO: Key is weak.\n");
	break;
      
      case DES_BAD_PARITY:
	/* FIXME: I don't think this should be visible in the user
	 * interface, the parity bits should just be ignored. */
	Pike_error("DES3_INFO: Key has bad parity.\n");
      default:
	Pike_error("DES3_INFO: Unexpected error, please send a bug report.\n");
      }
#endif
    }
}
#define pike_des3_set_encrypt_key pike_des3_set_key
#define pike_des3_set_decrypt_key pike_des3_set_key


/*! @class DES3
 *!
 *! Implementation of the DES3 cipher algorithm.
 *!
 */
PIKECLASS DES3
{
  /*! @decl inherit Cipher
   */
  INHERIT Cipher;

  INIT
    {
      static const struct pike_cipher pike_des3 = _PIKE_CIPHER(des3, DES3);
      /* FIXME: Ought to traverse the inherit graph for
       *        the current program.
       */
      struct Cipher_struct *cipher;
      ASSIGN_CURRENT_STORAGE(cipher, struct Cipher_struct, 1,
			     Cipher_program);
      cipher->meta = &pike_des3;
    }

  /*! @decl string fix_parity(string key)
   *! Sets the last bit in every byte in @[key] to reflect the parity.
   *! If a 21 byte key is used, it will be expanded into 24
   *! bytes. If a key longer than 24 characters is used, it will
   *! be truncated to 24 characters.
   */
  PIKEFUN string(0..255) fix_parity(string(0..255) key)
  {
    INT32 i;
    struct array *arr;

    NO_WIDE_STRING(key);

    if(key->len < 24 && key->len != 21)
      Pike_error("Key must be 21 or >=24 characters.\n");

    /* Split the string */
    if(key->len==21)
      push_int(7);
    else
      push_int(8);
    f_divide(2);
    arr = Pike_sp[-1].u.array;
    add_ref(arr);
    pop_stack();

    /* fix_parity for every subkey */
    for(i=0; i<3; i++) {
      push_int(0);
      array_index(&Pike_sp[-1], arr, i);
      f_DES_fix_parity(1);
    }
    free_array(arr);

    /* Join the subkeys */
    f_add(3);
  }

  /*! @class State
   *!
   *! State for DES3 encyption
   */
  PIKECLASS State
    program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT;
  {
    DOCSTART() @decl inherit Cipher::State
    DOCEND()

    EXTRA
    {
      /* Perform an inherit of the Cipher.State class that our parent
       * contains via its inherit of Cipher.
       */
      struct program *parent_prog = Pike_compiler->previous->new_program;
      struct object *parent_obj = Pike_compiler->previous->fake_object;
      int parent_State_fun_num =
	really_low_find_shared_string_identifier(MK_STRING("State"),
						 parent_prog,
						 SEE_PROTECTED|SEE_PRIVATE);
      if (parent_State_fun_num >= 0) {
	struct program *parent_State_prog =
	  low_program_from_function(parent_obj, parent_State_fun_num);
	if (parent_State_prog) {
	  low_inherit(parent_State_prog, 0,
		      parent_State_fun_num +
		      parent_prog->inherits[1].identifier_level,
		      1 + 42, 0, NULL);
	}
      }
    }

    CVAR struct des3_ctx des3;

    INIT
    {
      struct Cipher_State_struct *state;
      ASSIGN_CURRENT_STORAGE(state, struct Cipher_State_struct, 1,
			     Cipher_State_program);
      state->ctx = &THIS->des3;
    }

    PIKEFUN string(0..255) make_key()
    {
      struct Cipher_struct *info = GET_INFO();
      struct Cipher_State_struct *state;
      ASSIGN_CURRENT_STORAGE(state, struct Cipher_State_struct, 1,
			     Cipher_State_program);
      assert(info);

      low_make_key(info->meta->key_size);
      f_DES3_fix_parity(1);

      /* FIXME: There should be a check for weak keys so this never throws. */
      info->meta->set_encrypt_key(state->ctx, Pike_sp[-1].u.string->len,
				  Pike_sp[-1].u.string->str, 0);

      state->crypt = info->meta->encrypt;
      state->key_size = Pike_sp[-1].u.string->len;
    }
  }
  /*! @endclass State */

}

/*! @endclass DES3 */

#ifdef HAVE_NETTLE_SERPENT_DECRYPT

static void
pike_serpent_set_key(void *ctx,
		     ptrdiff_t length, const char *key,
		     int UNUSED(force))
{
  if (length < SERPENT_MIN_KEY_SIZE || length > SERPENT_MAX_KEY_SIZE)
    Pike_error("SERPENT: Bad keysize for SERPENT.\n");
  
  serpent_set_key(ctx, length, (const uint8_t *)key);
}
#define pike_serpent_set_encrypt_key pike_serpent_set_key
#define pike_serpent_set_decrypt_key pike_serpent_set_key

#cmod_define PIKE_NAME SERPENT
#cmod_define NETTLE_NAME serpent
#cmod_include "cipher.H"
#cmod_undef PIKE_NAME
#cmod_undef NETTLE_NAME

#endif	/* HAVE_NETTLE_SERPENT_DECRYPT */

static void
pike_twofish_set_key(void *ctx,
		     ptrdiff_t length, const char *key,
		     int UNUSED(force))
{
  if (length < TWOFISH_MIN_KEY_SIZE || length > TWOFISH_MAX_KEY_SIZE)
    Pike_error("TWOFISH: Bad keysize for TWOFISH.\n");

  twofish_set_key(ctx, length, (const uint8_t *)key);
}
#define pike_twofish_set_encrypt_key pike_twofish_set_key
#define pike_twofish_set_decrypt_key pike_twofish_set_key

#define Twofish_BLOCK_SIZE	TWOFISH_BLOCK_SIZE
#define Twofish_KEY_SIZE 	TWOFISH_KEY_SIZE

#cmod_define PIKE_NAME Twofish
#cmod_define NETTLE_NAME twofish
#cmod_include "cipher.H"
#cmod_undef PIKE_NAME
#cmod_undef NETTLE_NAME

#ifdef WITH_IDEA

static void
pike_idea_set_encrypt_key(void *ctx_v,
			 ptrdiff_t length, const char *key,
			 int UNUSED(force))
{
  struct idea_ctx *ctx = ctx_v;
  if (length == IDEA_KEY_SIZE)
    idea_expand((unsigned INT16 *)ctx->ctx, (unsigned INT8 *)key);
  else
    Pike_error("IDEA: Bad keysize for IDEA.\n");
}

static void
pike_idea_set_decrypt_key(void *ctx_v,
			 ptrdiff_t length, const char *key,
			 int UNUSED(force))
{
  struct idea_ctx *ctx = ctx_v;
  if (length == IDEA_KEY_SIZE) {
    idea_expand((unsigned INT16 *)ctx->ctx, (unsigned INT8 *)key);
    idea_invert((unsigned INT16 *)ctx->ctx, (unsigned INT16 *)ctx->ctx);
  }
  else
    Pike_error("IDEA: Bad keysize for IDEA.\n");
}

#define idea_encrypt idea_crypt_blocks
#define idea_decrypt idea_crypt_blocks

#cmod_define PIKE_NAME IDEA
#cmod_define NETTLE_NAME idea
#cmod_include "cipher.H"
#cmod_undef PIKE_NAME
#cmod_undef NETTLE_NAME

#endif /* WITH_IDEA */

/*! @endmodule Nettle */

void
cipher_init(void)
{
  INIT;
}

void
cipher_exit(void)
{
  EXIT;
}

#endif /* HAVE_LIBNETTLE */
