#pike __REAL_VERSION__

#if !constant(@module@)
constant this_program_does_not_exist = 1;
#else
inherit @module@ : _PDF;

class ParseError {
    inherit Error.Generic;

    constant error_type = "pdf_parse";

    string data;
    int pos;

    protected void create(string data, int pos, string reason, array bt) {
	this_program::data = data;
	this_program::pos = pos;
#define R(x)	replace(sprintf("%O", x), "\"\n\"", "")
#define NEXTRA	20

	::create(sprintf("Error parsing PDF at %s '%s' %s: %s\n",
			 R(data[max(0, pos-NEXTRA)..pos-1]),
			 sprintf("%O", data[pos..pos])[1..<1],
			 R(data[pos+1..pos+NEXTRA+1]), reason), bt);
    }
}

void low_parse_error(string buf, string reason, int pos) {
    throw(ParseError(buf, pos, reason, backtrace()[..<1]));
}

#define ASSERT(x)   do { if (!(x)) error(#x " failed\n"); } while(0)

class Parser {
    inherit _PDF::Parser;

    void parse_error(string reason, void|int pos) {
	if (undefinedp(pos)) pos = ::current_position();
	throw(ParseError(buffer(), pos, reason, backtrace()[..<1]));
    }
}

#define ID2KEY(x,y) ((x)<<16|(y))
#define KEY2ID(x) ((x)>>16)
#define KEY2REV(x) ((x)&0xffff)
#define OBJ2KEY(o) ID2KEY((o)->id, (o)->rev)

class File {
    ADT.CritBit.IntTree geometry = ADT.CritBit.IntTree();
    // object 0 is special and free
    ADT.CritBit.IntTree objects = ADT.CritBit.IntTree(([ ID2KEY(0,65535) : -1 ]));
    mapping trailer;

    pdf_object new_object() {
	int last = objects->last();
	pdf_object o = pdf_object();
	o->id = ++last;
	o->rev = 0;
	objects[ID2KEY(last,0)] = o;
    }

    pdf_object|int get_object(int id, int|void rev) {
	return objects[ID2KEY(id, rev)];
    }

    void set_object(pdf_object o, void|mixed v) {
	objects[OBJ2KEY(o)] = undefinedp(v) ? o : v;
    }
}

class Reader {
    inherit Parser;
    inherit File;
    Stdio.Stat stat;
    Stdio.File file;

    mapping refs = ([]);

    object get_reference(string ref) {
	object o;

	if (!(o = refs[ref])) {
	    refs[ref] = o = ::get_reference(ref);
	}

	return o;
    }

#define _SCAN(fmt, x...) (sscanf(data, "%*"+i+"s"+fmt+"%n", x) - 2)
#define SCAN(x...) _SCAN(x, i)

    void parse_xref_table(int pos) {
	string type;
	int id, num;
	int i = 0;

	// we use -1 as a special marker here. objects may end at an
	// xref table
	geometry[pos] = -1;
	file->seek(pos);

	string data = file->read(512);

	// we are a little bit fuzzy here, to allow for misplaced
	// cross reference tables if there is only whitespace before
	if (SCAN("%*[\0\t \n\r]xref%*[ \n\r]") != 2)
	    low_parse_error(data, "Could not find cross reference table.", 0);

	while (SCAN("%d %d%*[ \n\r]", id, num) == 3) {
	    int|string gen, offset;

	    if (sizeof(data) < 20*num + i) {
		data += file->read(20*num + 512);
	    }

	    // pikes sscanf does not seem to take length specifiers for integers very seriously
	    while (num && SCAN("%10[0-9] %5[0-9] %1[nf]%*2[ \n\r]", offset, gen, type) == 4) {
		offset = (int)offset;
		gen = (int)gen;
		int key = ID2KEY(id,gen);
		num --;
		if (objects[id])
		    low_parse_error(data, "same object encountered twice.", i);
		if (type == "n") {
		    objects[key] = offset;
		    geometry[offset] = key;
		} else {
		    objects[key] = -1;
		}
		id++;
	    }

	    if (num) low_parse_error(data, sprintf("failed to parse object location for %d through %d\n", id, id+num), i);

	}

	data = data[i..];

	if (sizeof(data) < 7)
	    data += file->read(512);

	if (!has_prefix(data, "trailer"))
	    low_parse_error(data, "Could not find trailer.", 0);

	while (-1 == (pos = search(data, "startxref"))) {
	    string extra = file->read(512);
	    data += extra;
	    if (sizeof(extra) < 512) break;
	}

	feed("1 0 obj"+data[7..pos-1]+"endobj");

	mapping trailer = parse()->data;

	if (!this_program::trailer)
	    this_program::trailer = trailer;

	if (trailer->Prev) {
	    parse_xref_table(trailer->Prev);
	}
    }

    void create(Stdio.File file) {
	int start, pos;
	string trailer;
	this_program::file = file;
	stat = file->stat();
	start = stat->size;

	do {
	    start = max(0, start - 64);
	    file->seek(start);
	    trailer = file->read(128);
	    pos = search(trailer, "startxref");
	} while (pos == -1 && start);

	if (pos == -1) low_parse_error(trailer, "No xref position found.", 0);

	pos += sizeof("startxref");

	int xref_pos;

	if (sscanf(trailer[pos..], "%*[\r\n ]%d%*[\n\r ]%%%%EOF", xref_pos) != 3) {
	    low_parse_error(trailer, "Could not parse xref position.", pos);
	}

	parse_xref_table(xref_pos);
    }

    object get_object(object|int id, int|void rev) {

	if (objectp(id)) {
	    rev = id->rev;
	    id = id->id;
	}

	mixed ret = ::get_object(id, rev);

	if (intp(ret)) {
	    if (geometry[ret] != ID2KEY(id, rev)) {
		error("object location is wrong (%d vs %d).\n", geometry[ret], ID2KEY(id, rev));
	    }
	    reset();
	    file->seek(ret);
	    int pos = geometry->next(ret);

	    // this is a hack to allow reading from unfinished files.
	    if (!pos) pos = stat->size;

	    string raw = file->read(pos-ret);
	    feed(raw);
	    ret = parse();
	    if (!ret) 
		parse_error("Cross-reference table seems wrong. Could not find object.");
	}

	ret->ref = get_reference(sprintf("%d %d R", id, rev));

	return ret;
    }

    class _get_iterator {
	object it = get_iterator(geometry);

	void create() {
	    while (!!it && it->value() == -1) {
		it->next();
	    }
	}

	int next() {
	    int ret = it->next();
	    while (it->value() == -1) {
		ret = it->next();
	    }
	    return ret;
	}

	int(0..1) `!() {
	    int ret = !it;
	    return ret;
	}

	mixed index() {
	    return KEY2ID(it->value());
	}

	mixed value() {
	    if (it) {
		int key = it->value();
		return get_object(KEY2ID(key), KEY2REV(key));
	    }
	    return UNDEFINED;
	}
    }
}

class Writer {
    inherit File;
    function(string:void) to;
    int seek = 0;
    int lastxref = 0;

    void create(function(string:void) to) {
	trailer = ([]);
	this_program::to = to;
    }

    void write(object o) {

	if (!Program.inherits(o, pdf_object))
	    error("can only write pdf_object()s\n");

	int key = OBJ2KEY(o);


	if (!undefinedp(objects[key])) {
	    mixed v = objects[key];

	    if (intp(v)) {
		werror("Object already written to offset %d bytes.\n", v);
		return;
	    }

	    if (objectp(v) && v != o)
		error("Object id and revision already used by %O\n", v);
	}

	string raw = sprintf("%d %d obj\n%s\nendobj\n", o->id, o->rev, encode(o->data));

	if (!seek) {
	    seek = 9;
	    raw = "%PDF-1.4\n" + raw;
	}

	objects[key] = seek;
	seek += sizeof(raw);
	to(raw);
    }

    void collect() {
	foreach (objects; int key; mixed o) {
	    if (objectp(o)) write(o);
	}
    }

    void finish() {
	String.Buffer buf = String.Buffer();
	String.Buffer t = String.Buffer();
	int start;
	int last = -2;

	collect();

	// print xref table
	buf->add("xref\n");
	foreach (objects; int key; int offset) {
	    int id = KEY2ID(key);
	    int rev = KEY2REV(key);

	    // have to start a new section
	    if (last < id-1) {
		if (sizeof(t)) {
		    buf->add(sprintf("%d %d\n%s", start, last-start+1, t->get()));
		}
		start = id;
	    }
	    last = id;
	    if (offset == -1) {
		t->add(sprintf("%010d %05d f \n", 0, rev));
	    } else {
		t->add(sprintf("%010d %05d n \n", offset, rev));
	    }
	}

	if (sizeof(t)) {
	    buf->add(sprintf("%d %d\n%s", start, last-start+1, t->get()));
	}

	// print trailer
	mapping m = trailer + ([
	    "Size" : sizeof(objects),
	]);

	if (lastxref) {
	    m->Prev = lastxref;
	}

	buf->add(sprintf("trailer\n%s\nstartxref\n%d\n%%%%EOF", encode(m), seek));
	lastxref = seek;
	seek += sizeof(buf);
	to(buf->get());
    }
}

class Document {
    object file;
    object catalog;
    object pages;

    void create(object file) {
	this_program::file = file;

	catalog = file->get_object(file->trailer->Root);

	ASSERT(catalog->data->Type == "Catalog");
	pages = PageNode(file->get_object(catalog->data->Pages));
    }

    object _get_iterator() {
	return get_iterator(pages);
    }

    class PageNode {
	object o;
	object parent;

	void create(object o, void|object parent) {
	    this_program::o = o;
	    if (parent) this_program::parent = parent;
	    ASSERT(o->data->Type == "Pages");
	}

	class _get_iterator {
	    object it;

	    void create() {
		it = get_iterator(o->data->Kids);
	    }

	    int next() {
		return it->next();
	    }

	    int(0..1) `!() {
		return !it;
	    }

	    mixed index() {
		return it->index();
	    }

	    mixed value() {
		return Page(file->get_object(it->value()), this);
	    }
	}

    /* this should really work without concatenation and gcc cpp also handles it properly,
     * but the pike cpp seems "different"
     */
#define PDF_INHERIT(name)						\
	mixed `-> ## name () {						\
	    return o->data-> ## name || (parent && parent-> ## name);	\
	}

	PDF_INHERIT(CropBox)
	PDF_INHERIT(MediaBox)
	PDF_INHERIT(Resources)

	int `->Rotate() {
	    if (has_index(o->data, "Rotate")) {
		return o->data->Rotate;
	    }

	    if (parent)
		return parent->Rotate;
	    else return 0;
	}
    }

    class Page {
	object o;
	object parent;

	void create(object o, object parent) {
	    this_program::o = o;
	    ASSERT(o->data->Type == "Page");
	    this_program::parent = parent;
	}

	string _sprintf(int type) {
	    return sprintf("Page(%O)", o->data);
	}

#undef PDF_INHERIT
#define PDF_INHERIT(name)					\
	mixed `-> ## name() {					\
	    return o->data-> ## name || parent-> ## name;	\
	}

	PDF_INHERIT(CropBox);
	PDF_INHERIT(MediaBox);
	PDF_INHERIT(Resources);

	int `->Rotate() {
	    if (has_index(o->data, "Rotate")) {
		return o->data->Rotate;
	    }

	    return parent->Rotate;
	}
    }
}

#endif
