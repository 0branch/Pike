#pike __REAL_VERSION__

#if !constant(@module@)
constant this_program_does_not_exist = 1;
#else
inherit @module@ : _PDF;

class ParseError {
    inherit Error.Generic;

    constant error_type = "pdf_parse";

    string data;
    int pos;

    protected void create(string data, int pos, string reason, array bt) {
	this_program::data = data;
	this_program::pos = pos;

	::create(sprintf("Error parsing PDF at %O '%c' %O: %s\n",
			 data[max(0, pos-10)..pos-1],
			 data[pos], data[pos+1..pos+11], reason), bt);
    }
}

void parse_error(string buf, string reason, int pos) {
    throw(ParseError(buf, pos, reason, backtrace()[..<1]));
}

class Reader {
    inherit _PDF::Reader;

    mapping refs = ([]);

    void parse_error(string reason, int pos) {
	throw(ParseError(buffer(), pos, reason, backtrace()[..<1]));
    }

    object get_reference(string ref) {
	object o;

	if (!(o = refs[ref])) {
	    refs[ref] = o = ::get_reference(ref);
	}

	return o;
    }
}

class File {
    object reader = Reader();
    ADT.CritBit.IntTree geometry = ADT.CritBit.IntTree();
    Stdio.Stat stat;
    Stdio.File file;

    mapping objects = ([]);

    void parse_xref_table(int pos) {
	string type;
	int id, num;

	// we use -1 as a special marker here. objects may end at an
	// xref table
	geometry[pos] = -1;
	file->seek(pos);

	string data = file->read(512);

	if (sscanf(data, "xref%*[\n\r]%s", data) != 2)
	    parse_error(data, "Could not find cross reference table.", 0);

	while (sscanf(data, "%d %d%*[\n\r]%s", id, num, data) == 4) {
	    int gen;
	    int offset;
	    int i = 0;

	    if (sizeof(data) < 20*num) {
		data += file->read(20*num + 512);
	    }

	    while (num && sscanf(data, "%*"+i+"s%10d %5d %1[nf]%*2[ \n\r]", offset, gen, type) == 5) {
		i += 20;
		num --;
		if (id && (!objects[id] || objects[id][1] < gen)) {
		    objects[id] = ({ offset, gen, type });
		    geometry[offset] = id;
		}
		id++;
	    }

	    data = data[i..];

	    if (num) error("failed to parse object location for %d through %d\n", id, id+num);
	}

	if (!has_prefix(data, "trailer"))
	    parse_error(data, "Could not find trailer.", 0);

	while (-1 == (pos = search(data, "startxref"))) {
	    string extra = file->read(512);
	    data += extra;
	    if (sizeof(extra) < 512) break;
	}

	reader->feed("1 0 obj"+data[7..pos-1]+"endobj");

	mapping trailer = reader->parse()->data;

	werror("trailer: %O\nobjects: %O\n", trailer, sizeof(objects));

	if (trailer->Prev) {
	    parse_xref_table(trailer->Prev);
	}
    }

    void create(Stdio.File file) {
	this_program::file = file;
	stat = file->stat();
	file->seek(stat->size - 48);
	string trailer = file->read();
	int pos = search(trailer, "startxref");

	if (pos == -1) parse_error(trailer, "No xref position found.", 0);

	int tail = 48-pos;

	pos += sizeof("startxref");

	int xref_pos;

	if (sscanf(trailer[pos..], "%*[\r\n ]%d%*[\n\r ]%%%%EOF", xref_pos) != 3) {
	    parse_error(trailer, "Could not parse xref position.", pos);
	}

	parse_xref_table(xref_pos);
    }

    object get_object(int id) {
	array info = objects[id];

	if (geometry[info[0]] != id) {
	    error("object location is wrong.\n");
	}

	reader->reset();
	file->seek(info[0]);
	int pos = geometry->next(info[0]);

	string raw = file->read(pos-info[0]);
	reader->feed(raw);
	return reader->parse() || reader->parse_error("Cross-reference table seems wrong. Could not find object.", 0);
    }

    class _get_iterator {
	object it = get_iterator(geometry);

	void create() {
	    while (!!it && it->value() == -1) {
		it->next();
	    }
	}

	int next() {
	    int ret = it->next();
	    while (it->value() == -1) {
		ret = it->next();
	    }
	    return ret;
	}

	int(0..1) `!() {
	    int ret = !it;
	    return ret;
	}

	mixed index() {
	    return it->value();
	}

	mixed value() {
	    return it ? get_object(it->value()) : UNDEFINED;
	}
    }
}

#endif
