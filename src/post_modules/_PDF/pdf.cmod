/* vim:syntax=c
 */
#include "global.h"
#include "interpret.h"
#include "parse.h"
#include "builtin_functions.h"
#include "module.h"

#define DEFAULT_CMOD_STORAGE static

DECLARATIONS

PIKECLASS reference {
    PIKEVAR string ref;

    PIKEFUN void create(string ref) {
	add_ref(ref);
	THIS->ref = ref;
    }

    PIKEFUN int __hash() {
	struct svalue sv;

	SET_SVAL(sv, PIKE_T_STRING, 0, string, THIS->ref);

	RETURN hash_svalue(&sv);
    }

    PIKEFUN int `==(mixed o) {
	struct svalue sv;

	SET_SVAL(sv, PIKE_T_STRING, 0, string, THIS->ref);

	RETURN is_eq(&sv, o);
    }

    PIKEFUN string _sprintf(int type, mapping params) {
	pop_n_elems(args);
	push_text("%O(%s)");
	ref_push_program(reference_program);
	ref_push_string(THIS->ref);
	f_sprintf(3);
    }
}

PIKECLASS pdf_object {
    PIKEVAR int id;
    PIKEVAR int rev;
    PIKEVAR mixed data;
    PIKEVAR string raw;

    INIT {
	THIS->data = svalue_undefined;
    }

    PIKEFUN mixed `()() {
	push_svalue(&THIS->data);
    }

    PIKEFUN string _sprintf(int type, mapping params) {
	pop_n_elems(args);
	push_text("%O(%d %d, %O)");
	ref_push_program(pdf_object_program);
	push_int(THIS->id);
	push_int(THIS->rev);
	push_svalue(&THIS->data);
	f_sprintf(5);
    }
}

PIKECLASS stream {
    PIKEVAR mapping param;
    PIKEVAR string data;

    PIKEFUN string _sprintf(int type, mapping params) {
	pop_n_elems(args);
	push_text("%O(%d bytes)");
	ref_push_program(stream_program);
	push_int(THIS->data->len);
	f_sprintf(3);
    }
}

static void generate_stream(struct svalue * s, const unsigned char * start, const unsigned char * end) {
    struct object * o = low_clone(stream_program);
    OBJ2_STREAM(o)->data = make_shared_binary_string((const char*)start, end-start);
    OBJ2_STREAM(o)->param = s->u.mapping;
    SET_SVAL(*s, PIKE_T_OBJECT, 0, object, o);
}

/*! Class representing a PDF @expr{name@} object. This is used where ever a @expr{name@} could
 *! be mistaken for a @expr{string@}. That is, everywhere except for keys in dictionaries.
 */
PIKECLASS name {
    PIKEVAR string name;

    PIKEFUN void create(string name) {
	add_ref(name);
	THIS->name = name;
    }

    PIKEFUN int __hash() {
	struct svalue sv;

	SET_SVAL(sv, PIKE_T_STRING, 0, string, THIS->name);

	RETURN hash_svalue(&sv);
    }

    PIKEFUN int `==(mixed o) {
	struct svalue sv;

	SET_SVAL(sv, PIKE_T_STRING, 0, string, THIS->name);

	RETURN is_eq(&sv, o);
    }

    PIKEFUN string cast(string type) {
	ref_push_string(THIS->name);
    }

    PIKEFUN string _sprintf(int type, mapping params) {
	pop_n_elems(args);
	push_text("%O(%O)");
	ref_push_program(name_program);
	ref_push_string(THIS->name);
	f_sprintf(3);
    }
}

static struct object * create_reference(const unsigned char * start, const unsigned char * end) {
    struct object *o;
    struct pike_string * ref = make_shared_binary_string((const char*)start, end-start);

    push_string(ref);
    apply(Pike_fp->current_object, "get_reference", 1);

    if (TYPEOF(*(Pike_sp-1)) != PIKE_T_OBJECT) {
	Pike_error("Bad return value of get_reference().\n");
    }

    o = (Pike_sp-1)->u.object;

    add_ref(o);
    pop_stack();

    return o;
}

#include "rl/pdf.c"

PIKECLASS Parser {
    CVAR struct parse_context c;
    CVAR struct string_builder buf;

    INIT {
	init_string_builder_alloc(&THIS->buf, 4096, 0);
	parse_context_init(&THIS->c);
    }

    EXIT {
	// free the parse stack
    }

    PIKEFUN object get_reference(string ref) {
	struct object * o = clone_object(reference_program, 1);
	push_object(o);
    }

    PIKEFUN string buffer() {
	push_string(debug_make_shared_binary_string(THIS->buf.s->str, THIS->buf.s->len));
    }

    PIKEFUN int _sizeof() {
	push_int(THIS->buf.s->len - THIS->c.pos);
    }

    PIKEFUN string rest() {
	push_string(debug_make_shared_binary_string(THIS->buf.s->str+THIS->c.pos,
						    THIS->buf.s->len-THIS->c.pos));
    }

    PIKEFUN void reset() {
	THIS->buf.s->len = 0;
	parse_context_reset(&THIS->c);
    }

    PIKEFUN void feed(string data) {

	if (data->size_shift) Pike_error("expects non-unicode data\n");

	/*
	 * remove buffered data only if it helps
	 */
	if (data->len + THIS->buf.s->len + 1 >= THIS->buf.malloced) {
	    ptrdiff_t waste = THIS->c.mark;
#ifdef PDF_TRACE
	    fprintf(stderr, "shrinking by %ld bytes \n", waste);
#endif
	    if (waste > 0) {
		memmove(STR0(THIS->buf.s), STR0(THIS->buf.s)+waste, THIS->buf.s->len - waste);
		THIS->buf.s->len -= waste;
		THIS->c.mark = 0;
		THIS->c.pos -= waste;
		STR0(THIS->buf.s)[THIS->buf.s->len] = 0;
	    }
	}

	string_builder_binary_strcat0(&THIS->buf, STR0(data), data->len);
	pop_n_elems(args);
    }

    PIKEFUN mixed parse() {
	int ret;
	ptrdiff_t opos = THIS->c.pos;

	ret = parse_object(&THIS->c, THIS->buf.s);

#ifdef PDF_TRACE
	fprintf(stderr, "processed %ld in state %d\n", THIS->c.pos - opos, THIS->c.state);
#endif

	if (ret) {
	    struct svalue * sp = stack_top(&THIS->c.stack);
	    push_svalue(sp);
	    free_svalue(sp);
	    return;
	}

	if (THIS->c.state == PDF_error_state) {
	    push_text("foo");
	    push_int(THIS->c.pos);
	    apply (Pike_fp->current_object, "parse_error", 2);
	    /* lets guarantee the parse error throws */
	    Pike_error("error parsing pdf at %d\n", THIS->c.pos);
	}

	push_int(0);
    }

    PIKEFUN void parse_error(string msg, int pos) {
	Pike_error("error parsing pdf at %d\n", pos);
    }
}

struct encode_context {
    struct string_builder buf;
};

static INLINE int pdf_is_whitespace(char c) {
    switch (c) {
    case '\0':
    case '\n':
    case '\r':
    case ' ':
    case '\t':
    case '\f':
	return 1;
    default:
	return 0;
    }
}

static INLINE int pdf_is_delimiter(char c) {
    switch (c) {
    case '#':
    case '{':
    case '}':
    case '[':
    case ']':
    case '(':
    case ')':
    case '/':
    case '%':
    case '<':
    case '>':
	return 1;
    default:
	return 0;
    }
}

static int pdf_is_regular(char c) {
    return !pdf_is_whitespace(c) && !pdf_is_delimiter(c);
}

static void pdf_encode_string(struct string_builder *buf, const struct pike_string * val) {
    ptrdiff_t mark, i;
    const p_wchar0 * s;

    if (val->size_shift > 0) {
	Pike_error("PDF Strings are 8-bit.\n");
    }

    string_builder_putchar(buf, '(');

    s = STR0(val);

    for (mark = 0, i = 0; i < val->len; i++) {
	switch (s[i]) {
	case '\\':
	case '(':
	case ')':
	    if (mark < i) {
		string_builder_binary_strcat0(buf, s+mark, i - mark);
	    }
	    string_builder_putchar(buf, '\\');
	    string_builder_putchar(buf, s[i]);
	    mark = i + 1;
	    break;
	}
    }

    if (mark < i) {
	string_builder_binary_strcat0(buf, s + mark, i - mark);
    }

    string_builder_putchar(buf, ')');
}

static char hex_chars[] = "0123456789abcdef";

static void pdf_encode_name(struct string_builder *buf, const struct pike_string * val) {
    ptrdiff_t mark, i;
    const p_wchar0 * s;

    if (val->size_shift > 0) {
	Pike_error("PDF names are 8-bit.\n");
    }

    string_builder_putchar(buf, '/');

    s = STR0(val);

    for (mark = 0, i = 0; i < val->len; i++) {
	p_wchar0 c = s[i];
	if (!pdf_is_regular(c)) {
	    if (mark < i) {
		string_builder_binary_strcat0(buf, s+mark, i - mark);
	    }
	    string_builder_putchar(buf, '#');
	    string_builder_putchar(buf, hex_chars[c&15]);
	    string_builder_putchar(buf, hex_chars[c>>4]);
	    mark = i + 1;
	}
    }

    if (mark < i) {
	string_builder_binary_strcat0(buf, s + mark, i - mark);
    }
}

static void pdf_encode_recur(struct string_builder *buf, const struct svalue * val);

static void pdf_encode_dict(struct string_builder *buf, const struct mapping * m) {
    struct array *inds = mapping_indices (m);
    const struct keypair * k;
    ONERROR err;
    INT32 size = inds->size, i;

    SET_ONERROR(err, do_free_array, inds);

    string_builder_strcat(buf, "<<");

    sort_array_destructively (inds);

    for (i = 0; i < size; i++) {
	const struct svalue * key = ITEM(inds) + i;

	if (TYPEOF(*key) != PIKE_T_STRING) {
	    Pike_error("Bad index in mapping.\n");
	}

	{
	    struct svalue * val = low_mapping_lookup(m, key);
	    if (val) {
		push_svalue(val);
	    } else continue;
	}

	if (i)
	    string_builder_putchar(buf, ' ');

	pdf_encode_name(buf, key->u.string);
	string_builder_putchar(buf, ' ');
	pdf_encode_recur(buf, Pike_sp - 1);
	pop_stack();
    }

    UNSET_ONERROR(err);
    free_array(inds);
    string_builder_strcat(buf, ">>");
}

static void pdf_encode_recur(struct string_builder *buf, const struct svalue * val) {

    switch (TYPEOF(*val)) {
    case PIKE_T_STRING:
	pdf_encode_string(buf, val->u.string);
	break;
    case PIKE_T_INT:
	string_builder_append_integer(buf, val->u.integer, 10, APPEND_SIGNED, 0, 0);
	break;
    case PIKE_T_ARRAY: {
	    const struct array * a = val->u.array;
	    ptrdiff_t i;

	    string_builder_putchar(buf, '[');
	    for (i = 0; i < a->size; i++) {
		if (i) string_builder_putchar(buf, ' ');
		pdf_encode_recur(buf, ITEM(a) + i);
	    }
	    string_builder_putchar(buf, ']');
	}
	break;
    case PIKE_T_MAPPING: {
	    pdf_encode_dict(buf, val->u.mapping);
	}
	break;
    case PIKE_T_OBJECT: {
	    const struct object * o = val->u.object;
	    if (o->prog == name_program) {
		pdf_encode_name(buf, OBJ2_NAME(o)->name);
		break;
	    } else if (o->prog == reference_program) {
		const struct pike_string * str = OBJ2_REFERENCE(o)->ref;
		string_builder_append(buf, MKPCHARP_STR(str), str->len);
		break;
	    } else if (o->prog == stream_program) {
		ref_push_mapping(OBJ2_STREAM(o)->param);
		pdf_encode_recur(buf, Pike_sp-1);
		pop_stack();
		string_builder_strcat(buf, "\nstream\n");
		string_builder_shared_strcat(buf, OBJ2_STREAM(o)->data);
		string_builder_strcat(buf, "\nendstream");
		break;
	    } else if (o == get_val_null()) {
		string_builder_strcat(buf, "null");
		break;
	    } else if (o == get_val_true()) {
		string_builder_strcat(buf, "true");
		break;
	    } else if (o == get_val_false()) {
		string_builder_strcat(buf, "false");
		break;
	    } else if (o->prog) {
		int fun = find_identifier("pdf_encode", o->prog);
		if (fun >= 0) {
		    apply_low(o, fun, 0);
		    pdf_encode_recur(buf, Pike_sp-1);
		    pop_stack();
		    break;
		}
	    }

	    Pike_error("Cannot PDF encode object %O.\n", val);
	}
    case PIKE_T_FLOAT:
	string_builder_sprintf(buf, "%.10f", (double)val->u.float_number);
	{
	    /* strip trailing zeroes */
	    ptrdiff_t pos = buf->s->len-1;
	    const p_wchar0 * s = STR0(buf->s);
	    while (s[pos] == '0') pos--;
	    if (s[pos] == '.') pos++;
	    buf->s->len = pos+1;
        }
	break;
    default:
	Pike_error("Cannot PDF encode %O.\n", val);
    }
}

PIKEFUN string encode(mixed val) {
    struct string_builder buf;
    ONERROR err;
    /* TODO: make this recursion safe
     *  - c stack handling
     *  - cyclic structure detection
     */

    init_string_builder(&buf, 0);

    SET_ONERROR(err, free_string_builder, &buf);

    pdf_encode_recur(&buf, val);

    UNSET_ONERROR(err);

    pop_stack();
    push_string(finish_string_builder(&buf));
}
