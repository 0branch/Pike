/* vim:syntax=c
 */
#include "global.h"
#include "interpret.h"
#include "parse.h"
#include "module.h"

#define DEFAULT_CMOD_STORAGE static

DECLARATIONS

PIKECLASS reference {
    PIKEVAR string ref;

    PIKEFUN int __hash() {
	struct svalue sv;

	SET_SVAL(sv, PIKE_T_STRING, 0, string, THIS->ref);

	RETURN hash_svalue(&sv);
    }

    PIKEFUN int `==(mixed o) {
	struct svalue sv;

	SET_SVAL(sv, PIKE_T_STRING, 0, string, THIS->ref);

	RETURN is_eq(&sv, o);
    }

    PIKEFUN string _sprintf(int type, mapping params) {
	pop_n_elems(args);
	push_text("%O(%s)");
	ref_push_program(reference_program);
	ref_push_string(THIS->ref);
	f_sprintf(3);
    }
}

PIKECLASS pdf_object {
    PIKEVAR int id;
    PIKEVAR int rev;
    PIKEVAR mixed data;
    PIKEVAR string raw;

    PIKEFUN mixed `()() {
	push_svalue(&THIS->data);
    }

    PIKEFUN string _sprintf(int type, mapping params) {
	pop_n_elems(args);
	push_text("%O(%d %d, %O)");
	ref_push_program(pdf_object_program);
	push_int(THIS->id);
	push_int(THIS->rev);
	push_svalue(&THIS->data);
	f_sprintf(5);
    }
}

/*! Class representing a PDF @expr{name@} object. This is used where ever a @expr{name@} could
 *! be mistaken for a @expr{string@}. That is everywhere except as keys of dictionaries.
 */
PIKECLASS name {
    PIKEVAR string name;

    PIKEFUN int __hash() {
	struct svalue sv;

	SET_SVAL(sv, PIKE_T_STRING, 0, string, THIS->name);

	RETURN hash_svalue(&sv);
    }

    PIKEFUN int `==(mixed o) {
	struct svalue sv;

	SET_SVAL(sv, PIKE_T_STRING, 0, string, THIS->name);

	RETURN is_eq(&sv, o);
    }

    PIKEFUN string cast(string type) {
	ref_push_string(THIS->name);
    }
}

static struct object * create_reference(const unsigned char * start, const unsigned char * end) {
    struct object * o = low_clone(reference_program);
    struct pike_string * ref = make_shared_binary_string((const char*)start, end-start);

    OBJ2_REFERENCE(o)->ref = ref;

    return o;
}

static struct object * create_name(const unsigned char * start, const unsigned char * end) {
    struct object * o = low_clone(pdf_object_program);
    struct pike_string * name = make_shared_binary_string((const char*)start, end-start);

    OBJ2_NAME(o)->name = name;

    return o;
}

#include "rl/pdf.c"

PIKECLASS Reader {
    CVAR struct parse_context c;
    CVAR struct string_builder buf;

    INIT {
	init_string_builder(&THIS->buf, 0);
	parse_context_init(&THIS->c);
    }

    EXIT {
	// free the parse stack
    }

    PIKEFUN void feed(string data) {

	if (data->size_shift) Pike_error("expects non-unicode data\n");

	/*
	 * remove buffered data only if it helps
	 */
	if (data->len + THIS->buf.s->len + 1 >= THIS->buf.malloced) {
	    ptrdiff_t waste = THIS->c.mark;
	    if (waste > 0) {
		memmove(STR0(THIS->buf.s), STR0(THIS->buf.s)+waste, THIS->buf.s->len - waste);
		THIS->buf.s->len -= waste;
		THIS->c.mark = 0;
		THIS->c.pos -= waste;
		STR0(THIS->buf.s)[THIS->buf.s->len] = 0;
	    }
	}

	string_builder_binary_strcat0(&THIS->buf, STR0(data), data->len);
	pop_n_elems(args);
    }

    PIKEFUN mixed parse() {
	int ret;

	ret = parse_object(&THIS->c, THIS->buf.s);

	if (ret) {
	    struct svalue * sp = stack_top(&THIS->c.stack);
	    push_svalue(sp);
	    free_svalue(sp);
	    return;
	}

	push_int(0);
    }
}
