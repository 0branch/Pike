/* -*- c -*-
|| This file is part of Pike. For copyright information see COPYRIGHT.
|| Pike is distributed under GPL, LGPL and MPL. See the file COPYING
|| for more information.
*/
#include "global.h"
#include "object.h"
#include "svalue.h"
#include "interpret.h"
#include "program.h"

#include <mpi.h>

#include <stdio.h>

#include "module_support.h"

/*
 * TODO:
 * communicators
 * all kinds of send/recv
 * reduce
 * all_reduce (reduced result present everywhere)
 * reduce_scatter
 * gather
 * scatter
 * scan etc?
 */

struct mpi_info {
    MPI_Datatype type;
    unsigned int length;
    unsigned int type_size;
    unsigned char shift;
    void * data;
};

DECLARATIONS

PIKECLASS IntArray
{
#cmod_define pike_type int
#cmod_define c_type int
#cmod_define name_prefix Int
#cmod_define ARRAY_STORAGE OBJ2_INTARRAY
#cmod_define PUSH push_int
#cmod_define MPI_DATATYPE MPI_INT
#cmod_define MPI_SHIFT (1<<3)
#cmod_include "typed_array.H"
}

PIKECLASS FloatArray
{
#cmod_define pike_type float
#cmod_define c_type double
#cmod_define name_prefix Float
#cmod_define ARRAY_STORAGE OBJ2_FLOATARRAY
#cmod_define PUSH push_float
#cmod_define MPI_DATATYPE MPI_DOUBLE
#cmod_define MPI_SHIFT (2<<3)
#cmod_include "typed_array.H"
}

int mpi_Recv(struct object *buf, int source, int tag, MPI_Comm comm)
{
    unsigned char shift;
    unsigned int length;
    MPI_Status status;
    int r;

    MPI_Recv(&shift, 1, MPI_CHAR, source, tag, comm, &status);
    MPI_Recv(&length, 1, MPI_INT, status.MPI_SOURCE, tag, comm, NULL);

    if (shift != OBJ2_INTARRAY(buf)->i.shift)
	Pike_error("Trying to receive shift %d into buffer of shift %d.\n",
		   (int)shift, (int)OBJ2_INTARRAY(buf)->i.shift);
    if (OBJ2_INTARRAY(buf)->i.length < length)
#if 0
	Pike_error("Cannot receive MPI." cmod_STRFY_EVAL(name_prefix) "Array(%d) into MPI." cmod_STRFY_EVAL(name_prefix) "Array(%d).\n",
		   length, OBJ2_INTARRAY(buf)->i.length);
#else
	Pike_error("Cannot receive magic shift %d length %d into length %d.\n",
		   shift, length, OBJ2_INTARRAY(buf)->i.length);
#endif

    return MPI_Recv(OBJ2_INTARRAY(buf)->i.data, length,
		    OBJ2_INTARRAY(buf)->i.type, status.MPI_SOURCE,
		    tag, comm, NULL);
}

static int mpi_string_Recv(int source, int tag, MPI_Comm comm, struct pike_string **ps)
{
    unsigned char shift;
    unsigned int length;
    MPI_Status status;
    MPI_Datatype type;
    void *_buf;
    struct svalue sval;
    int r;

    mark_free_svalue(&sval);

    MPI_Recv(&shift, 1, MPI_CHAR, source, tag, comm, &status);
    MPI_Recv(&length, 1, MPI_INT, status.MPI_SOURCE, tag, comm,
	     NULL);


    switch (shift) {
    case 0:
    case 1:
    case 2:
	type = MPI_CHAR;
	_buf = malloc(length+1);
	((char*)_buf)[length] = 0;
	break;
    default:
	Pike_error("Cannot receive shift %d as a string. %d\n", (int)shift);
    }

    r = MPI_Recv(_buf, length, type, status.MPI_SOURCE, tag,
		 comm, NULL);

    switch (shift) {
    case 0:
	*ps = make_shared_binary_string(_buf, length);
	break;
    case 1:
	*ps = make_shared_binary_string1((p_wchar1*)_buf, length >> shift);
	break;
    case 2:
	*ps = make_shared_binary_string2((p_wchar2*)_buf, length >> shift);
	break;
    }

    free(_buf);

    return r;
}

int mpi_Send(struct object *buf, int dest, int tag, MPI_Comm comm)
{
    MPI_Send(&OBJ2_INTARRAY(buf)->i.shift, 1, MPI_CHAR, dest, tag, comm);
    MPI_Send(&OBJ2_INTARRAY(buf)->i.length, 1, MPI_INT, dest, tag, comm);
    return MPI_Send(OBJ2_INTARRAY(buf)->i.data, OBJ2_INTARRAY(buf)->i.length,
		    OBJ2_INTARRAY(buf)->i.type, dest, tag, comm);
}

PIKECLASS Pointer
{
    CVAR struct svalue x;
    CVAR int y;

    PIKEFUN void create(mixed|void m)
	flags ID_PROTECTED;
    {
	if (m) assign_svalue(&THIS->x, m);
	pop_n_elems(args);
    }

    PIKEFUN mixed `()()
	flags ID_PROTECTED;
    {
	push_svalue(&THIS->x);
    }

    PIKEFUN mixed `()(mixed m)
	flags ID_PROTECTED;
    {
	assign_svalue(&THIS->x, m);
    }

    INIT
    {
	SET_SVAL(THIS->x, PIKE_T_INT, NUMBER_UNDEFINED, integer, 0);
    }

    EXIT
    {
	free_svalue(&THIS->x);
    }
}

void f_Send(INT32 args);

PIKECLASS Comm
/* flags ID_PRIVATE; */
{
    CVAR MPI_Comm comm;

    PIKEFUN void Send(string buf, int dest, int|void tag)
    {
	unsigned char shift = buf->size_shift;
	unsigned int length = buf->len << shift;

	MPI_Send(&shift, 1, MPI_CHAR, dest, tag && tag->u.integer, THIS->comm);
	MPI_Send(&length, 1, MPI_INT, dest, tag && tag->u.integer, THIS->comm);
	MPI_Send(buf->str, length, MPI_CHAR, dest, tag && tag->u.integer, THIS->comm);

	pop_n_elems(args);
    }

    PIKEFUN void Send(object buf, int dest, int|void tag)
    {
	mpi_Send(buf, dest, tag && tag->u.integer, THIS->comm);
	pop_n_elems(args);
    }

    PIKEFUN void Recv(object buf, int source, int|void tag)
    {
	struct pike_string *ps = NULL;

	if (-1 == low_get_storage(buf->prog, Pointer_program)) {
	    /* TODO: check for valid types */
	    mpi_Recv(buf, source, tag && tag->u.integer, THIS->comm);
	    pop_n_elems(args);
	} else {
	    mpi_string_Recv(source, tag && tag->u.integer, THIS->comm, &ps);
	    pop_n_elems(args-1);
	    push_string(ps);
	    f_call_function(2);
	    pop_n_elems(1);
	}
    }

    PIKEFUN void Abort(int errorcode)
    {
	MPI_Abort(THIS->comm, errorcode);
    }

    PIKEFUN void Barrier()
    {
	MPI_Barrier(THIS->comm);
    }

    PIKEFUN int rank()
    {
	int rank;

	MPI_Comm_rank(THIS->comm, &rank);
	push_int(rank);
    }

    PIKEFUN int size()
    {
	int size;

	MPI_Comm_size(THIS->comm, &size);
	push_int(size);
    }

    EXIT
    {
	/*
	if (THIS->comm && THIS->comm != MPI_COMM_WORLD
		&& (void*)THIS->comm != (void*)MPI_COMM_SELF)
	    free(THIS->comm);
	*/
    }
}

PIKECLASS O
{
    INHERIT Pointer;

    CVAR INT32 i;

    PIKEFUN void set_i(int j)
    {
	THIS->i = j;
	pop_n_elems(args);
    }

    PIKEFUN int get_i()
    {
	push_int(THIS->i);
    }
}

PIKEFUN void psp(object o)
{
    fprintf(stderr, ">> [[%p]].\n", o->storage);
    fprintf(stderr, ">> [[%d]].\n", *((INT32*)o->storage));
    fprintf(stderr, ">> %s.\n", ((struct svalue*)(o->storage+4))->u.string->str);
}

/* TODO: guard against multiple calls */
PIKEFUN void Init()
{
    MPI_Init(NULL, NULL); /* MPI Specification does not use &argc, &argv
			     for anything, nor operate on it in any other
			     way. AFAIK this holds for all implementations,
			     but at least does for OpenMPI. */
}

/*
PIKEFUN int Comm_size(object comm, object|void ptr)
{
    int size;

    if (!comm || -1 == low_get_storage(comm->prog, Comm_program))
	SIMPLE_BAD_ARG_ERROR("`+", 1, "inherits(MPI.Comm)");

    MPI_Comm_size(MPI_COMM_WORLD, &size);
    if (ptr) {
	stack_swap();
	pop_n_elems(1);
	push_int(size);
	f_call_function(2);
    } else
	pop_n_elems(args);

    push_int(size);
}

PIKEFUN int Comm_rank(object comm, object|void ptr)
{
    int rank;

    if (!comm || -1 == low_get_storage(comm->prog, Comm_program))
	SIMPLE_BAD_ARG_ERROR("`+", 1, "inherits(MPI.Comm)");

    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    if (ptr) {
	stack_swap();
	pop_n_elems(1);
	push_int(rank);
	f_call_function(2);
    } else
	pop_n_elems(args);

    push_int(rank);
}
*/


/* TODO: guard against finalizing what has not been inited. */
PIKEFUN void Finalize()
{
    MPI_Finalize();
}

PIKEFUN void Send(string buf, int dest, int|void tag, object|void comm)
{
    unsigned char shift = buf->size_shift;
    unsigned int length = buf->len << shift;

    fprintf(stderr, "string send!\n");

    MPI_Send(&shift, 1, MPI_CHAR, dest, tag && tag->u.integer, MPI_COMM_WORLD);
    MPI_Send(&length, 1, MPI_INT, dest, tag && tag->u.integer, MPI_COMM_WORLD);
    MPI_Send(buf->str, length, MPI_CHAR, dest, tag && tag->u.integer, MPI_COMM_WORLD);
}

PIKEFUN void Send(object buf, int dest, int|void tag, object|void comm)
{
    unsigned char shift;
    unsigned int length;
    MPI_Datatype type;

    fprintf(stderr, "object send!\n");

    if (!buf || -1 == low_get_storage(buf->prog, IntArray_program))
	Pike_error("You can only send strings and MPI typed arrays.\n");


    shift = 1 << 3;
    type = MPI_INTEGER;
    length = OBJ2_INTARRAY(buf)->i.length;

    MPI_Send(&shift, 1, MPI_CHAR, dest, tag && tag->u.integer, MPI_COMM_WORLD);
    MPI_Send(&length, 1, MPI_INT, dest, tag && tag->u.integer, MPI_COMM_WORLD);
    MPI_Send(OBJ2_INTARRAY(buf)->i.data, length, type, dest, tag && tag->u.integer, MPI_COMM_WORLD);
}

/*
PIKEFUN void Recv(object buf, int source, int|void tag, object|void comm)
{
    struct object *obuf = buf;
    struct pike_string *ps;

    if (comm && comm->prog != Comm_program) Pike_error("MPI.Recv: invalid program passed as comm.\n");

    add_ref(obuf);

    mpi_Recv((void**)&ps, source, tag && tag->u.integer, comm ? OBJ2_COMM(comm)->comm : MPI_COMM_WORLD);

    pop_n_elems(args);
    push_object(obuf);
    push_string(ps);

    f_call_function(2);
}
*/

PIKECLASS Test
{
    PIKEVAR int anti;
    PIKEFUN string foo()
    {
	push_text("yay!");
	THIS->anti = 7;
    }
}

PIKEFUN object `world()
{
    static struct object *comm_world = NULL;

    if (!comm_world) {
	comm_world = clone_object(Comm_program, 0);
	OBJ2_COMM(comm_world)->comm = MPI_COMM_WORLD;
    }

    ref_push_object(comm_world);
}

PIKEFUN int `ANY_SOURCE()
{
    push_int(MPI_ANY_SOURCE);
}

PIKEFUN void showptr(object o) {
    fprintf(stderr, ">>> %p\n", OBJ2_INTARRAY(o));
    fprintf(stderr, ">>> %p\n", OBJ2_FLOATARRAY(o));
    pop_n_elems(args);
}

PIKEFUN void showptr2(object o) {
    fprintf(stderr, ">>> %p\n", OBJ2_FLOATARRAY(o));
    fprintf(stderr, ">>> %p\n", OBJ2_INTARRAY(o));
    pop_n_elems(args);
}


PIKE_MODULE_INIT
{
  INIT;
  /*
  fprintf(stderr, ">> %p\n", THIS_->wupp);
  THIS_->wupp = clone_object(Comm_program, 0);
  fprintf(stderr, ">> %p\n", THIS_->wupp);
  OBJ2_COMM(THIS_->wupp)->comm = MPI_COMM_WORLD;
  */
}

PIKE_MODULE_EXIT
{
  EXIT;
} 
