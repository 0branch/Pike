#require constant(@module@)

inherit @module@;

//! Table of static headers. RFC 7541 Appendix A, Table 1.
//!
//! @array
//!   @item 0..60
//!     @array
//!       @item 0 string(8bit)
//!         Header name.
//!       @item 1 string(8bit)
//!         Default value.
//!     @endarray
//! @endarray
//!
//! @note
//!   Note that this table is indexed starting on @expr{0@} (zero),
//!   while the corresponding table in RFC 7541 starts on @expr{1@} (one).
constant static_header_tab = ({
  ({ ":authority", "", }),
  ({ ":method", "GET", }),
  ({ ":method", "POST", }),
  ({ ":path", "/", }),
  ({ ":path", "/index.html", }),
  ({ ":scheme", "http", }),
  ({ ":scheme", "https", }),
  ({ ":status", "200", }),
  ({ ":status", "204", }),
  ({ ":status", "206", }),
  ({ ":status", "304", }),
  ({ ":status", "400", }),
  ({ ":status", "404", }),
  ({ ":status", "500", }),
  ({ "accept-charset", "", }),
  ({ "accept-encoding", "gzip, deflate", }),
  ({ "accept-language", "", }),
  ({ "accept-ranges", "", }),
  ({ "accept", "", }),
  ({ "access-control-allow-origin", "", }),
  ({ "age", "", }),
  ({ "allow", "", }),
  ({ "authorization", "", }),
  ({ "cache-control", "", }),
  ({ "content-disposition", "", }),
  ({ "content-encoding", "", }),
  ({ "content-language", "", }),
  ({ "content-length", "", }),
  ({ "content-location", "", }),
  ({ "content-range", "", }),
  ({ "content-type", "", }),
  ({ "cookie", "", }),
  ({ "date", "", }),
  ({ "etag", "", }),
  ({ "expect", "", }),
  ({ "expires", "", }),
  ({ "from", "", }),
  ({ "host", "", }),
  ({ "if-match", "", }),
  ({ "if-modified-since", "", }),
  ({ "if-none-match", "", }),
  ({ "if-range", "", }),
  ({ "if-unmodified-since", "", }),
  ({ "last-modified", "", }),
  ({ "link", "", }),
  ({ "location", "", }),
  ({ "max-forwards", "", }),
  ({ "proxy-authenticate", "", }),
  ({ "proxy-authorization", "", }),
  ({ "range", "", }),
  ({ "referer", "", }),
  ({ "refresh", "", }),
  ({ "retry-after", "", }),
  ({ "server", "", }),
  ({ "set-cookie", "", }),
  ({ "strict-transport-security", "", }),
  ({ "transfer-encoding", "", }),
  ({ "user-agent", "", }),
  ({ "vary", "", }),
  ({ "via", "", }),
  ({ "www-authenticate", "", }),
});

protected void update_index(mapping(string(8bit):int|mapping(string(8bit):int)) index,
			    int i, array(string(8bit)) val)
{
  if (!index[val[0]]) {
    if (val[1] == "") {
      index[val[0]] = i;
    } else {
      index[val[0]] = ([ val[1]:i ]);
    }
  } else {
    if (intp(index[val[0]])) {
      index[val[0]] = ([ "":index[val[0]] ]);
    }
    index[val[0]][val[1]] = i;
  }
}

protected mapping(string(8bit):int|mapping(string(8bit):int)) create_index(array(array(string(8bit))) tab)
{
  mapping(string(8bit):int|mapping(string(8bit):int)) res = ([]);
  foreach(tab; int i; array(string(8bit)) val) {
    update_index(res, i+1, val);
  }
  return res;
}

// Note that the index here is offset by one!
protected mapping(string(8bit):int|mapping(string(8bit):int))
  static_header_index = create_index(static_header_tab);

// Constant from RFC 7540 6.5.2.
constant DEFAULT_HEADER_TABLE_SIZE = 4096;

class Context
{
  array(array(string(8bit))) dynamic_headers = ({});
  int dynamic_prefix;
  int dynamic_size;

  int dynamic_max_size = DEFAULT_HEADER_TABLE_SIZE;

  // Positive indices offsetted by one for static_header_tab.
  // Negative indices offsetted by sizeof(dynamic_headers) for
  // dynamic_headers.
  mapping(string(8bit):int|mapping(string(8bit):int)) header_index =
    static_header_index + ([]);

  void evict_dynamic_headers()
  {
    while (dynamic_size > dynamic_max_size) {
      int i = dynamic_prefix++;
      array(string(8bit)) entry = dynamic_headers[i];
      int sz = sizeof(entry[0]) + sizeof(entry[1]) + 32;
      dynamic_size -= sz;
      dynamic_headers[i] = UNDEFINED;
      mapping|int m;
      if (mappingp(m = header_index[entry[0]])) {
	m_delete(m, entry[1]);
	if (sizeof(m)) {
	  continue;
	}
      }
      m_delete(header_index, entry[0]);
    }
  }

  void add_header(string(8bit) header, string(8bit) value)
  {
    int sz = sizeof(header) + sizeof(value) + 32;
    dynamic_size += sz;
    dynamic_headers += ({ ({ header, value }) });
    update_index(header_index, -sizeof(dynamic_headers), dynamic_headers[0]);
    if (dynamic_size > dynamic_max_size) {
      evict_dynamic_headers();
      if (!dynamic_size) return;
    }
  }

  array(string(8bit)) get_indexed_header(int index)
  {
    if (index <= sizeof(static_header_tab)) {
      return static_header_tab[index - 1];
    }
    index = sizeof(dynamic_headers) + sizeof(static_header_tab) - index;
    return dynamic_headers[index];
  }

  protected int get_long_int(Stdio.Buffer buf)
  {
    int shift;
    int res;
    int c;
    do {
      c = buf->read_int(1);
      res |= (c & 0x7f)<<shift;
      shift += 7;
    } while(c & 0x80);
    return res;
  }

  protected string(8bit) get_string(Stdio.Buffer buf)
  {
    // 5.2 String Literal Representation.

    int c = buf->read_int(1);
    int len = c & 0x7f;
    if (len == 0x7f) {
      len += get_long_int(buf);
    }
    string s = buf->read(len);
    if (c & 0x80) {
      // Huffman encoded.
      return huffman_decode(s);
    }
    return s;
  }

  array(array(string(8bit))) decode(Stdio.Buffer buf)
  {
    array(array(string(8bit))) res = ({});
    while (sizeof(buf)) {
      int c = buf->read_int(1);
      if (c & 0x80) {
	// 6.1 Indexed Header Field Representation.
	c &= 0x7f;
	if (!c) {
	  error("Invalid header: 0x80.\n");
	}
	if (c == 0x7f) {
	  c += get_long_int(buf);
	}
	res += ({ get_indexed_header(c) });
      } else if (c & 0x40) {
	// 6.2.1 Literal Header Field with Incremental Indexing.
	string(8bit) header;

	c &= 0x3f;
	if (!c) {
	  // New name.
	  header = get_string(buf);
	} else {
	  // Indexed.
	  if (c == 0x3f) {
	    c += get_long_int(buf);
	  }
	  header = get_indexed_header(c)[0];
	}
	
	string(8bit) value = get_string(buf);
	add_header(header, value);
	res += ({ ({ header, value }) });
      } else if (!(c & 0xe0)) {
	// 6.2.2 Literal Header Field without Indexing.
	// 6.2.3 Literal Header Field Never Indexed.
	// NB: We ignore the difference for now.
	string(8bit) header;
	c &= 0x0f;
	if (!c) {
	  // New name.
	  header = get_string(buf);
	} else {
	  // Indexed name.
	  if (c == 0x0f) {
	    c += get_long_int(buf);
	  }
	  header = get_indexed_header(c)[0];
	}

	string(8bit) value = get_string(buf);
	res += ({ ({ header, value }) });
      } else if (c & 0x20) {
	// 6.3 Dynamic Table Size Update.
	c &= 0x1f;
	if (c == 0x1f) {
	  c += get_long_int(buf);
	}
	// FIXME: MUST be less than the protocol specified limit.
	dynamic_max_size = c;
	if (dynamic_max_size < dynamic_size) {
	  evict_dynamic_headers();
	}
      } else {
	// NOT_REACHED
	error("Invalid encoding.\n");
      }
    }
    return res;
  }

  protected void put_int(Stdio.Buffer buf, int(0..255) bits, int(0..255) mask,
			 int value)
  {
    if (value < mask) {
      buf->add_int(bits | value, 1);
      return;
    }
    buf->add_int(bits | mask, 1);
    value -= mask;
    while (value >= 0x80) {
      buf->add_int(value | 0x80, 1);
      value >>= 7;
    }
    buf->add_int(value, 1);
  }

  protected void put_string(Stdio.Buffer buf, string(8bit) str)
  {
    int flag = 0;
    string(8bit) hstr = huffman_encode(str);
    if (sizeof(hstr) < sizeof(str)) {
      str = hstr;
      flag = 0x80;
    }
    put_int(buf, flag, 0x7f, sizeof(hstr));
    buf->add(str);
  }

  void encode(array(array(string(8bit))) headers, Stdio.Buffer buf)
  {
    foreach(headers, array(string(8bit)) header) {
      int|mapping(string(8bit):int) entry =
	header_index[header[0]];
      if (entry) {
	if (intp(entry)) {
	  if (header[1] == "") {
	    // 6.1 Indexed header.
	    if (entry < 0) {
	      entry += sizeof(static_header_tab) + sizeof(dynamic_headers) + 1;
	    }
	    put_int(buf, 0x80, 0x7f, entry);
	    continue;
	  }
	} else if (entry[header[1]]) {
	  entry = entry[header[1]];
	  // 6.1 Indexed header.
	  if (entry < 0) {
	    entry += sizeof(static_header_tab) + sizeof(dynamic_headers) + 1;
	  }
	  put_int(buf, 0x80, 0x7f, entry);
	  continue;
	} else if (entry[""]) {
	  entry = entry[""];
	} else {
	  entry = entry[sort(indices(entry))[0]];
	}
	// 6.2.1 Literal Header Field with Incremental Indexing.
	if (entry < 0) {
	  entry += sizeof(static_header_tab) + sizeof(dynamic_headers) + 1;
	}
	put_int(buf, 0x40, 0x3f, entry);
      } else {
	// 6.2.1 Literal Header Field with Incremental Indexing.
	put_int(buf, 0x40, 0x3f, 0);
	put_string(buf, header[0]);
      }
      put_string(buf, header[1]);
      add_header(header[0], header[1]);
    }
  }

  variant string(8bit) encode(array(array(string(8bit))) headers)
  {
    Stdio.Buffer buf = Stdio.Buffer();
    encode(headers, buf);
    return buf->read();
  }
}
