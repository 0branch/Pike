/* -*- c -*-
|| This file is part of Pike. For copyright information see COPYRIGHT.
|| Pike is distributed under GPL, LGPL and MPL. See the file COPYING
|| for more information.
*/

#include "global.h"
#include "module.h"
#include "pike_error.h"
#include "interpret.h"
#include "pike_embed.h"
#include "module_support.h"
#include "pike_security.h"
#include "builtin_functions.h"

DECLARATIONS

/*! @decl int(0..) map_all_objects(function(object:void) cb)
 *! @belongs Debug
 *!
 *! Call cb for all objects that currently exist. The callback will
 *! not be called with destructed objects as it's argument.
 *!
 *! Objects might be missed if @[cb] creates new objects or destroys
 *! old ones.
 *!
 *! This function is only intended to be used for debug purposes.
 *!
 *! @returns
 *!   The total number of objects
 *!
 *! @seealso
 *!   @[next_object()]
 */
PIKEFUN int(0..) map_all_objects(function(object:void) cb)
{
    struct object *o = first_object;
    INT32 total = 0;
    ASSERT_SECURITY_ROOT("map_all_objects");

    while( o )
    {
        struct object *next = o->next;
        if( o->prog )
        {
            ref_push_object( o );
            safe_apply_svalue( Pike_sp-2, 1, 1 );
            pop_stack();
        }
        total++;
        o = next;
    }
    RETURN total;
}

/*! @decl int refs(string|array|mapping|multiset|function|object|program o)
 *! @belongs Debug
 *!
 *!   Return the number of references @[o] has.
 *!
 *!   It is mainly meant for debugging the Pike runtime, but can also be
 *!   used to control memory usage.
 *!
 *! @note
 *!   Note that the number of references will always be at least one since
 *!   the value is located on the stack when this function is executed.
 *!
 *! @seealso
 *!   @[_next()], @[_prev()]
 */
PIKEFUN int refs(string|array|mapping|multiset|function|object|program o)
{
  RETURN o->u.refs[0];
}


#ifdef PIKE_DEBUG
/* This function is for debugging *ONLY*
 * do not document please. /Hubbe
 */
PIKEFUN int leak(array|mapping|multiset|object|function|program|string|type val)
  export;
{
  INT32 i;

  if(!REFCOUNTED_TYPE(TYPEOF(*val)))
    SIMPLE_BAD_ARG_ERROR("leak", 1,
			 "array|mapping|multiset|object|"
			 "function|program|string|type");

  add_ref(val->u.dummy);
  i = val->u.refs[0];
  RETURN i;
}

/*! @decl int(0..) debug(int(0..) level)
 *! @belongs Debug
 *!
 *!   Set the run-time debug level.
 *!
 *! @returns
 *!   The old debug level will be returned.
 *!
 *! @note
 *!   This function is only available if the Pike runtime has been compiled
 *!   with RTL debug.
 */
PIKEFUN int(0..) debug(int(0..) d)
  export;
{
  pop_n_elems(args);
  push_int(d_flag);
  d_flag = d;
}

/*! @decl int(0..) optimizer_debug(int(0..) level)
 *! @belongs Debug
 *!
 *!   Set the optimizer debug level.
 *!
 *! @returns
 *!   The old optimizer debug level will be returned.
 *!
 *! @note
 *!   This function is only available if the Pike runtime has been compiled
 *!   with RTL debug.
 */
PIKEFUN int(0..) optimizer_debug(int(0..) l)
  export;
{
  pop_n_elems(args);
  push_int(l_flag);
  l_flag = l;
}

/*! @decl int(0..) assembler_debug(int(0..) level)
 *! @belongs Debug
 *!
 *!   Set the assembler debug level.
 *!
 *! @returns
 *!   The old assembler debug level will be returned.
 *!
 *! @note
 *!   This function is only available if the Pike runtime has been compiled
 *!   with RTL debug.
 */
PIKEFUN int(0..) assembler_debug(int(0..) l)
  export;
{
  pop_n_elems(args);
  push_int(a_flag);
  a_flag = l;
}

/*! @decl void dump_program_tables(program p, int(0..)|void indent)
 *! @belongs Debug
 *!
 *! Dumps the internal tables for the program @[p] on stderr.
 *!
 *! @param p
 *!   Program to dump.
 *!
 *! @param indent
 *!   Number of spaces to indent the output.
 */
PIKEFUN void dump_program_tables(program p, int(0..)|void indent)
{
  dump_program_tables(p, indent?indent->u.integer:0);
  pop_n_elems(args);
}

#ifdef YYDEBUG

/*! @decl int(0..) compiler_trace(int(0..) level)
 *! @belongs Debug
 *!
 *!   Set the compiler trace level.
 *!
 *! @returns
 *!   The old compiler trace level will be returned.
 *!
 *! @note
 *!   This function is only available if the Pike runtime has been compiled
 *!   with RTL debug.
 */
PIKEFUN int(0..) compiler_trace(int(0..) yyd)
  export;
{
  extern int yydebug;
  pop_n_elems(args);
  push_int(yydebug);
  yydebug = yyd;
}

#endif /* YYDEBUG */

#endif /* PIKE_DEBUG */

PIKE_MODULE_INIT
{
  INIT;
#ifdef PIKE_DEBUG
  ADD_INT_CONSTANT("HAVE_DEBUG", 1, 0);
#endif
}
