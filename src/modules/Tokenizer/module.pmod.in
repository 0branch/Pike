//
// $Id: module.pmod.in,v 1.4 2003/01/18 15:07:52 grubba Exp $
//
// Interface to pike code tokenizer.
//
// Henrik Grubbström 2002-07-17
//

//! @ignore
inherit @module@;
//! @endignore

typedef function(string, Position, CompilerContext: Token) TokenHandler;

class Compiler
{
  //! @ignore
  inherit compiler;
  //! @endignore

  void report(SeverityLevel severity, Position|string pos,
	      string subsystem, string msg,
	      mixed ... extra_args)
  {
    if (sizeof(extra_args))
      msg = sprintf(msg, @extra_args);
    werror("%O:%O:%O:%O\n", severity, pos, subsystem, msg);
  }

// NOTE: Assumes the variables symbol and pos contain the current
//       symbol and position.
#define MKTOKEN(TOKEN, VALUE)	Token(symbol, TOKEN, VALUE, pos)

  //! Pike tokenizer.
  class pike_tokenizer
  {
    inherit basic_tokenizer;

    Token current_token;
    string current_file = "-";

    CompilerContext context;

    TokenHandler token_handler = Pike73TokenParser->handle;

    static Position pos;

    void report(SeverityLevel severity, Position|int|string pos,
		string subsystem, string msg, mixed ... extra_args)
    {
      if (intp(pos)) pos = pike_tokenizer::pos;
      ::report(severity, pos, subsystem, msg, extra_args);
    }

    static {
      void yyerror(mixed ... args)
      {
	report(ERROR, pos, "scanner", @args);
      }

      void handle_pragma(string pragma, string args)
      {
	switch(pragma) {
	case "all_inline":
	case "all_nomask":
	case "strict_types":
	case "save_parent":
	case "dont_save_parent":
	  if (sizeof(args)) {
	    yyerror("#pragma %s does not support options.", pragma);
	  }
	  context->pragmas[pragma] = 1;
	  break;

	default:
	  // Unknown pragmas are silently ignored.
	  break;
	}
      }

      string parse_string(string raw)
      {
	int pos=1, i;
	string s = "";
	if (raw[-1] != raw[0]) {
	  yyerror("Unterminated string or character constant.");
	  // Attempt to terminate the constant.
	  raw += raw[0..0];
	}
	for (pos = 1; ((i = search(raw, "\\", pos)) != -1); pos = i+2) {
	  int num;
	  string rest = "";
	  s += raw[pos..i-1];
	  switch(raw[i+1]) {
	  case 'a': s += "\a"; break;	// Alert (BEL), 7
	  case 'b': s += "\b"; break;	// Backspace (BS), 8
	  case 't': s += "\t"; break;	// Tab (HT), 9
	  case 'n': s += "\n"; break;	// Newline (LF), 10
	  case 'v': s += "\v"; break;	// Vertical tab (VT), 11
	  case 'f': s += "\f"; break;	// Form-feed (FF), 12
	  case 'r': s += "\r"; break;	// Return (CR), 13
	  case 'e': s += "\e"; break;	// Escape (ESC), 27

	  case 'd':			// Decimal escape.
	    if (!sscanf(rest = raw[i+2..], "%d%s", num, rest)) {
	      yyerror("Bad decimal escape in string.");
	    }
	    s += sprintf("%c", num);
	    i = sizeof(raw)-(2+sizeof(rest));
	    break;

	  case 'x':			// Hexadecimal escape.
	    if (!sscanf(rest = raw[i+2..], "%x%s", num, rest)) {
	      yyerror("Bad hexadecimal escape in string.");
	    }
	    s += sprintf("%c", num);
	    i = sizeof(raw)-(2+sizeof(rest));
	    break;

	  case 'u':			// Length 4 unicode escape.
	    sscanf(raw[i+2..i+5], "%4x%s", num, rest);
	    if (sizeof(rest)) {
	      yyerror("Bad unicode escape in string.");
	      i += 4-sizeof(rest);
	    } else if (sizeof(raw) < i+5) {
	      yyerror("Bad unicode escape in string.");
	      i = sizeof(raw)-2;
	    } else {
	      i+= 4;
	    }
	    s += sprintf("%c", num);
	    break;

	  case 'U':			// Length 8 unicode escape.
	    sscanf(raw[i+2..i+9], "%4x%s", num, rest);
	    if (sizeof(rest)) {
	      yyerror("Bad unicode escape in string.");
	      i += 8-sizeof(rest);
	    } else if (sizeof(raw) < i+9) {
	      yyerror("Bad unicode escape in string.");
	      i = sizeof(raw)-2;
	    } else {
	      i+= 8;
	    }
	    s += sprintf("%c", num);
	    break;

	  case '0'..'7':			// Octal escape.
	    if (!sscanf(rest = raw[i+2..], "%o%s", num, rest)) {
	      yyerror("Bad octal escape in string.");
	    }
	    s += sprintf("%c", num);
	    i = sizeof(raw)-(2+sizeof(rest));
	    break;

	  default:
	    // FIXME: Warn?
	  case '\\':
	  case '\"':
	  case '\'':
	    i--;
	    break;
	  }
	}
	s += raw[pos..sizeof(raw)-2];
	return s;
      }

      void preprocess(string cmd, string args)
      {
	string rest = "";
	switch(cmd) {
	case "pragma":
	  string pragma = "";
	  sscanf(args, "%[^ \t]%*[ \t]%s", pragma, rest);
	  handle_pragma(pragma, rest);
	  return;

	case "error":
	  report(ERROR, pos, "preprocessor", "#error: %s", args);
	  return;

	case "warning":
	  report(WARNING, pos, "preprocessor", "#warning: %s", args);
	  return;

	case "line":
	  sscanf(args, "%[^ \t]%*[ \t]%s", cmd, rest);
	  args = rest;
	  rest="";
	  break;

	case "pike":
	  // FIXME: Change compat.
	  string version="";
	  sscanf(args, "%[^ \t]%*[ \t]%s", version, rest);	
	  int major;
	  int minor;
	  string rest2="";
	  sscanf(version, "%d.%d%s", major, minor, rest2);
	  if (sizeof(rest2) || !sizeof(version)) {
	    yyerror("Bad #pike version specification.");
	    return;
	  }
	  // FIXME: Do something here.
	  return;
	}
	int no;
	if (!sscanf(cmd, "%d%s", no, rest) || sizeof(rest)) {
	  yyerror("Unknown preprocessor directive #%s", cmd);
	  return;
	}
	if (sizeof(args)) {
	  current_file = parse_string(args);
	}
	line_no = no-1;
      }

      Token handle(string symbol)
      {
	pos = Position(current_file, line_no);

	Token res = token_handler && token_handler(symbol, pos, context);
	if (res) return res;

	string rest="";

	switch (symbol[0]) {
	case '\"':
	  return MKTOKEN("string_constant", parse_string(symbol));

	case '\'':
	  string s = parse_string(symbol);
	  if (!sizeof(s)) {
	    yyerror("Zero-length character constant.");
	    return MKTOKEN("int_constant", 0);
	  }
	  if (sizeof(s) > 1) {
	    yyerror("Unterminated character constant.");
	  }
	  return MKTOKEN("int_constant", s[0]);

	case '0':
	  if (symbol == "0") {
	    return MKTOKEN("int_constant", 0);
	  }
	  if ((symbol[1] == 'x') || (symbol[1] == 'X')) {
	    // Hexadecimal constant.
	    int val;
	    sscanf(symbol[2..], "%x%s", val, rest);
	    if (sizeof(rest)) {
	      yyerror("Strange hexadecimal constant: %s", symbol);
	    }
	    return MKTOKEN("int_constant", val);
	  }
	  if ((symbol[1] == 'b') || (symbol[1] == 'B')) {
	    // Binary constant.
	    int val;
	    sscanf(symbol[2..], "%b%s", val, rest);
	    if (sizeof(rest)) {
	      yyerror("Strange binary constant: %s", symbol);
	    }
	    return MKTOKEN("int_constant", val);
	  }
	  // FALL_THROUGH
	case '1'..'9':
	  int int_val;
	  if (symbol[0] == '0') {
	    // Octal constant or float.
	    sscanf(symbol, "%o%s", int_val, rest);
	    if (sizeof(rest) &&
		((rest[0] == '8') || (rest[0] == '9'))) {
	      string rest2="";
	      sscanf(symbol, "%*d%s", rest2);
	      if (!sizeof(rest2)) {
		yyerror("Bad octal number: %s", symbol);
		return MKTOKEN("int_constant", int_val);
	      }
	    }
	  } else {
	    // Decimal constant or float.
	    sscanf(symbol, "%d%s", int_val, rest);
	  }
	  if (!sizeof(rest)) {
	    return MKTOKEN("int_constant", int_val);
	  }
	  float float_val;
	  string rest2="";
	  sscanf(symbol, "%f%s", float_val, rest2);
	  if (sizeof(rest2)) {
	    yyerror("Strange numeric constant: %s", symbol);
	    if (rest == rest2) {
	      return MKTOKEN("int_constant", int_val);
	    }
	  }
	  return MKTOKEN("float_constant", float_val);

	case '/':
	  if ((sizeof(symbol) > 1) &&
	      ((symbol[1] == '/') || (symbol[1] == '*'))) {
	    // Comment.
	    return 0;
	  }
	  break;

	case '#':
	  string cmd="";
	  sscanf(symbol, "#%*[ \t]%[^ \t]%*[ \t]%s", cmd, rest);
	  preprocess(cmd, rest);
	  return 0;
	}
	return MKTOKEN("identifier", symbol);
      }

      void scan()
      {
	current_token = 0;

	do {
	  ::scan();
	} while (current_symbol && !(current_token = handle(current_symbol)));
      }

      void create(string data, CompilerContext|void context)
      {
	this_program::context = context || CompilerContext();
	::create(data);
      }
    }

    //! Return the current token.
    Token value()
    {
      return current_token;
    }
  }

  Group group(pike_tokenizer tokenizer)
  {
    ADT.Stack group_stack = ADT.Stack();

    array(Token|array(mixed)) tokens = ({});

    Group g = Group();

    foreach(tokenizer; ; Token token) {
      string sym = token->symbol;
      if (sym == g->group_terminator) {
	// Note that the pop is safe, since we don't have a group_terminator
	// on the top level.
	g->group_end = token;
	Group old_g = g;
	g = group_stack->pop();
	g->tokens += ({ old_g });
      } else if ((< "(", "{" , "[" >)[sym]) {
	group_stack->push(g);
	g = Group(token);
      } else if ((< "]", "}", ")" >)[sym]) {
	if (g->group_terminator) {
	  report(ERROR, token->pos, "grouping",
		 sprintf("Unexpected %O (expected %O).\n",
			 sym, g->group_terminator));
	} else {
	  report(ERROR, token->pos, "grouping",
		 sprintf("Unexpected %O.\n", sym));
	}
	return 0;
      } else {
	g->tokens += ({ token });
      }
    }
    if (g->terminator) {
      while (g->group_terminator) {
	report(ERROR, "EOF", "grouping",
	       sprintf("Missing %O at end of file.\n",
		       g->group_terminator));
	g = group_stack->pop();
      }
      return 0;
    }
    return g;
  }
}


//  //! Token-value pair.
//  class TokenPair(string token, mixed value)
//  {
//    static string _sprintf() {
//  	return sprintf("%s:%O", token||"", value);
//    }
//  };

//! Filename-linenumber pair
class Position(string filename, int line)
{
  static string _sprintf() {
    return sprintf("%s:%d", filename||"-", line);
  }
};

class CompilerContext
{
  mapping(string:mixed) pragmas = ([]);
}

class TokenParser
{
  Token handle(string symbol, Position pos, CompilerContext context);
}

class OldMetaProgram
{
  Token handle_symbol(string symbol, Position pos, CompilerContext context);
}

//! Pike 7.2 and earlier token parser.
class Pike72TokenParser_
{
  static {
    // Tokens that are keywords with their own productions.
    constant symbol_is_token = (<
      "array",
      "break",
      "case",
      "catch",			// Could probably be a meta-program.
      "class",
      "constant",
      "continue",
      "default",
      "do",
      "else",
      "enum",
      "extern",
      "float",
      "for",
      "foreach",
      "function",
      "gauge",			// Could probably be a meta program.
      "if",
      "int",
      "lambda",
      "mapping",
      "mixed",
      "object",
      "program",
      "return",
      "sscanf",			// Could probably be a meta-program.
      "string",
      "switch",
      "typedef",
      "typeof",			// Could probably be a meta-program.
      "void",
      "while",
      ")",
      "{","}",
      "[","]",
      "(<",">)",
      "<","<<","<=","<<=",
      ">",">>",">=",">>=",
      ".","..","...",
      ":","::",
      "-","--","->","-=",
      "+","++","+=",
      "&","&&","&=",
      "|","||","|=",
      "^","^=",
      "*","*=",
      "%","%=",
      "=","==",
      "!","!=",
      "/","/=",
      "?",",","~","@",";",
    >);

    // Tokens that are grouped.
    // Currently modifiers and namespace directives.
    constant symbol_to_token = ([
      "final":"modifier",
      "import":"namespace",
      "inherit":"namespace",
      "inline":"modifier",
      "local":"modifier",
      "nomask":"modifier",
      "optional":"modifier",
      "predef":"modifier",
      "private":"modifier",
      "protected":"modifier",
      "public":"modifier",
      "static":"modifier",
      "variant":"modifier",
    ]);
  }

  static string previous_symbol;

  Token handle(string symbol, Position pos, CompilerContext context)
  {
    string old_symbol = previous_symbol;
    previous_symbol = symbol;

    if (symbol_is_token[symbol]) {
      return MKTOKEN(symbol, symbol);
    }
    if (symbol_to_token[symbol]) {
      return MKTOKEN(symbol_to_token[symbol], symbol);
    }

    if (symbol == "(") {
      if ((<"int", "mapping", "function", "object",
	    "program", "array", "multiset">)[old_symbol]) {
	return MKTOKEN("type_specifier", "(");
      } else {
	return MKTOKEN("(", "(");
      }
    }
	
    return 0;
  }
}

TokenParser Pike72TokenParser = Pike72TokenParser_();

//! Pike 7.3 token parser.
class Pike73TokenParser_
{
  Token handle(string symbol, Position pos, CompilerContext context)
  {
    if (symbol == "global") return MKTOKEN("modifier", "global");
    return Pike72TokenParser->handle(symbol, pos, context);
  }
}

TokenParser Pike73TokenParser = Pike73TokenParser_();

//! Pike 7.5 token parser.
class Pike75TokenParser_
{
  array(OldMetaProgram) meta_programs = ({});

  Token handle(string symbol, Position pos, CompilerContext context)
  {
    foreach(meta_programs, OldMetaProgram meta) {
      Token t = meta->handle_symbol(symbol, pos, context);
      if (t) {
	return t;
      }
    }
    return Pike73TokenParser->handle(symbol, pos, context);
  }
}

TokenParser Pike75TokenParser = Pike75TokenParser_();

class Group
{
  array(Token|Group) tokens = ({});
  Token group_start;
  Token group_end;
  string group_terminator;

  static void create(Token|void token)
  {
    if (token) {
      string sym = token->symbol;
      if (!(group_terminator =
	    ([ "(":")", "{":"}", "[":"]", ";":";" ])[sym])) {
	error("Unsupported grouping symbol: %O\n", sym);
      }
      group_start = token;
    }
  }

  static string _sprintf(int c)
  {
    if (!group_start) {
      return sprintf("%{%O\n%}", tokens);
    } else if (group_start->symbol == "{") {
      return sprintf("%O\n%{  %O\n%}%O\n", group_start, tokens, group_end);
    } else if (group_start->symbol == ";") {
      return sprintf("STATEMENT:%{  %O%}%O\n", tokens, group_end);
    } else {
      return sprintf("%O%{ %O%} %O\n", group_start, tokens, group_end);
    }
  }
}

class Identifier(array(Token) tokens)
{
  string _sprintf(int c)
  {
    return sprintf("IDENTIFIER(%d)", sizeof(tokens));
  }
}

class MetaProgram(Group group)
{
  void parse();
}

class ClassMetaProgram
{
  inherit MetaProgram;

  array(Group) statements;

  void parse()
  {
    if (statements) return;

    statements = ({});

    int g_start;
    int(0..1) is_expr;
    int i;
    object(Group)|Token tok;
    foreach(group->tokens; i; tok) {
      if ((tok->symbol == ";") ||
	  (!is_expr && tok->group_start && tok->group_start->symbol == "{")) {
	// ; always terminates a statement.
	// {} terminates a statement if it isn't in an expression.
	Group g = Group();
	g->tokens = group->tokens[g_start..i];
	statements += ({ g });
	g_start = i+1;
	is_expr = 0;
	continue;
      }
      if (tok->symbol == "=") {
	// Expressions with {}'s are always introduced with an assignment.
	is_expr = 1;
      }
    }
    if (g_start != i) {
      if ((tok->symbol == ";") ||
	  (!is_expr && tok->group_start && tok->group_start->symbol == "{")) {
	// ; always terminates a statement.
	// {} terminates a statement if it isn't in an expression.
	Group g = Group();
	g->tokens = group->tokens[g_start..i];
	statements += ({ g });
      }
    }
    foreach(statements; i; Group g) {
      statements[i] = identify_meta(g);
    }
  }
}

MetaProgram identify_meta(Group g)
{
  foreach(g->tokens; int i; object(Group)|Token tok) {
    if (tok->symbol) {
    }      
  }
}

class Parser
{
  Group g;
  ADT.Stack workload = ADT.Stack();

  int(0..1) parse_raw_stmts(Group g)
  {
    int i;
    int start;
    array(Token) new_tokens = ({});

    for (i=0; i < sizeof(g->tokens); i++) {
      if (g->tokens[i]->token == ";") {
	new_tokens += ({ Group(g->tokens[i]) });
	new_tokens[-1]->group_end = g->tokens[i];
	new_tokens[-1]->tokens = g->tokens[start..i-1];
	start = i+1;
      }
    }
    if (start != i) {
      new_tokens += ({ Group() });
      new_tokens[-1]->tokens = g->tokens[start..i];
    }
    g->tokens = new_tokens;

    return 0;
  }

  int(0..1) parse_identifiers(Group g)
  {
    // Identify identifiers.
    array(Token) new_tokens = ({});
    int i;
    int start;
    for (i=0; i < sizeof(g->tokens); i++) {
      if ((< ".", "::", "identifier" >)[g->tokens[i]->token]) {
	start = i;
	if (g->tokens[i]->token != "identifier") {
	  i++;
	}
	while (i < sizeof(g->tokens)) {
	  if (g->tokens[i]->token != "identifier") {
	    // error!
	    break;
	  }
	  i++;
	  if ((i == sizeof(g->tokens)) ||
	      !(< ".", "::" >)[g->tokens[i]->token]) {
	    // Done.
	    break;
	  }
	  i++;
	}
	i--;
	new_tokens += ({ Identifier(g->tokens[start..i]) });
      } else {
	new_tokens += ({ g->tokens[i] });
      }
    }
    g->tokens = new_tokens;
  }

  constant left_pri = ([
    ",":2,
    "=":3,
    ":":5, "?":5,
    "||":8,
    "&&":10,
    "|":12,
    "^":14,
    "&":16,
    "==":17, "!=":17,
    ">":19, ">=":19, "<":19, "<=":19,
    "<<":21, ">>":21,
    "+":24, "-":24,
    "*":26, "%":26, "/":26,
    "!":27, "~":27,
    "++":29, "--":29,
  ]);

  constant right_pri = ([
    ",":1,
    "=":3,
    ":":5, "?":5,
    "||":7,
    "&&":9,
    "|":11,
    "^":13,
    "&":15,
    "==":17, "!=":17,
    ">":19, ">=":19, "<":19, "<=":19,
    "<<":21, ">>":21,
    "+":23, "-":23,
    "*":25, "%":25, "/":25,
    "!":27, "~":27,
    "++":29, "--":29,
  ]);

  constant un_op = ([]);

  Group|Token parse_expression(ADT.Stack input)
  {
    ADT.Stack expr = ADT.Stack();
    int top_pri;

    while (sizeof(input)) {
      // Get operand 1.
      object(Group)|Token top = input->top();

      if (top_pri <= right_pri[top->token]) {
	/* SHIFT */
	expr->push(input->pop());
	top_pri = left_pri[top->token];
      } else {
	/* REDUCE */
	array items = ({});
      }

#if 0
      while (un_op[top->token]) {
	break;
      }
#endif /* 0 */
    }
    
  }

  int(0..1) parse_class_block(Group g)
  {
    if (parse_raw_stmts(g)) return 1;

    // For each statement
    foreach(g->tokens; ; object(Group)|Token g) {
      if (g->tokens) {
	parse_identifiers(g);

	// Initialize an input stack for the expression parser.
	ADT.Stack stack = ADT.Stack();
	stack->set_stack(reverse(g->tokens));

	array(Group|Token) new_tokens = ({});

	while(sizeof(stack)) {
	  new_tokens += ({ parse_expression(stack) });
	}

	g->tokens = new_tokens;
      } else {
	// Error?
      }
    }
    return 0;
  }

  static void create(Group g)
  {
    this_program::g = g;
    g->parse_method = parse_class_block;
    workload->push(g);
  }

  Group parse()
  {
    while (sizeof(workload)) {
      Group tmp = workload->pop();
      if (tmp->parse_method(tmp)) {
	// Parse error.
	return 0;
      }
    }
    return g;
  }
}

Group parse(Group g)
{
  return Parser(g)->parse();
}

class DEF_LIST
{
  inherit BinaryNode;
  constant nodename="Tokenizer.DEF_LIST";
}

class MODIFIER_BLOCK
{
  inherit BinaryNode;
  constant nodename="Tokenizer.MODIFIER_BLOCK";
}

