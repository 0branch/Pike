//
// $Id: module.pmod.in,v 1.8 2003/04/17 15:19:34 grubba Exp $
//
// Interface to pike code tokenizer.
//
// Henrik Grubbström 2002-07-17
//

//! @ignore
inherit @module@;
//! @endignore

typedef function(string, Position, CompilerContext: Token) TokenHandler;

//! Filename-linenumber pair
class Position(string filename, int line)
{
  static string _sprintf() {
    return sprintf("%s:%d", filename||"-", line);
  }
};

class CompilerContext
{
  mapping(string:mixed) pragmas = ([]);
}

class TokenizingCompiler
{
  //! @ignore
  inherit compiler;
  //! @endignore

  void report(SeverityLevel severity, Position|string pos,
	      string subsystem, string msg,
	      mixed ... extra_args)
  {
    if (sizeof(extra_args))
      msg = sprintf(msg, @extra_args);
    werror("%O:%O:%O:%O\n", severity, pos, subsystem, msg);
  }

  // Placeholder token classes.
  // These are likely to be overloaded.
  class StringToken { inherit Token; }
  class IntegerToken { inherit Token; }
  class FloatToken { inherit Token; }
  class IdentifierToken { inherit Token; }

  //! Pike tokenizer.
  class pike_tokenizer
  {
    inherit basic_tokenizer;

    Token current_token;
    string current_file = "-";

    CompilerContext context;

    mapping(string:program(Token)) token_lookup;

    static Position pos;

    void report(SeverityLevel severity, Position|int|string pos,
		string subsystem, string msg, mixed ... extra_args)
    {
      if (intp(pos)) pos = pike_tokenizer::pos;
      ::report(severity, pos, subsystem, msg, extra_args);
    }

    static {
      void yyerror(mixed ... args)
      {
	report(ERROR, pos, "scanner", @args);
      }

      void handle_pragma(string pragma, string args)
      {
	switch(pragma) {
	case "all_inline":
	case "all_nomask":
	case "strict_types":
	case "save_parent":
	case "dont_save_parent":
	  if (sizeof(args)) {
	    yyerror("#pragma %s does not support options.", pragma);
	  }
	  context->pragmas[pragma] = 1;
	  break;

	default:
	  // Unknown pragmas are silently ignored.
	  break;
	}
      }

      string parse_string(string raw)
      {
	int pos=1, i;
	string s = "";
	if (raw[-1] != raw[0]) {
	  yyerror("Unterminated string or character constant.");
	  // Attempt to terminate the constant.
	  raw += raw[0..0];
	}
	for (pos = 1; ((i = search(raw, "\\", pos)) != -1); pos = i+2) {
	  int num;
	  string rest = "";
	  s += raw[pos..i-1];
	  switch(raw[i+1]) {
	  case 'a': s += "\a"; break;	// Alert (BEL), 7
	  case 'b': s += "\b"; break;	// Backspace (BS), 8
	  case 't': s += "\t"; break;	// Tab (HT), 9
	  case 'n': s += "\n"; break;	// Newline (LF), 10
	  case 'v': s += "\v"; break;	// Vertical tab (VT), 11
	  case 'f': s += "\f"; break;	// Form-feed (FF), 12
	  case 'r': s += "\r"; break;	// Return (CR), 13
	  case 'e': s += "\e"; break;	// Escape (ESC), 27

	  case 'd':			// Decimal escape.
	    if (!sscanf(rest = raw[i+2..], "%d%s", num, rest)) {
	      yyerror("Bad decimal escape in string.");
	    }
	    s += sprintf("%c", num);
	    i = sizeof(raw)-(2+sizeof(rest));
	    break;

	  case 'x':			// Hexadecimal escape.
	    if (!sscanf(rest = raw[i+2..], "%x%s", num, rest)) {
	      yyerror("Bad hexadecimal escape in string.");
	    }
	    s += sprintf("%c", num);
	    i = sizeof(raw)-(2+sizeof(rest));
	    break;

	  case 'u':			// Length 4 unicode escape.
	    sscanf(raw[i+2..i+5], "%4x%s", num, rest);
	    if (sizeof(rest)) {
	      yyerror("Bad unicode escape in string.");
	      i += 4-sizeof(rest);
	    } else if (sizeof(raw) < i+5) {
	      yyerror("Bad unicode escape in string.");
	      i = sizeof(raw)-2;
	    } else {
	      i+= 4;
	    }
	    s += sprintf("%c", num);
	    break;

	  case 'U':			// Length 8 unicode escape.
	    sscanf(raw[i+2..i+9], "%4x%s", num, rest);
	    if (sizeof(rest)) {
	      yyerror("Bad unicode escape in string.");
	      i += 8-sizeof(rest);
	    } else if (sizeof(raw) < i+9) {
	      yyerror("Bad unicode escape in string.");
	      i = sizeof(raw)-2;
	    } else {
	      i+= 8;
	    }
	    s += sprintf("%c", num);
	    break;

	  case '0'..'7':			// Octal escape.
	    if (!sscanf(rest = raw[i+2..], "%o%s", num, rest)) {
	      yyerror("Bad octal escape in string.");
	    }
	    s += sprintf("%c", num);
	    i = sizeof(raw)-(2+sizeof(rest));
	    break;

	  default:
	    // FIXME: Warn?
	  case '\\':
	  case '\"':
	  case '\'':
	    i--;
	    break;
	  }
	}
	s += raw[pos..sizeof(raw)-2];
	return s;
      }

      // Overload this.
      void handle_pike_compat(int major, int minor);

      void preprocess(string cmd, string args)
      {
	string rest = "";
	switch(cmd) {
	case "pragma":
	  string pragma = "";
	  sscanf(args, "%[^ \t]%*[ \t]%s", pragma, rest);
	  handle_pragma(pragma, rest);
	  return;

	case "error":
	  report(ERROR, pos, "preprocessor", "#error: %s", args);
	  return;

	case "warning":
	  report(WARNING, pos, "preprocessor", "#warning: %s", args);
	  return;

	case "line":
	  sscanf(args, "%[^ \t]%*[ \t]%s", cmd, rest);
	  args = rest;
	  rest="";
	  break;

	case "pike":
	  string version="";
	  sscanf(args, "%[^ \t]%*[ \t]%s", version, rest);	
	  int major;
	  int minor;
	  string rest2="";
	  sscanf(version, "%d.%d%s", major, minor, rest2);
	  if (sizeof(rest2) || !sizeof(version)) {
	    yyerror("Bad #pike version specification.");
	    return;
	  }
	  handle_pike_compat(major, minor);
	  return;
	}
	int no;
	if (!sscanf(cmd, "%d%s", no, rest) || sizeof(rest)) {
	  yyerror("Unknown preprocessor directive #%s", cmd);
	  return;
	}
	if (sizeof(args)) {
	  current_file = parse_string(args);
	}
	line_no = no-1;
      }

      Token handle(string symbol)
      {
	pos = Position(current_file, line_no);

	if (token_lookup &&
	    token_lookup[symbol]) {
	  return token_lookup[symbol](symbol, symbol, symbol, pos);
	}

	string rest="";

	switch (symbol[0]) {
	case '\"':
	  return StringToken(symbol, "string_constant",
			     parse_string(symbol), pos);

	case '\'':
	  string s = parse_string(symbol);
	  if (!sizeof(s)) {
	    yyerror("Zero-length character constant.");
	    return IntegerToken(symbol, "int_constant", 0, pos);
	  }
	  if (sizeof(s) > 1) {
	    yyerror("Unterminated character constant.");
	  }
	  return IntegerToken(symbol, "int_constant", s[0], pos);

	case '0':
	  if (symbol == "0") {
	    return IntegerToken(symbol, "int_constant", 0, pos);
	  }
	  if ((symbol[1] == 'x') || (symbol[1] == 'X')) {
	    // Hexadecimal constant.
	    int val;
	    sscanf(symbol[2..], "%x%s", val, rest);
	    if (sizeof(rest)) {
	      yyerror("Strange hexadecimal constant: %s", symbol);
	    }
	    return IntegerToken(symbol, "int_constant", val, pos);
	  }
	  if ((symbol[1] == 'b') || (symbol[1] == 'B')) {
	    // Binary constant.
	    int val;
	    sscanf(symbol[2..], "%b%s", val, rest);
	    if (sizeof(rest)) {
	      yyerror("Strange binary constant: %s", symbol);
	    }
	    return IntegerToken(symbol, "int_constant", val, pos);
	  }
	  // FALL_THROUGH
	case '1'..'9':
	  int int_val;
	  if (symbol[0] == '0') {
	    // Octal constant or float.
	    sscanf(symbol, "%o%s", int_val, rest);
	    if (sizeof(rest) &&
		((rest[0] == '8') || (rest[0] == '9'))) {
	      string rest2="";
	      sscanf(symbol, "%*d%s", rest2);
	      if (!sizeof(rest2)) {
		yyerror("Bad octal number: %s", symbol);
		return IntegerToken(symbol, "int_constant", int_val, pos);
	      }
	    }
	  } else {
	    // Decimal constant or float.
	    sscanf(symbol, "%d%s", int_val, rest);
	  }
	  if (!sizeof(rest)) {
	    return IntegerToken(symbol, "int_constant", int_val, pos);
	  }
	  float float_val;
	  string rest2="";
	  sscanf(symbol, "%f%s", float_val, rest2);
	  if (sizeof(rest2)) {
	    yyerror("Strange numeric constant: %s", symbol);
	    if (rest == rest2) {
	      return IntegerToken(symbol, "int_constant", int_val, pos);
	    }
	  }
	  return FloatToken(symbol, "float_constant", float_val, pos);

	case '/':
	  if ((sizeof(symbol) > 1) &&
	      ((symbol[1] == '/') || (symbol[1] == '*'))) {
	    // Comment.
	    return 0;
	  }
	  break;

	case '#':
	  string cmd="";
	  sscanf(symbol, "#%*[ \t]%[^ \t]%*[ \t]%s", cmd, rest);
	  preprocess(cmd, rest);
	  return 0;
	}
	return IdentifierToken(symbol, "identifier", symbol, pos);
      }

      void scan()
      {
	current_token = 0;

	do {
	  ::scan();
	} while (current_symbol && !(current_token = handle(current_symbol)));
      }

      void create(string data, CompilerContext|void context)
      {
	this_program::context = context || CompilerContext();
	::create(data);
      }
    }

    //! Return the current token.
    Token value()
    {
      return current_token;
    }
  }
}

//! List of Tokens and Groups
class TokenList
{
  array(Token|Group) tokens = ({});

  TokenList `+=(mixed x)
  {
    tokens += ({ x });
    return this;
  }

  static class _get_iterator()
  {
    static int pos = 0;

    static int(0..1) `!()
    {
      return pos >= sizeof(tokens);
    }

    this_program `+=(int i)
    {
      pos += i;
      if (pos < 0) pos = 0;
      else if (pos > sizeof(tokens)) pos = sizeof(tokens);
      return this;
    }

    Token|Group value()
    {
      return (pos < sizeof(tokens))?tokens[pos]:UNDEFINED;
    }

    int(0..) index()
    {
      return pos;
    }

    string _sprintf()
    {
      return sprintf("%{%s %}·%{ %s%}",
		     tokens[..pos-1], tokens[pos..]);
    }
  }

  static string _sprintf()
  {
    return sprintf("%{%O, %}", tokens);
  }
}

class Group
{
  TokenList contents = TokenList();
  Token group_start;
  Token group_end;
  string group_terminator;

  static void create(Token|void token)
  {
    if (token) {
      string sym = token->symbol;
      if (!(group_terminator =
	    ([ "(":")", "{":"}", "[":"]" ])[sym])) {
	error("Unsupported grouping symbol: %O\n", sym);
      }
      group_start = token;
    }
  }

  static string _sprintf(int c)
  {
    if (!group_start) {
      return sprintf("%O", contents);
    } else {
      return sprintf("%O%O%O", group_start, contents, group_end);
    }
  }
}

class GroupingCompiler
{
  inherit TokenizingCompiler;

  TokenList group(pike_tokenizer tokenizer)
  {
    ADT.Stack group_stack = ADT.Stack();

    array(Token|array(mixed)) tokens = ({});

    Group g = Group();

    foreach(tokenizer; ; Token token) {
      string sym = token->symbol;
      if (sym == g->group_terminator) {
	// Note that the pop is safe, since we don't have a group_terminator
	// on the top level.
	g->group_end = token;
	Group old_g = g;
	g = group_stack->pop();
	g->contents->`+=(old_g);
      } else if ((< "(", "{" , "[" >)[sym]) {
	group_stack->push(g);
	g = Group(token);
      } else if ((< "]", "}", ")" >)[sym]) {
	if (g->group_terminator) {
	  report(ERROR, token->pos, "grouping",
		 sprintf("Unexpected %O (expected %O).\n",
			 sym, g->group_terminator));
	} else {
	  report(ERROR, token->pos, "grouping",
		 sprintf("Unexpected %O.\n", sym));
	}
	return 0;
      } else {
	g->contents->`+=(token);
      }
    }
    if (g->terminator) {
      while (g->group_terminator) {
	report(ERROR, "EOF", "grouping",
	       sprintf("Missing %O at end of file.\n",
		       g->group_terminator));
	g = group_stack->pop();
      }
      return 0;
    }
    return g->contents;
  }
}

class PikeCompiler
{
  inherit GroupingCompiler;

  class Modifiers
  {
    array(Modifier) modifiers;

    Modifiers `+(mixed ... modifier_list) {
      return Modifiers(modifiers + [array(Modifier)]modifier_list);
    }

    Modifiers `+=(mixed ... modifier_list) {
      modifiers += [array(Modifier)]modifier_list;
      return this;
    }

    static void create(array(Modifier)|void modifiers)
    {
      Modifiers::modifiers = modifiers || ({});
    }

    static string _sprintf()
    {
      return sprintf("Modifiers(%{%s %})", modifiers);
    }
  }

  class Modifier
  {
    inherit Token;

    // Called at
    //   modifier ·
    void parse_modifier(object tokens_left) {}
  }

  class NameSpace
  {
    inherit Token;

    // Called at
    //   namespace · { string | symbol } [ ':' name ] ';'
    void parse_meta_program(Class current_class, object tokens_left,
			    Modifiers current_modifiers)
    {
      // FIXME:
      foreach(tokens_left; ;Token token) {
	if (token->symbol == ";") return;
      }
      report(ERROR, pos, "parser", "Syntax error");      
    }
  }

  class Expression
  {
  }

  class ValueExpression(Token value)
  {
  }

  class PrefixExpression(Token operator, Expression operand)
  {
    inherit Expression;
  }

  class SuffixExpression(Token operator, Expression operand)
  {
    inherit Expression;
  }

  class BinaryExpression(Token operator, Expression operand1,
			 Expression operand2)
  {
    inherit Expression;
  }

  class TrinaryExpression(Token operator1, Expression operand1,
			  Token operator2, Expression operand2,
			  Expression operand3)
  {
    inherit Expression;
  }

#define UNARY_SUFFIX(NAME, BASE, SYMS)					\
    Expression parse_ ## NAME ## _expression(object tokens_left)	\
    {									\
      Expression expr = parse_ ## BASE ## _expression(tokens_left);	\
      Token token;							\
      while (tokens_left &&						\
	     SYMS[(token = tokens_left->value())->symbol]) {		\
	tokens_left->`+=(1);						\
	expr = SuffixExpression(token, expr);				\
      }									\
      return expr;							\
    }
#define UNARY_PREFIX(NAME, BASE, SYMS)					\
    Expression parse_ ## NAME ## _expression(object tokens_left)	\
    {									\
      Token token;							\
      if (tokens_left &&						\
	  SYMS[(token = tokens_left->value())->symbol]) {		\
	tokens_left->`+=(1);						\
	return								\
	  PrefixExpression(token,					\
			   parse_ ## NAME ## _expression(tokens_left));	\
      } else {								\
        return parse_ ## BASE ## _expression(tokens_left);		\
      }									\
    }
#define RIGHT_ASSOC(NAME, BASE, SYMS)					\
    Expression parse_ ## NAME ## _expression(object tokens_left)	\
    {									\
      Expression expr = parse_ ## BASE ## _expression(tokens_left);	\
      Token token;							\
      if (tokens_left &&						\
	  SYMS[(token = tokens_left->value())->symbol]) {		\
	tokens_left->`+=(1);						\
	expr =								\
	  BinaryExpression(token, expr,					\
			   parse_ ## NAME ## _expression(tokens_left));	\
      }									\
      return expr;							\
    }
#define LEFT_ASSOC(NAME, BASE, SYMS)					\
    Expression parse_ ## NAME ## _expression(object tokens_left)	\
    {									\
      Expression expr = parse_ ## BASE ## _expression(tokens_left);	\
      Token token;							\
      while (tokens_left &&						\
	     SYMS[(token = tokens_left->value())->symbol]) {		\
	tokens_left->`+=(1);						\
	expr =								\
	  BinaryExpression(token, expr,					\
			   parse_ ## BASE ## _expression(tokens_left));	\
      }									\
      return expr;							\
    }

  Expression parse_basic_expression(object tokens_left)
  {
    if (!tokens_left) {
      SYNTAX_ERROR();
      return 0;
    }
    Token token = tokens_left->value();
    if (token->group_start) {
      if (token->group_start->symbol == "(") {
	tokens_left->`+=(1);
	do {
	  Token sub_token;
	  if ((sizeof(token->contents) == 1) &&
	      (sub_token = token->contents[0]->group_start)) {
	    switch (sub_token->symbol) {
	    case "(":
	      token = sub_token;
	      continue;
	    case "{":
	      return parse_array_expression(sub_token->contents);
	    case "[":
	      return parse_mapping_expression(sub_token->contents);
	    default:
	      SYNTAX_ERROR();
	      return 0;
	    }
	  }
	  break;
	} while(1);
	if (sizeof(token->contents) && (token->contents[0]->symbol == "<")) {
	  return parse_multiset_expression(token->contents);
	}
	tokens_left = __builtin.Iterator(token->contents);
	Expression expr = parse_expression(tokens_left);
	if (tokens_left) {
	  return parse_var_decl(expr, tokens_left);
	}
	return expr;
      }
      SYNTAX_ERROR();
      return 0;
    } else {
      switch(token->token) {
      case "identifier":
	return parse_identifier_expression(tokens_left);
      case "string_constant":
      case "int_constant":
      case "float_constant":
	tokens_left->`+=(1);
	return LiteralExpression(token->value);
      default:
	SYNTAX_ERROR();
	return 0;
      }
    }
  }

  Expression parse_funcall_expression(object tokens_left)
  {
    int potential_cast =
      tokens_left && tokens_left->group_start &&
      (<"(", "[">)[tokens_left->group_start->symbol];
    Expression expr = parse_basic_expression(tokens_left);
    Token token;
    while (tokens_left && 
	   (((token = tokens_left->value())->symbol == "->") ||
	    (token->group_start &&
	     (<"(", "[">)[token->group_start->symbol]))) {
      if (token->group_start) {
	expr = BinaryExpression(token->group_start, expr,
				parse_argument_list(token->contents));
      } else {
	tokens_left->`+=(1);
	expr = BinaryExpression(token, expr, parse_basic_expression());
      }
    }
  }

  UNARY_POSTFIX(postfix, funcall, (<"++", "--">));
  UNARY_PREFIX(prefix, postfix, (<"!", "~", "-", "++", "--">));
  LEFT_ASSOC(product, prefix (<"*", "%", "/">));
  LEFT_ASSOC(sum, product, (<"+", "-">));
  LEFT_ASSOC(shift, sum, (<"<<", ">>">));
  LEFT_ASSOC(rel, shift, (<">", ">=", "<", "<=">));
  LEFT_ASSOC(eq, rel, (<"==", "!=">));
  LEFT_ASSOC(and, eq, (<"&">));
  LEFT_ASSOC(xor, and, (<"^">));
  LEFT_ASSOC(or, xor, (<"|">));
  LEFT_ASSOC(land, or, (<"&&">));
  LEFT_ASSOC(lor, land, (<"||">));

  Expression parse_cond_expression(object tokens_left)
  {
    Expression expr = parse_lor_expression(tokens_left);
    Token token;
    if (tokens_left &&
	(token = tokens_left->value())->symbol == "?") {
      tokens_left->`+=(1);
      Expression true = parse_cond_expression(tokens_left);
      Token token2;
      if (!tokens_left ||
	  (token2 = tokens_left->value())->symbol != ":") {
	SYNTAX_ERROR(token2 || token);
      } else {
	tokens_left->`+=(1);
      }
      return TrinaryExpression(token, expr, token2, true,
			       parse_cond_expression(tokens_left));
    }
    return expr;
  }

  RIGHT_ASSOC(assign, cond, (<"=", "+=", "-=", "*=", "/=">));
  LEFT_ASSOC(comma, assign, (<",">));

  Expression parse_expression(object tokens_left)
  {
    return parse_comma_expression(tokens_left);
  }

  class Class
  {
    inherit Token;

    // Called at
    //   class name '{' · class_body '}'
    void parse_class_body(TokenList tokens, Modifiers|void default_modifiers)
    {
      if (!tokens) return;

      default_modifiers = default_modifiers || Modifiers();

      object tokens_left = __builtin.Iterator(tokens);

      while(tokens_left) {
	Modifiers current_modifiers = default_modifiers;
	object(Token)|Group token;
	while((token = tokens_left->value()) && token->parse_modifier) {
	  tokens_left->`+=(1);
	  token->parse_modifier(tokens_left);
	  current_modifiers += token;
	  if (!tokens_left) {
	    report(ERROR, token->pos, "parser", "Syntax error");
	  }
	}
	if (token->group_start) {
	  if (token->group_start->symbol == "{") {
	    // Modifier scope.
	    parse_class_body(token->contents, current_modifiers);
	  } else {
	    report(ERROR, token->pos, "parser", "Syntax error");
	  }
	  tokens_left->`+=(1);
	} else {
	  if (token->symbol == ";") {
	    tokens_left->`+=(1);
	  } else if (token->parse_meta_program) {
	    // inherit, class, constant, typedef, enum, etc.
	    tokens_left->`+=(1);
	    token->parse_meta_program(this, tokens_left, current_modifiers);
	  } else {
	    // FIXME: variable, function, etc.
	  }
	}
      }
    }

    // Called at
    //   class · [name] [ '(' create_args ')' ] '{' class_body '}'
    void parse_meta_program(Class current_class, object tokens_left,
			    Modifiers current_modifiers)
    {
      if (!tokens_left) {
	report(ERROR, tokens_left->last_pos, "parser", "Syntax error");
	return;
      }
      string name;
      Token token = tokens_left->value();
      if (!token->group_start) {
	name = token->symbol;
	tokens_left->`+=(1);
	token = tokens_left->value();
      }
      if (!token->group_start) {
	report(ERROR, tokens_left->last_pos, "parser", "Syntax error");
	return;
      }
      if (token->group_start->symbol == "(") {
	// FIXME: create_args.
	tokens_left->`+=(1);
	token = tokens_left->value();
	if (!token->group_start) {
	  report(ERROR, tokens_left->last_pos, "parser", "Syntax error");
	  return;
	}
      }
      if (!token->group_start || token->group_start->symbol != "{") {
	report(ERROR, tokens_left->last_pos, "parser", "Syntax error");
	return;
      }
      parse_class_body(token->contents);
      tokens_left->`+=(1);
      current_class->add_constant(current_modifiers, name, this);
    }

    void add_constant(Modifiers modifiers, string name, Token value)
    {
      werror("Defining constant %O with modifiers %O and value %O\n",
	     name, modifiers, value);
    }
  }

  Class parse_program(TokenList tokens)
  {
    Class prog = Class("class","class","class", 0);
    prog->parse_class_body(tokens);
    return prog;
  }

  class pike_tokenizer
  {
    inherit GroupingCompiler::pike_tokenizer;

    // Note: Pike prior to 0.6 used a K&R-style cpp.

    static {
      // Symbol ==> TokenClass
      mapping(string:program(Token)) Pike_0_1_Tokens = ([
	//"array":ArrayType,
	//"break":Break,
	//"case":Case,
	//"catch":Catch,
	"class":Class,
	//"continue":Continue,
	//"default":Default,
	//"do":Do,
	//"predef":Predef,
	//"else":Else,
	//"float":FloatType,
	//"for":For,
	//"foreach":ForEach,
	//"function":FunctionType,
	//"gauge":Gauge,
	//"if":If,
	"inherit":NameSpace,
	"inline":Modifier,
	//"int":IntType,
	//"lambda":Lambda,
	//"multiset":MultisetType,
	//"mapping":MappingType,
	//"mixed":MixedType,
	"nomask":Modifier,
	//"object":ObjectType,
	"private":Modifier,
	//"program":ProgramType,
	"protected":Modifier,
	"public":Modifier,
	//"return":Return,
	//"sscanf":Sscanf,
	"static":Modifier,
	//"string":StringType,
	//"switch":Switch,
	//"typeof":Typeof,
	"varargs":Modifier,
	//"void":VoidType,
	//"while":While,
      ]);

      mapping(string:program(Token)) Pike_0_3_Tokens = Pike_0_1_Tokens + ([
	//"constant":Constant,	// 0.3
      ]);

      mapping(string:program(Token)) Pike_0_4_Tokens = Pike_0_3_Tokens + ([
	"import":NameSpace,	// 0.4.8
      ]);

      mapping(string:program(Token)) Pike_0_6_Tokens = Pike_0_4_Tokens + ([
	"final":Modifier,	// 0.6.36
	"local":Modifier,	// 0.6.36
      ]) - ([
	"varargs":Modifier,	// Obsoleted in 0.6.2
      ]);

      mapping(string:program(Token)) Pike_0_7_Tokens = Pike_0_6_Tokens + ([
	"extern":Modifier,	// 0.7.85
	"optional":Modifier,	// 0.7.85
      ]);

      mapping(string:program(Token)) Pike_7_1_Tokens = Pike_0_7_Tokens + ([
	"variant":Modifier,	// 7.1.3
      ]);

      mapping(string:program(Token)) Pike_7_2_Tokens = Pike_7_1_Tokens + ([
	//"enum":Enum,		// 7.2.27, 7.3.6
	//"typedef":Typedef,	// 7.2.27, 7.3.6
      ]);

      mapping(string:program(Token)) Pike_7_3_Tokens = Pike_7_2_Tokens + ([
	"global":Modifier,	// 7.3.42
      ]);

      array(array(int|mapping(string:program(Token)))) compat_lookup = ({
	({ 7, 3, Pike_7_3_Tokens, }),
	({ 7, 2, Pike_7_2_Tokens, }),
	({ 7, 1, Pike_7_1_Tokens, }),
	({ 0, 7, Pike_0_7_Tokens, }),
	({ 0, 6, Pike_0_6_Tokens, }),
	({ 0, 4, Pike_0_4_Tokens, }),
	({ 0, 3, Pike_0_3_Tokens, }),
	({ 0, 0, Pike_0_1_Tokens, }),
      });

      void handle_pike_compat(int major, int minor)
      {
	if (major < 0) major = 0;
	if (minor < 0) minor = 0;
	foreach(compat_lookup,
		[int maj, int min, mapping(string:program(Token)) tokens]) {
	  if ((maj < major) || (maj == major && (min <= minor))) {
	    token_lookup = tokens;
	    return;
	  }
	}
	// NOT REACHED.
      }

      void create(string data, CompilerContext|void context)
      {
	// Default token_lookup.
	token_lookup = compat_lookup[0][2];

	::create(data, context);
      }
    }
  }

}

#if 0

//  //! Token-value pair.
//  class TokenPair(string token, mixed value)
//  {
//    static string _sprintf() {
//  	return sprintf("%s:%O", token||"", value);
//    }
//  };

class TokenParser
{
  Token handle(string symbol, Position pos, CompilerContext context);
}

class OldMetaProgram
{
  Token handle_symbol(string symbol, Position pos, CompilerContext context);
}

//! Pike 7.2 and earlier token parser.
class Pike72TokenParser_
{
  static {
    // Tokens that are keywords with their own productions.
    constant symbol_is_token = (<
      "array",
      "break",
      "case",
      "catch",			// Could probably be a meta-program.
      "class",
      "constant",
      "continue",
      "default",
      "do",
      "else",
      "enum",
      "extern",
      "float",
      "for",
      "foreach",
      "function",
      "gauge",			// Could probably be a meta program.
      "if",
      "int",
      "lambda",
      "mapping",
      "mixed",
      "object",
      "program",
      "return",
      "sscanf",			// Could probably be a meta-program.
      "string",
      "switch",
      "typedef",
      "typeof",			// Could probably be a meta-program.
      "void",
      "while",
      ")",
      "{","}",
      "[","]",
      "(<",">)",
      "<","<<","<=","<<=",
      ">",">>",">=",">>=",
      ".","..","...",
      ":","::",
      "-","--","->","-=",
      "+","++","+=",
      "&","&&","&=",
      "|","||","|=",
      "^","^=",
      "*","*=",
      "%","%=",
      "=","==",
      "!","!=",
      "/","/=",
      "?",",","~","@",";",
    >);

    // Tokens that are grouped.
    // Currently modifiers and namespace directives.
    constant symbol_to_token = ([
      "final":"modifier",
      "import":"namespace",
      "inherit":"namespace",
      "inline":"modifier",
      "local":"modifier",
      "nomask":"modifier",
      "optional":"modifier",
      "predef":"modifier",
      "private":"modifier",
      "protected":"modifier",
      "public":"modifier",
      "static":"modifier",
      "variant":"modifier",
    ]);
  }

  static string previous_symbol;

  Token handle(string symbol, Position pos, CompilerContext context)
  {
    string old_symbol = previous_symbol;
    previous_symbol = symbol;

    if (symbol_is_token[symbol]) {
      return MKTOKEN(symbol, symbol);
    }
    if (symbol_to_token[symbol]) {
      return MKTOKEN(symbol_to_token[symbol], symbol);
    }

    if (symbol == "(") {
      if ((<"int", "mapping", "function", "object",
	    "program", "array", "multiset">)[old_symbol]) {
	return MKTOKEN("type_specifier", "(");
      } else {
	return MKTOKEN("(", "(");
      }
    }
	
    return 0;
  }
}

TokenParser Pike72TokenParser = Pike72TokenParser_();

//! Pike 7.4 token parser.
class Pike74TokenParser_
{
  Token handle(string symbol, Position pos, CompilerContext context)
  {
    if (symbol == "global") return MKTOKEN("modifier", "global");
    return Pike72TokenParser->handle(symbol, pos, context);
  }
}

TokenParser Pike73TokenParser = Pike73TokenParser_();

//! Pike 7.5 token parser.
class Pike75TokenParser_
{
  array(OldMetaProgram) meta_programs = ({});

  Token handle(string symbol, Position pos, CompilerContext context)
  {
    foreach(meta_programs, OldMetaProgram meta) {
      Token t = meta->handle_symbol(symbol, pos, context);
      if (t) {
	return t;
      }
    }
    return Pike73TokenParser->handle(symbol, pos, context);
  }
}

TokenParser Pike75TokenParser = Pike75TokenParser_();

class Identifier(array(Token) tokens)
{
  string _sprintf(int c)
  {
    return sprintf("IDENTIFIER(%d)", sizeof(tokens));
  }
}

#endif /* 0 */

#if 0

class MetaProgram(Group group)
{
  void parse();
}

class ClassMetaProgram
{
  inherit MetaProgram;

  array(Group) statements;

  void parse()
  {
    if (statements) return;

    statements = ({});

    int g_start;
    int(0..1) is_expr;
    int i;
    object(Group)|Token tok;
    foreach(group->tokens; i; tok) {
      if ((tok->symbol == ";") ||
	  (!is_expr && tok->group_start && tok->group_start->symbol == "{")) {
	// ; always terminates a statement.
	// {} terminates a statement if it isn't in an expression.
	Group g = Group();
	g->token_list = group->token_list[g_start..i];
	statements += ({ g });
	g_start = i+1;
	is_expr = 0;
	continue;
      }
      if (tok->symbol == "=") {
	// Expressions with {}'s are always introduced with an assignment.
	is_expr = 1;
      }
    }
    if (g_start != i) {
      if ((tok->symbol == ";") ||
	  (!is_expr && tok->group_start && tok->group_start->symbol == "{")) {
	// ; always terminates a statement.
	// {} terminates a statement if it isn't in an expression.
	Group g = Group();
	g->token_list = group->token_list[g_start..i];
	statements += ({ g });
      }
    }
    foreach(statements; i; Group g) {
      statements[i] = identify_meta(g);
    }
  }
}

MetaProgram identify_meta(Group g)
{
  foreach(g->tokens; int i; object(Group)|Token tok) {
    if (tok->symbol) {
    }      
  }
}

class Parser
{
  Group g;
  ADT.Stack workload = ADT.Stack();

  int(0..1) parse_raw_stmts(Group g)
  {
    int i;
    int start;
    array(Token) new_tokens = ({});

    for (i=0; i < sizeof(g->tokens); i++) {
      if (g->tokens[i]->token == ";") {
	new_tokens += ({ Group(g->tokens[i]) });
	new_tokens[-1]->group_end = g->tokens[i];
	new_tokens[-1]->tokens = g->tokens[start..i-1];
	start = i+1;
      }
    }
    if (start != i) {
      new_tokens += ({ Group() });
      new_tokens[-1]->tokens = g->tokens[start..i];
    }
    g->tokens = new_tokens;

    return 0;
  }

  int(0..1) parse_identifiers(Group g)
  {
    // Identify identifiers.
    array(Token) new_tokens = ({});
    int i;
    int start;
    for (i=0; i < sizeof(g->tokens); i++) {
      if ((< ".", "::", "identifier" >)[g->tokens[i]->token]) {
	start = i;
	if (g->tokens[i]->token != "identifier") {
	  i++;
	}
	while (i < sizeof(g->tokens)) {
	  if (g->tokens[i]->token != "identifier") {
	    // error!
	    break;
	  }
	  i++;
	  if ((i == sizeof(g->tokens)) ||
	      !(< ".", "::" >)[g->tokens[i]->token]) {
	    // Done.
	    break;
	  }
	  i++;
	}
	i--;
	new_tokens += ({ Identifier(g->tokens[start..i]) });
      } else {
	new_tokens += ({ g->tokens[i] });
      }
    }
    g->tokens = new_tokens;
  }

  constant left_pri = ([
    ",":2,
    "=":3,
    ":":5, "?":5,
    "||":8,
    "&&":10,
    "|":12,
    "^":14,
    "&":16,
    "==":17, "!=":17,
    ">":19, ">=":19, "<":19, "<=":19,
    "<<":21, ">>":21,
    "+":24, "-":24,
    "*":26, "%":26, "/":26,
    "!":27, "~":27,
    "++":29, "--":29,
  ]);

  constant right_pri = ([
    ",":1,
    "=":3,
    ":":5, "?":5,
    "||":7,
    "&&":9,
    "|":11,
    "^":13,
    "&":15,
    "==":17, "!=":17,
    ">":19, ">=":19, "<":19, "<=":19,
    "<<":21, ">>":21,
    "+":23, "-":23,
    "*":25, "%":25, "/":25,
    "!":27, "~":27,
    "++":29, "--":29,
  ]);

  constant un_op = ([]);

  Group|Token parse_expression(ADT.Stack input)
  {
    ADT.Stack expr = ADT.Stack();
    int top_pri;

    while (sizeof(input)) {
      // Get operand 1.
      object(Group)|Token top = input->top();

      if (top_pri <= right_pri[top->token]) {
	/* SHIFT */
	expr->push(input->pop());
	top_pri = left_pri[top->token];
      } else {
	/* REDUCE */
	array items = ({});
      }

#if 0
      while (un_op[top->token]) {
	break;
      }
#endif /* 0 */
    }
    
  }

  int(0..1) parse_class_block(Group g)
  {
    if (parse_raw_stmts(g)) return 1;

    // For each statement
    foreach(g->tokens; ; object(Group)|Token g) {
      if (g->tokens) {
	parse_identifiers(g);

	// Initialize an input stack for the expression parser.
	ADT.Stack stack = ADT.Stack();
	stack->set_stack(reverse(g->tokens));

	array(Group|Token) new_tokens = ({});

	while(sizeof(stack)) {
	  new_tokens += ({ parse_expression(stack) });
	}

	g->tokens = new_tokens;
      } else {
	// Error?
      }
    }
    return 0;
  }

  static void create(Group g)
  {
    this_program::g = g;
    g->parse_method = parse_class_block;
    workload->push(g);
  }

  Group parse()
  {
    while (sizeof(workload)) {
      Group tmp = workload->pop();
      if (tmp->parse_method(tmp)) {
	// Parse error.
	return 0;
      }
    }
    return g;
  }
}

Group parse(Group g)
{
  return Parser(g)->parse();
}

class DEF_LIST
{
  inherit BinaryNode;
  constant nodename="Tokenizer.DEF_LIST";
}

class MODIFIER_BLOCK
{
  inherit BinaryNode;
  constant nodename="Tokenizer.MODIFIER_BLOCK";
}

#endif /* 0 */
