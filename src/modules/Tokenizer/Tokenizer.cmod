/*
 * $Id: Tokenizer.cmod,v 1.19 2004/04/01 12:37:06 grubba Exp $
 *
 * Interface to pike code tokenizer.
 *
 * Henrik Grubbström 2002-07-11
 */

#include "global.h"

#include "config.h"

#include "svalue.h"
#include "object.h"
#include "mapping.h"
#include "interpret.h"
#include "operators.h"
#include "builtin_functions.h"
#include "pike_types.h"
#include "stralloc.h"
#include "sscanf.h"
#include "module.h"

DECLARATIONS

/*
 * Convenience macro to apply functions in current object.
 */
#define APPLY_SELF(REF_NO, ARGS)				\
  apply_low(Pike_fp->current_object,				\
	    Pike_fp->context.identifier_level + (REF_NO),	\
	    (ARGS))

/*! @module Tokenizer
 */

/*! @decl enum SeverityLevel
 *!   Message severity level.
 *! { NOTICE, WARNING, ERROR, FATAL }
 *!
 *! @constant NOTICE
 *! @constant WARNING
 *! @constant ERROR
 *! @constant FATAL
 *!
 *! @seealso
 *!   @[compiler()->report()]
 */

#define SL_NOTICE 0
#define SL_WARNING 1
#define SL_ERROR 2
#define SL_FATAL 3

/*! @class Compiler
 */
PIKECLASS compiler
  flags ID_STATIC;
{
  /*! @decl void report(SeverityLevel severity, @
   *!			mapping(string:int|string) context, @
   *!                   string subsystem, string msg, mixed ... extra_args)
   *!   Function called to report messages.
   *!
   *! @param severity
   *!   Message severity.
   *!
   *! @param context
   *!   Context where the message occurred.
   *!
   *! @param subsystem
   *!   Subsystem where the message was generated. Currently one of
   *!   @string
   *!     @value "preprocessor"
   *!     @value "scanner"
   *!     @value "grouping"
   *!   @endstring
   *!
   *! @param msg
   *!   Message. This is taken to be a @[sprintf()] format string
   *!   if @[extra_args] are specified.
   *!
   *! @param extra_args
   *!   Parameters to @[sprintf()] @[msg].
   *!
   *!   The default implementation reports to stderr.
   *!
   *! @note
   *!   The default implementation currently does no parsing of @[context].
   *!
   *! @note
   *!   Overload this function to change the report formatting,
   *!   or to redirect the output.
   *!
   *! @seealso
   *!   @[SeverityLevel]
   */
  PIKEFUN void report(int(0..3) severity, mapping(string:int|string) context,
		      string subsystem, string msg, mixed ... extra_args)
  {
    if (args > 4) {
      f_sprintf(args-3);
      args = 4;
    }
    switch(severity) {
    case SL_NOTICE:
      REF_MAKE_CONST_STRING(Pike_sp[-4].u.string,
			    "NOTICE:%O:%O:%O\n");
      break;
    case SL_WARNING:
      REF_MAKE_CONST_STRING(Pike_sp[-4].u.string,
			    "WARNING:%O:%O:%O\n");
      break;
    case SL_ERROR:
      REF_MAKE_CONST_STRING(Pike_sp[-4].u.string,
			    "ERROR:%O:%O:%O\n");
      break;
    case SL_FATAL:
      REF_MAKE_CONST_STRING(Pike_sp[-4].u.string,
			    "FATAL:%O:%O:%O\n");
      break;

    default:
      Pike_error("Unknown severity level: %"PRINTPIKEINT"d\n", severity);
      break;
    }
    Pike_sp[-args].type = PIKE_T_STRING;
    Pike_sp[-args].subtype = 0;
    f_werror(args);
    args = 1;
  }

  /*! @class basic_tokenizer
   */
  PIKECLASS basic_tokenizer
    program_flags PROGRAM_USES_PARENT;
  {
    // String being converted.
    CVAR struct pike_string *data;

    // Position in string.
    CVAR int pos;

    // Token number in stream.
    PIKEVAR int(0..) token_num;

    /*! @decl mapping(string:int|string) context
     *!
     *!   Current context.
     *!
     *!   The following contextual information is available:
     *!   @mapping
     *!     @member int(1..) "line"
     *!       Current line number.
     *!   @endmapping
     *!
     *! @note
     *!   Do NOT perform destructive operations on the mapping,
     *!   since it may be shared with other data structures.
     */
    PIKEVAR mapping(string:int|string) context;

    /*! @decl string current_symbol
     *!
     *!   Current symbol.
     *!
     *!   Set by @[scan()]. Is set to @tt{0@} (zero) at end of stream.
     *!
     *! @seealso
     *!   @[scan()]
     */
    PIKEVAR string current_symbol;

    // Current scanner.
    CVAR void (*scanner)(struct compiler_basic_tokenizer_struct *);

    /*! @decl void report(SeverityLevel severity, @
     *!			  mapping(string:int|string) context, @
     *!                   string subsystem, string msg, mixed ... extra_args)
     *!   Function called to report messages.
     *!
     *!   This function acts as a relay to @[Tokenizer.compiler()->report()],
     *!   and exists for overloading purposes.
     *!
     *! @seealso
     *!   @[Tokenizer.compiler()->report()]
     */
    PIKEFUN void report(int(0..3) severity,
			mapping(string:int|string)|int context,
			string subsystem, string msg, mixed ... extra_args)
    {
      if (context->type == PIKE_T_INT) {
	add_ref(context->u.mapping = THIS->context);
	context->type = T_MAPPING;
      }
      apply_external(1, f_compiler_report_fun_num, args);
    }

    /* Helper function for the most common case. */
    static void report_error(const char *msg)
    {
      push_int(2);
      ref_push_mapping(THIS->context);
      ref_push_string(MK_STRING("scanner"));
      push_text(msg);
      apply_current(f_compiler_basic_tokenizer_report_fun_num, 4);
      pop_stack();
    }

#define gobble(C)	(((this->pos < this->data->len) && \
			  (str[this->pos] == (C)))?(this->pos++,1):0)

    static inline void detach_context(struct compiler_basic_tokenizer_struct *this)
    {
      if (this->context->refs > 1) {
	/* Detach the mapping from other users. */
	struct mapping *m = copy_mapping(this->context);
	free_mapping(this->context);
	this->context = m;
      }
    }

    static void inc_line_no(struct compiler_basic_tokenizer_struct *this,
			    int increment)
    {
      struct mapping *m;
      struct svalue *old;
      if (!increment) return;
      detach_context(this);
      m = this->context;
      ref_push_string(MK_STRING("line"));
      old = low_mapping_lookup(m, Pike_sp-1);
      if (old && (old->type == T_INT)) {
	/* FIXME: Bignums? */
	push_int(old->u.integer + increment);
      } else {
	push_int(increment);
      }
      low_mapping_insert(m, Pike_sp-2, Pike_sp-1, 1);
      pop_n_elems(2);
    }

    /*! @decl void set_context(string property, int|string value)
     *!
     *!   Set @[property] in @[context] to @[value], and
     *!   perform any needed detaching.
     */
    PIKEFUN void set_context(string property, int|string value)
    {
      detach_context(THIS);

      low_mapping_insert(THIS->context, Pike_sp-2, Pike_sp-1, 1);
    }

    /*! @decl int|string get_context(string property)
     *! @decl mapping(string:int|string) get_context()
     *!
     *!   Either get a single @[property] from @[context],
     *!   or return the entire mapping @[context].
     *!
     *!   Equvivalent to:
     *!   @code
     *!     @[context][@[property]]
     *!       // or
     *!     @[context]
     *!   @endcode
     *!
     *!   Provided to simplify C code.
     */
    PIKEFUN int|string|mapping(string:int|string) get_context(string|void property)
      type function(string:int|string)|function(:mapping(string:int|string));
    {
      struct svalue *val;
      if (!property) {
	pop_n_elems(args);
	ref_push_mapping(THIS->context);
	return;
      }
      val = low_mapping_lookup(THIS->context, Pike_sp-1);
      pop_stack();
      if (val) {
	push_svalue(val);
      } else {
	push_undefined();
      }
    }

#define MAKE_SCANNER(SHIFT)						\
    static void PIKE_CONCAT(scan, SHIFT)				\
		     (struct compiler_basic_tokenizer_struct *this)	\
    {									\
      PIKE_CONCAT(p_wchar, SHIFT) *str = 				\
	PIKE_CONCAT(STR, SHIFT)(this->data);				\
      while (this->pos < this->data->len) {				\
	int start = this->pos;						\
	int c = str[this->pos++];					\
	switch(c) {							\
	case '\n':							\
	  inc_line_no(this, 1);						\
	  /* FALL_THROUGH */						\
	case ' ': case '\t': case '\r':					\
	  /* Plain whitespace. */					\
	  continue;							\
									\
	case '\033':	/* ESC */					\
	case '\233':	/* CSI */					\
	  /* Assume ANSI/DEC escape sequence.				\
	   * Format supported:						\
	   *	    <ESC>[\040-\077]+[\100-\177]			\
	   * or								\
	   *	    <CSI>[\040-\077]*[\100-\177]			\
	   */								\
	  while ((this->pos < this->data->len) &&			\
		 (((c = str[this->pos++]) & ~0x1f) == 0x20))		\
	    ;								\
	  if ((c & ~0x3f) != 0x40) {					\
	    /* FIXME: Warning here? */					\
	    this->pos--;						\
	  }								\
	  continue;							\
									\
	case '#':							\
	  /* Preprocessor-style directive (#line, pragma, etc). */	\
	  while (this->pos < this->data->len) {				\
	    if (((c = str[this->pos++]) == '\n') || (c == '\r')) {	\
	      this->pos--;						\
	      break;							\
	    }								\
	  }								\
	  break;							\
									\
	case '0':							\
	  /* Octal, binary, hexadecimal or float number */		\
	  gobble('b')||gobble('B')||gobble('x')||gobble('X');		\
	  /* FALL_THROUGH */						\
	case '1':							\
	case '2':							\
	case '3':							\
	case '4':							\
	case '5':							\
	case '6':							\
	case '7':							\
	case '8':							\
	case '9':							\
	  /* Number. */							\
									\
	  /* Note: Exponent handling is included in			\
	   * the hexadecimal range.					\
	   */								\
	  while(this->pos < this->data->len) {				\
	    c = str[this->pos];						\
	    if ((c < '0') || ((c > '9') && (c < 'A')) ||		\
		((c > 'F') && (c < 'a')) || (c > 'f')) {		\
	      break;							\
	    }								\
	    this->pos++;						\
	  }								\
	  break;							\
									\
	case '\'':							\
	case '\"':							\
	  {								\
	    /* String or character constant. */				\
	    int d;							\
	    while ((this->pos < this->data->len) &&			\
		   ((d = str[this->pos]) != '\n') &&			\
		   (d != '\r') && (this->pos++, (d != c))) {		\
	      if (d == '\\') {						\
	        if (this->pos < this->data->len) {			\
		  d = str[this->pos];					\
		  if ((d == '\r') || (d == '\n')) {			\
		    break;						\
		  }							\
		  this->pos++;						\
	        }							\
	      }								\
	    }								\
	  }								\
	  break;							\
									\
	  /* Operators. */						\
	case ':':							\
	  gobble(':');							\
	  break;							\
									\
	case '.':							\
	  gobble('.') && gobble('.');					\
	  break;							\
									\
	case '-':							\
	  if (gobble('>')) break;					\
	  /* FALL_THROUGH */						\
	case '+':							\
	case '&':							\
	case '|':							\
	  if (gobble(c)) break;						\
	  /* FALL_THROUGH */						\
	case '^':							\
	case '*':							\
	case '%':							\
	case '=':							\
	case '!':							\
	  gobble('=');							\
	  break;							\
									\
	case '/':							\
	  if (gobble('*')) {						\
	    int no = 0;							\
	    do {							\
	      if (gobble('*') && gobble('/')) {				\
		break;							\
	      }								\
	      if (gobble('\n')) {					\
		no++;							\
	      } else {							\
		this->pos++;						\
	      }								\
	    } while (this->pos < this->data->len);			\
	    if (this->pos >= this->data->len) {				\
	      report_error("Unterminated comment.");			\
	    }								\
	    inc_line_no(this, no);					\
	  } else if (gobble('/')) {					\
	    while ((this->pos < this->data->len) &&			\
		   (str[this->pos] != '\n')){				\
	      this->pos++;						\
	    }								\
	    if (this->pos >= this->data->len) {				\
	      report_error("Unterminated comment.");			\
	    }								\
	  } else {							\
	    gobble('=');						\
	  }								\
	  break;							\
									\
	case '>':							\
	  if (gobble(')')) break;					\
	  /* FALL_THROUGH */						\
	case '<':							\
	  gobble(c);							\
	  gobble('=');							\
	  break;							\
									\
	case '(':							\
	  gobble('<');							\
	  break;							\
									\
	case ']':							\
	case '?':							\
	case ',':							\
	case '~':							\
	case '@':							\
	case ')':							\
	case '[':							\
	case '{':							\
	case ';':							\
	case '}':							\
	  break;							\
									\
	case '`':							\
	  gobble('`');							\
	  gobble('`');							\
									\
	  if (this->pos < this->data->len) {				\
	    switch(c = str[this->pos++]) {				\
	    case '/':							\
	    case '%':							\
	    case '*':							\
	    case '&':							\
	    case '|':							\
	    case '^':							\
	    case '~':							\
	      break;							\
									\
	    case '<':							\
	    case '>':							\
	      if (gobble(c)) break;					\
	      /* FALL_THROUGH */					\
	    case '+':							\
	    case '!':							\
	    case '=':							\
	      gobble('=');						\
	      break;							\
									\
	    case '(':							\
	      if (!gobble(')')) {					\
		report_error("Illegal ` identifier. Expected `().");	\
		push_string(string_slice(this->data,			\
					 start, this->pos - start));	\
		push_constant_text(")");				\
		f_add(2);						\
	        this->current_symbol = Pike_sp[-1].u.string;		\
		Pike_sp--;						\
		return;							\
	      }								\
	      break;							\
									\
	    case '-':							\
	      if (gobble('>')) {					\
		gobble('=');						\
	      }								\
	      break;							\
									\
	    case '[':							\
	      if (!gobble(']')) {					\
		report_error("Illegal ` identifier. Expected `[].");	\
		push_string(string_slice(this->data,			\
					 start, this->pos - start));	\
		if (gobble('=')) {					\
		  push_constant_text("]=");				\
		} else {						\
		  push_constant_text("]");				\
		}							\
		f_add(2);						\
	        this->current_symbol = Pike_sp[-1].u.string;		\
		Pike_sp--;						\
		return;							\
	      }								\
	      gobble('=');						\
	      break;							\
									\
	    default:							\
	      report_error("Illegal ` identifier.");			\
	      this->pos--;						\
	      break;							\
	    }								\
	  } else {							\
	    report_error("Illegal ` identifier at end of file.");	\
	  }								\
	  break;							\
									\
	default:							\
	  if ((c >= 256) || isidchar(c)) {				\
	    /* Identifier. */						\
	    while(this->pos < this->data->len) {			\
	      if ((!((c = str[this->pos]) & ~0xff)) && !isidchar(c)) {	\
	        break;							\
	      }								\
	      this->pos++;						\
	    }								\
	    break;							\
	  }								\
									\
	  /* Error. */							\
	  push_int(2);							\
	  ref_push_mapping(THIS->context);				\
	  push_constant_text("scanner");				\
	  push_constant_text("Illegal character (hex %02x) '%c'");	\
	  push_int(c);							\
	  push_int(c);							\
	  apply_current(f_compiler_basic_tokenizer_report_fun_num, 6);	\
	  pop_stack();							\
	  continue;							\
	}								\
	this->current_symbol = string_slice(this->data,			\
					   start, this->pos - start);	\
	return;								\
      }									\
    }

    MAKE_SCANNER(0)
    MAKE_SCANNER(1)
    MAKE_SCANNER(2)

    /*! @decl void scan()
     *!
     *!   Called to advance one token in the stream.
     *!
     *!   The new token is stored in @[current_symbol].
     *!
     *! @note
     *!   This function is not callable directly, but may be overloaded.
     */
    PIKEFUN void scan()
      flags ID_STATIC;
    {
      if (THIS->current_symbol) {
	free_string(THIS->current_symbol);
	THIS->current_symbol = NULL;
      }

      if (!THIS->scanner) {
	if (THIS->data) {
	  if (!THIS->data->size_shift) {
	    THIS->scanner = scan0;
	  } else if (THIS->data->size_shift == 1) {
	    THIS->scanner = scan1;
	  } else {
	    THIS->scanner = scan2;
	  }
	} else {
	  /* No data. */
	  return;
	}
      }
      THIS->scanner(THIS);
      if (THIS->current_symbol) {
	THIS->token_num++;
      }
    }

    /*! @decl void create(string data)
     *!
     *! Initialize the basic tokenizer.
     *!
     *! @param data
     *!   String to tokenize.
     */
    PIKEFUN void create(string data)
      flags ID_STATIC;
    {
      if (THIS->data) {
	free_string(THIS->data);
      }
      copy_shared_string(THIS->data, data);

      THIS->pos = 0;
      THIS->token_num = 0;

      detach_context(THIS);
      ref_push_string(MK_STRING("line"));
      push_int(1);
      low_mapping_insert(THIS->context, Pike_sp-2, Pike_sp-1, 1);
      pop_n_elems(2);

      if (THIS->current_symbol) {
	free_string(THIS->current_symbol);
	THIS->current_symbol = NULL;
      }

      THIS->scanner = NULL;

      apply_current(f_compiler_basic_tokenizer_scan_fun_num, 0);
      pop_stack();
    }

    /*! @decl int(0..1) `!()
     *!
     *! Check for end of stream.
     *!
     *! @returns
     *!   Returns 1 at end of stream.
     */
    PIKEFUN int(0..1) `!()
      flags ID_STATIC;
    {
      RETURN !THIS->current_symbol;
    }

    PIKEFUN object `+=(int n)
      flags ID_STATIC;
    {
      while (n-- > 0) {
	apply_current(f_compiler_basic_tokenizer_scan_fun_num, 0);
	pop_stack();
      }
      pop_n_elems(args);
      f_this_object(0);
    }

    PIKEFUN int index()
    {
      RETURN THIS->token_num;
    }

    PIKEFUN string value()
    {
      add_ref(THIS->current_symbol);
      RETURN THIS->current_symbol;
    }

    INIT
    {
      THIS->data = NULL;
      THIS->scanner = NULL;
      THIS->pos = 0;
      THIS->token_num = 0;
      THIS->current_symbol = NULL;
      THIS->context = allocate_mapping(8);
    }

    EXIT
    {
      if (THIS->data) {
	free_string(THIS->data);
	THIS->data = NULL;
      }
      THIS->scanner = NULL;
    }
  } 

  /*! @endclass
   */
}
/*! @endclass
 */

/*! @class Token
 */
PIKECLASS Token
{
  /*! @decl string symbol
   *!
   *! Raw symbol as found in the source code.
   */
  PIKEVAR string symbol;

  /*! @decl mapping(string:string|int) context
   *!
   *!   Context information.
   *!
   *! @seealso
   *!   @[Tokenizer.Context]
   */
  PIKEVAR mapping(string:string|int) context;

  EXTRA
  {
    struct svalue tmp = {
      PIKE_T_STRING, 0, { 0 },
    };
    tmp.u.string = MK_STRING("token");
    add_constant(MK_STRING("token"), &tmp, 0);
  }

  PIKEFUN void create(string symbol, mapping(string:string|int) context)
    flags ID_STATIC;
  {
    if (THIS->symbol) {
      free_string(THIS->symbol);
      THIS->symbol = NULL;
    }
    copy_shared_string(THIS->symbol, symbol);
    if (THIS->context) {
      free_mapping(THIS->context);
    }
    add_ref(THIS->context = context);
  }

  PIKEFUN string _sprintf(int format, mapping(string:string|int) options)
    flags ID_STATIC;
  {
    if (format == 's') {
      if (THIS->symbol) {
	ref_push_string(THIS->symbol);
      } else {
	ref_push_string(MK_STRING("NONE"));
      }
    } else {
      push_text("%O:%s");
      ref_push_mapping(THIS->context);
      if (THIS->symbol) {
	ref_push_string(THIS->symbol);
      } else {
	ref_push_string(MK_STRING("NONE"));
      }
      f_sprintf(3);
    }
    stack_pop_n_elems_keep_top(args);
    return;
  }
}

/*! @endclass
 */

/*! @class IdentifierToken
 */
PIKECLASS IdentifierToken
{
  INHERIT Token;

  EXTRA
  {
    struct svalue tmp = {
      PIKE_T_STRING, 0, { 0 },
    };
    tmp.u.string = MK_STRING("identifer");
    simple_add_constant("token", &tmp, 0);
    add_integer_constant("is_identifier", 1, 0);
  }
}
/*! @endclass
 */

/*! @class OperatorToken
 */
PIKECLASS OperatorToken
{
  INHERIT Token;

  EXTRA
  {
    struct svalue tmp = {
      PIKE_T_STRING, 0, { 0 },
    };
    tmp.u.string = MK_STRING("operator");
    simple_add_constant("token", &tmp, 0);
    add_integer_constant("is_operator", 1, 0);
  }
}
/*! @endclass
 */

/*! @class LiteralToken
 */
PIKECLASS LiteralToken
{
  INHERIT Token;

  PIKEVAR mixed value;

  static int literal_token_inherited_create;

  INIT
  {
    THIS->value.type = PIKE_T_INT;
    THIS->value.subtype = NUMBER_UNDEFINED;
    THIS->value.u.integer = 0;
  }

  EXTRA
  {
    struct svalue tmp = {
      PIKE_T_STRING, 0, { 0 },
    };
    tmp.u.string = MK_STRING("literal");
    simple_add_constant("token", &tmp, 0);
    add_integer_constant("is_literal", 1, 0);
    /* We want to access the inherited create(). */
    literal_token_inherited_create =
      really_low_reference_inherited_identifier(NULL, 1,
						f_Token_create_fun_num);
  }

  PIKEFUN void create(string token, mapping(string:string|int) pos,
		      mixed value)
    flags ID_STATIC;
  {
    assign_svalue(&THIS->value, value);
    pop_stack();
    APPLY_SELF(literal_token_inherited_create, 2);
  }
}
/*! @endclass
 */

/*! @class StringToken
 */
PIKECLASS StringToken
{
  INHERIT LiteralToken;

  EXTRA
  {
    struct svalue tmp = {
      PIKE_T_STRING, 0, { 0 },
    };
    tmp.u.string = MK_STRING("string_constant");
    simple_add_constant("token", &tmp, 0);
    add_integer_constant("is_string", 1, 0);

    /* Modify the type of "value". */
    simple_add_variable("value", "string", 0);
    /* FIXME: Do the same for create()? */
  }
}
/*! @endclass
 */

/*! @class IntegerToken
 */
PIKECLASS IntegerToken
{
  INHERIT LiteralToken;

  EXTRA
  {
    struct svalue tmp = {
      PIKE_T_STRING, 0, { 0 },
    };
    tmp.u.string = MK_STRING("int_constant");
    simple_add_constant("token", &tmp, 0);
    add_integer_constant("is_int", 1, 0);

    /* Modify the type of "value". */
    simple_add_variable("value", "int", 0);
    /* FIXME: Do the same for create()? */
  }
}
/*! @endclass
 */

/*! @class FloatToken
 */
PIKECLASS FloatToken
{
  INHERIT LiteralToken;

  EXTRA
  {
    struct svalue tmp = {
      PIKE_T_STRING, 0, { 0 },
    };
    tmp.u.string = MK_STRING("float_constant");
    simple_add_constant("token", &tmp, 0);
    add_integer_constant("is_float", 1, 0);

    /* Modify the type of "value". */
    simple_add_variable("value", "float", 0);
    /* FIXME: Do the same for create()? */
  }
}
/*! @endclass
 */

/*! @class TokenizingCompiler
 */
PIKECLASS TokenizingCompiler
{
  /*! @decl inherit Compiler
   */
  INHERIT compiler;

  /*! @class pike_tokenizer
   *!
   *!   Pike tokenizer.
   */
  PIKECLASS pike_tokenizer
  {
    static int tc_pt_inh_report = -1;
    static int tc_pt_inh_scan = -1;
    static int tc_pt_inh_current_symbol = -1;
    static int tc_pt_inh_set_context = -1;
    static int tc_pt_inh_get_context = -1;

    EXTRA
    {
      /* Perform an inherit of the "basic_tokenizer" that our parent
       * contains through its inherit of "compiler".
       */
      /* FIXME: We may want to extend precompile.pike to handle
       *        this automatically.
       */
      /*! @decl inherit basic_tokenizer
       */
      low_inherit(compiler_basic_tokenizer_program,
		  0,
		  compiler_basic_tokenizer_program_fun_num +
		  Pike_compiler->previous->new_program->inherits[1].identifier_level,
		  1 + 42,
		  0,
		  NULL);
      tc_pt_inh_report =
	really_low_reference_inherited_identifier(NULL, 1,
						  f_compiler_basic_tokenizer_report_fun_num);
      tc_pt_inh_scan =
	really_low_reference_inherited_identifier(NULL, 1,
						  f_compiler_basic_tokenizer_scan_fun_num);
      /* FIXME: Ought to save the identifier numbers for variables too. */
      tc_pt_inh_current_symbol =
	low_reference_inherited_identifier(NULL, 1,
					   MK_STRING("current_symbol"),
					   SEE_STATIC);
      tc_pt_inh_set_context =
	really_low_reference_inherited_identifier(NULL, 1,
						  f_compiler_basic_tokenizer_set_context_fun_num);
      tc_pt_inh_get_context =
	really_low_reference_inherited_identifier(NULL, 1,
						  f_compiler_basic_tokenizer_get_context_fun_num);
    }

    /*! @decl mapping(string:int|string) context
     *!   Context information (inherited from @[basic_tokenizer]).
     *!
     *!   The context information provided by @[basic_tokenizer]
     *!   is further extended with the following:
     *!   @mapping
     *!     @member string "file"
     *!       Filename where the token was found.
     *!
     *!     @member int(0..) "pike_major"
     *!     @member int(0..) "pike_minor"
     *!       Major and minor version of Pike to be emulated.
     *!
     *!     @member string "pragma_*"
     *!       State of pragma @tt{*@}. Only present if a corresponding
     *!       @tt{#pragma@} statement is active.
     *!   @endmapping
     *!
     *! @note
     *!   As noted before: Do NOT perform destructive changes on this
     *!   mapping.
     *!
     *! @seealso
     *!   @[get_context()], @[set_context()]
     */

    PIKEVAR object(Token) current_token;

    PIKEVAR mapping(string:program(Token)) token_lookup;

    PIKEFUN void yyerror(string msg, mixed ... extras)
      flags ID_STATIC;
    {
      if (extras) {
	f_sprintf(args);
      }
      push_int(0);
      ref_push_string(MK_STRING("scanner"));
      Pike_sp[0] = Pike_sp[-3];
      Pike_sp[-3].type = PIKE_T_INT;
      Pike_sp[-3].subtype = 0;
      Pike_sp[-3].u.integer = SL_ERROR;
      Pike_sp++;

      APPLY_SELF(tc_pt_inh_report, 4);
    }

    PIKEFUN void handle_pragma(string pragma, string rest)
      flags ID_STATIC;
    {
      /* Store pragmas in context prefixed with "pragma_" */
      ref_push_string(MK_STRING("pragma_"));
      ref_push_string(pragma);
      f_add(2);
      ref_push_string(rest);
      APPLY_SELF(tc_pt_inh_set_context, 2);
      pop_n_elems(2);	/* Keep one element on the stack. */
    }

    PIKEFUN string parse_string(string raw)
      flags ID_STATIC;
    {
      struct string_builder buf;
      ONERROR err;

      if (raw->len == 0) {
	ref_push_string(MK_STRING("Empty string passed to parse_string()."));
	APPLY_SELF(f_TokenizingCompiler_pike_tokenizer_yyerror_fun_num, 1);
	pop_stack();
	return;	/* Return the empty string */
      }
      if ((raw->len < 2) ||
	  (index_shared_string(raw, 0) !=
	   index_shared_string(raw, raw->len-1))) {
	ref_push_string(raw);
	ref_push_string(MK_STRING("Unterminated string or character constant %s."));
	APPLY_SELF(f_TokenizingCompiler_pike_tokenizer_yyerror_fun_num, 2);
	pop_stack();
      }

      /* The result will be at least as wide as the raw string. */
      init_string_builder(&buf, raw->size_shift);
      SET_ONERROR(err, free_string_builder, &buf);

      switch(raw->size_shift)
      {
#define PS_CASE(SHIFT)							\
      case SHIFT:							\
	{								\
	  PIKE_CONCAT(p_wchar, SHIFT) *raw_str;				\
	  ptrdiff_t off;						\
	  raw_str = PIKE_CONCAT(STR,SHIFT)(raw);			\
	  for (off = 1; off < raw->len-1; off++) {			\
	    ptrdiff_t end = off;					\
	    while ((end < raw->len-1) && (raw_str[end] != '\\')) {	\
	      end++;							\
	    }								\
	    if (off != end) {						\
	      string_builder_append(&buf, MKPCHARP(raw_str+off, 0),	\
				    end - off);				\
	      off = end;						\
	    }								\
	    if (off+1 < raw->len-1) {					\
	      p_wchar2 code;						\
	      switch(code = raw_str[++off]) {				\
	      case 'a':	/* Alert (BEL), 7 */				\
		string_builder_putchar(&buf, 7);			\
		break;							\
	      case 'b':	/* Backspace (BS), 8 */				\
		string_builder_putchar(&buf, 8);			\
		break;							\
	      case 't':	/* Tab (HT), 9 */				\
		string_builder_putchar(&buf, 9);			\
		break;							\
	      case 'n':	/* Newline (LF), 10 */				\
		string_builder_putchar(&buf, 10);			\
		break;							\
	      case 'v':	/* Vertical tab (VT), 11 */			\
		string_builder_putchar(&buf, 11);			\
		break;							\
	      case 'f':	/* Form-feed (FF), 12 */			\
		string_builder_putchar(&buf, 12);			\
		break;							\
	      case 'r':	/* Return (CR), 13 */				\
		string_builder_putchar(&buf, 13);			\
		break;							\
	      case 'e':	/* Escape (ESC), 27 */				\
		string_builder_putchar(&buf, 27);			\
		break;							\
									\
	      case '0':							\
	      case '1':							\
	      case '2':							\
	      case '3':							\
	      case '4':							\
	      case '5':							\
	      case '6':							\
	      case '7':	/* Octal escape. */				\
		{							\
		  p_wchar2 val = 0;					\
		  p_wchar2 c;						\
		  while ((off < raw->len) &&				\
			 ((c = raw_str[off]) <= '7') &&			\
			 (c >= '0')) {					\
		    val = val*8 + (c - '0');				\
		    off++;						\
		  }							\
		  string_builder_putchar(&buf, val);			\
		  off--;						\
		}							\
		break;							\
									\
	      case 'd':	/* Decimal escape. */				\
		{							\
		  p_wchar2 val = 0;					\
		  p_wchar2 c;						\
		  off++;						\
		  while ((off < raw->len) &&				\
			 ((c = raw_str[off]) <= '9') &&			\
			 (c >= '0')) {					\
		    val = val*10 + (c - '0');				\
		    off++;						\
		  }							\
		  string_builder_putchar(&buf, val);			\
		  off--;						\
		}							\
		break;							\
									\
	      case 'U':	/* Length 8 unicode escape. */			\
		if (off+8 < (end = raw->len)) {				\
		  end = off+9;						\
		}							\
		goto PIKE_CONCAT(do_read_hex, SHIFT);			\
	      case 'u':	/* Length 4 unicode escape. */			\
		if (off+4 < (end = raw->len)) {				\
		  end = off+5;						\
		}							\
		goto PIKE_CONCAT(do_read_hex, SHIFT);			\
	      case 'x':	/* Hexadecimal escape. */			\
		end = raw->len;						\
	      PIKE_CONCAT(do_read_hex, SHIFT):				\
		{							\
		  p_wchar2 val = 0;					\
		  p_wchar2 c;						\
		  off++;						\
		  while ((off < end) &&					\
			 ((c = raw_str[off]) <= 'f') &&			\
			 (c >= '0') &&					\
			 ((c <= '9') || (c >= 'a') ||			\
			  ((c >= 'A') && (c <= 'F')))) {		\
		    val *= 16;						\
		    if (c >= 'A') {					\
		      val += (c+(10-'A')) & 15;				\
		    } else {						\
		      val += c - '0';					\
		    }							\
		    off++;						\
		  }							\
		  string_builder_putchar(&buf, val);			\
									\
		  if ((code != 'x') && (off != end)) {			\
		    /* Short Unicode escape. */				\
		  }							\
		  off--;						\
		}							\
		break;							\
									\
	      default:							\
		/* FIXME: Warn? */					\
	      case '\\':						\
	      case '\"':						\
	      case '\'':						\
		string_builder_putchar(&buf, code);			\
		break;							\
	      }								\
	    }								\
	  }								\
	}								\
	break
	PS_CASE(0);
	PS_CASE(1);
	PS_CASE(2);
#undef PS_CASE
      default:
	push_int(raw->size_shift);
	ref_push_string(raw);
	ref_push_string(MK_STRING("Unsupported string shift %d on string %O."));
	APPLY_SELF(f_TokenizingCompiler_pike_tokenizer_yyerror_fun_num, 3);
	pop_stack();
	break;
      }
      push_string(finish_string_builder(&buf));
      stack_pop_n_elems_keep_top(args);
    }

    PIKEFUN void handle_pike_compat(int major, int minor)
      flags ID_STATIC;
    {
      ref_push_string(MK_STRING("pike_major"));
      push_int(major);
      APPLY_SELF(tc_pt_inh_set_context, 2);
      ref_push_string(MK_STRING("pike_minor"));
      push_int(minor);
      APPLY_SELF(tc_pt_inh_set_context, 2);
      pop_n_elems(4-1);	/* Keep one element on the stack. */
    }

    PIKEFUN void preprocess(string cmd, string extras)
      flags ID_STATIC;
    {
      struct pike_string *pragma_str;
      struct pike_string *error_str;
      struct pike_string *warning_str;
      struct pike_string *line_str;
      struct pike_string *pike_str;
#define MKSTR(SYM) \
    MAKE_CONST_STRING(PIKE_CONCAT(SYM, _str), #SYM)
      MKSTR(pragma);
      MKSTR(error);
      MKSTR(warning);
      MKSTR(line);
      MKSTR(pike);
#undef MKSTR
      if (cmd == pragma_str) {
	struct pike_string *format_str;
	MAKE_CONST_STRING(format_str, "%[^ \t]%*[ \t]%s");
	APPLY_SELF(f_TokenizingCompiler_pike_tokenizer_handle_pragma_fun_num,
		   low_sscanf(extras, format_str));
	pop_n_elems(args);
	/* NOTE: We keep one argument on the stack. */
	return;
      } else if (cmd == error_str) {
	push_int(SL_ERROR);
	push_int(0);
	ref_push_string(MK_STRING("preprocessor"));
	ref_push_string(MK_STRING("#error: %s"));
	ref_push_string(extras);
	APPLY_SELF(tc_pt_inh_report, 4);
	pop_n_elems(args);
	/* NOTE: We keep one argument on the stack. */
	return;
      } else if (cmd == warning_str) {
	push_int(SL_WARNING);
	push_int(0);
	ref_push_string(MK_STRING("preprocessor"));
	ref_push_string(MK_STRING("#warning: %s"));
	ref_push_string(extras);
	APPLY_SELF(tc_pt_inh_report, 4);
	pop_n_elems(args);
	/* NOTE: We keep one argument on the stack. */
	return;
      } else if (cmd == pike_str) {
	/* FIXME: Use more paranoid parsing of version? */
	APPLY_SELF(f_TokenizingCompiler_pike_tokenizer_handle_pike_compat_fun_num,
		   low_sscanf(extras, MK_STRING("%d.%d")));
	pop_n_elems(args);
	/* NOTE: We keep one argument on the stack. */
	return;
      } else if (cmd == line_str) {
	struct pike_string *format_string;
	int res;
	MAKE_CONST_STRING(format_string, "%[^ \t]%*[ \t]%s");
	res = low_sscanf(extras, format_string);
	if (!res) {
	  push_int(SL_ERROR);
	  push_int(0);
	  ref_push_string(MK_STRING("preprocessor"));
	  ref_push_string(MK_STRING("Bad directive: #line %s"));
	  ref_push_string(extras);
	  APPLY_SELF(tc_pt_inh_report, 4);
	  pop_n_elems(args);
	  /* NOTE: We keep one argument on the stack. */
	  return;
	}
	if (res == 1) {
	  push_constant_text("");
	}
	cmd = Pike_sp[-2].u.string;
	extras = Pike_sp[-1].u.string;
	args += 2;
      }
      /* Old-style line directive. */
      {
	int res;
	ref_push_string(MK_STRING("line"));
	if (!(res = low_sscanf(cmd, MK_STRING("%d"))) ||
	    (Pike_sp[-1].type != PIKE_T_INT)) {
	  push_int(SL_ERROR);
	  push_int(0);
	  ref_push_string(MK_STRING("preprocessor"));
	  ref_push_string(MK_STRING("Bad directive: #line %s %s"));
	  ref_push_string(cmd);
	  ref_push_string(extras);
	  APPLY_SELF(tc_pt_inh_report, 4);
	  pop_n_elems(args + res + 1);
	  /* NOTE: We keep one argument on the stack. */
	  return;
	}
	/* Set line_no. */
	APPLY_SELF(tc_pt_inh_set_context, 2);
	pop_stack();
	if (extras->len) {
	  /* NOTE: extras is always at the top of the stack here. */
	  APPLY_SELF(f_TokenizingCompiler_pike_tokenizer_parse_string_fun_num,
		     1);
	  Pike_sp[0] = Pike_sp[-1];
	  copy_shared_string(Pike_sp[-1].u.string, MK_STRING("file"));
	  Pike_sp++;
	  APPLY_SELF(tc_pt_inh_set_context, 2);
	}
	pop_n_elems(args-1);
	/* NOTE: We keep one argument on the stack. */
	return;
      }
    }

    /*! @decl Token handle(string symbol)
     *!
     *! Token factory.
     *!
     *! @seealso
     *!   @[token_lookup]
     */
    PIKEFUN Token handle(string symbol)
      flags ID_STATIC;
    {
      /* Make place for the token program. */
      Pike_sp[0] = Pike_sp[-1];
      Pike_sp[-1].type = PIKE_T_INT;
      Pike_sp[-1].subtype = NUMBER_UNDEFINED;
      Pike_sp[-1].u.integer = 0;
      Pike_sp++;

      APPLY_SELF(tc_pt_inh_get_context, 0);

      /* Stack is now:
       *
       * Pike_sp[-3]	UNDEFINED.
       * Pike_sp[-2]	symbol.
       * Pike_sp[-1]	context.
       */

      args = 3;

      if (THIS->token_lookup) {
	mapping_index_no_free(Pike_sp-3, THIS->token_lookup, Pike_sp-args);
	if (UNSAFE_IS_ZERO(Pike_sp-3)) {
	  goto examine_symbol;
	}
      } else {
	/* Try looking closer at the symbol. */
      examine_symbol:
	if (symbol->len) {
	  struct pike_string *format_str;
	  switch(index_shared_string(symbol, 0)) {
	  case '\"':
	  case '\'':
	    /* String or character constant. */
	    ref_push_string(symbol);
	    APPLY_SELF(f_TokenizingCompiler_pike_tokenizer_parse_string_fun_num, 1);
	    if (index_shared_string(symbol, 0) == '\'') {
	      if (!Pike_sp[-1].u.string->len) {
		ref_push_string(MK_STRING("Zero-length character constant: %s"));
		ref_push_string(Pike_sp[-2].u.string);
		APPLY_SELF(f_TokenizingCompiler_pike_tokenizer_yyerror_fun_num, 2);
		pop_stack();
		push_int(0);
	      } else {
		INT32 val;
		if (Pike_sp[-1].u.string->len > 1) {
		  ref_push_string(MK_STRING("Long character constant: %s"));
		  ref_push_string(Pike_sp[-2].u.string);
		  APPLY_SELF(f_TokenizingCompiler_pike_tokenizer_yyerror_fun_num, 2);
		  pop_stack();
		}
		val = index_shared_string(Pike_sp[-1].u.string, 0);
		pop_stack();
		push_int(val);
	      }
	      args=4;
	      add_ref(Pike_sp[-4].u.program = IntegerToken_program);
	      Pike_sp[-4].type = T_PROGRAM;
	    } else {
	      args=4;
	      add_ref(Pike_sp[-4].u.program = StringToken_program);
	      Pike_sp[-4].type = T_PROGRAM;
	    }
	    break;

	  case '0':
	    /* Binary, hexadecimal, octal or floating point number. */
	    if (symbol->len == 1) {
	      push_int(0);
	    } else if (!low_sscanf(symbol, MK_STRING("0%*[xX]%x")) &&
		       !low_sscanf(symbol, MK_STRING("0%*[bB]%b"))) {
	      /* NOTE: This sscanf will always succeed. */
	      low_sscanf(symbol, MK_STRING("%o%s"));
	      goto sscanned_int;
	    }
	    goto got_int;
	  case '1': case '2': case '3':
	  case '4': case '5': case '6':
	  case '7': case '8': case '9':
	    /* Decimal or floating point number. */
	    /* NOTE: This sscanf will always succeed. */
	    low_sscanf(symbol, MK_STRING("%d%s"));
	  sscanned_int:
	    if (Pike_sp[-1].u.string->len) {
	      /* Possibly a float. */
	      /* NOTE: This sscanf will always succeed. */
	      low_sscanf(symbol, MK_STRING("%f%s"));
	      if (Pike_sp[-1].u.string->len) {
		ref_push_string(MK_STRING("Strange numeric constant: %s"));
		ref_push_string(symbol);
		APPLY_SELF(f_TokenizingCompiler_pike_tokenizer_yyerror_fun_num,
			   2);
		pop_stack();
	      }
	      if (Pike_sp[-1].u.string->len > Pike_sp[-3].u.string->len) {
		/* We've got a float. */
		assign_svalue(Pike_sp-4, Pike_sp-2);
		pop_n_elems(3);
		args=4;
		add_ref(Pike_sp[-4].u.program = FloatToken_program);
		Pike_sp[-4].type = T_PROGRAM;
		break;
	      }
	      /* Get rid of the float and the strings. */
	      pop_n_elems(3);
	    } else {
	      /* Get rid of the empty string. */
	      pop_stack();
	    }
	  got_int:
	    args=4;
	    add_ref(Pike_sp[-4].u.program = IntegerToken_program);
	    Pike_sp[-4].type = T_PROGRAM;
	    break;

	  case '#':
	    /* Preprocessor directive.
	     */
	    MAKE_CONST_STRING(format_str, "#%*[ \t]%[^ \t]%*[ \t]%s");
	    APPLY_SELF(f_TokenizingCompiler_pike_tokenizer_preprocess_fun_num,
		       low_sscanf(symbol, format_str));
	    pop_stack();
	    /* FALL_THROUGH */

	  case '/':
	    /* Comment, since all other cases should be handled though
	     * the mapping token_lookup.
	     */
	    pop_n_elems(args);
	    push_int(0);
	    return;
	  }
	}
	if (UNSAFE_IS_ZERO(Pike_sp - args)) {
	  free_svalue(Pike_sp-args);
	  add_ref(Pike_sp[-args].u.program = IdentifierToken_program);
	  Pike_sp[-args].type = T_PROGRAM;
	}
      }
      f_call_function(args);
    }

    PIKEFUN void scan()
      flags ID_STATIC;
    {
      if (THIS->current_token) {
	free_object(THIS->current_token);
	THIS->current_token = NULL;
      }
      push_int(0);	/* Return value. */
      while (1) {
	APPLY_SELF(tc_pt_inh_scan, 0);
	pop_stack();
	low_object_index_no_free(Pike_sp, Pike_fp->current_object,
				 Pike_fp->context.identifier_level +
				 tc_pt_inh_current_symbol);
	Pike_sp++;
	if (SAFE_IS_ZERO(Pike_sp-1)) {
	  pop_stack();
	  return;
	}

	APPLY_SELF(f_TokenizingCompiler_pike_tokenizer_handle_fun_num, 1);
	if (Pike_sp[-1].type == T_OBJECT) {
	  add_ref(THIS->current_token = Pike_sp[-1].u.object);
	  pop_stack();
	  return;
	}
	pop_stack();
      }
    }

    PIKEFUN Token value()
    {
      if (THIS->current_token) {
	ref_push_object(THIS->current_token);
      } else {
	push_undefined();
      }
    }
  }
  /*! @endclass
   */
}
/*! @endclass
 */

#if 0
PIKEFUN object Compile(object tokenizer, object|void handler)
{
  struct compiler_context context;
  int res;

  if (!tokenizer->prog) {
    SIMPLE_BAD_ARG_ERROR("Compile", 1, "Tokenizer.pike_tokenizer");
  }
  add_ref(context.lexer = tokenizer);
  context.lex_value = find_identifier("value", tokenizer->prog);
  context.lex_next = FIND_LFUN(tokenizer->prog, LFUN_ADD_EQ);
  if (handler && (handler->type == PIKE_T_OBJECT) &&
      handler->u.object->prog) {
    add_ref(context.handler = handler->u.object);
    context.handle_report_msg =
      find_identifier("report_msg", handler->u.object->prog);
  } else {
    context.handler = NULL;
    context.handle_report_msg = -1;
  }

  context.result.type = T_INT;
  context.result.subtype = NUMBER_NUMBER;
  context.result.u.integer = 0;

  context.free_sval_list = NULL;
  context.sval_block_list = NULL;

  switch (tokenizer_yyparse(&context)) {
  case 0:	/* Success. */
    break;
  case 1:	/* Abort. */
  case 2:	/* Overflow. */
  default:	/* Unknown. */
    fprintf(stderr, "Compilation failed.\n");
    break;
  }

  pop_n_elems(args);
  push_svalue(&context.result);
  free_context(&context);

  return;
}
#endif /* 0 */

/*! @endmodule
 */

PIKE_MODULE_INIT
{
  INIT

  {
    struct pike_string *type_name;
    struct svalue type_value;

    /* enum SeverityLevel { NOTICE, WARNING, ERROR, FATAL } */
    type_value.type = PIKE_T_TYPE;
    type_value.subtype = 0;
    type_value.u.type = CONSTTYPE(tName("SeverityLevel", tInt03));
    add_constant(MK_STRING("SeverityLevel"), &type_value, 0);
    free_svalue(&type_value);

    add_integer_constant("NOTICE",  SL_NOTICE, 0);
    add_integer_constant("WARNING", SL_WARNING, 0);
    add_integer_constant("ERROR",   SL_ERROR, 0);
    add_integer_constant("FATAL",   SL_FATAL, 0);
  }

#if 0
  init_tokenizer_yyparse();
#endif /* 0 */

  parsetree_module_init();
}

PIKE_MODULE_EXIT
{
  parsetree_module_exit();

  EXIT
}
