/*
 * $Id: Tokenizer.cmod,v 1.11 2003/12/01 14:33:03 grubba Exp $
 *
 * Interface to pike code tokenizer.
 *
 * Henrik Grubbström 2002-07-11
 */

#include "global.h"

#include "config.h"

#include "svalue.h"
#include "object.h"
#include "interpret.h"
#include "operators.h"
#include "builtin_functions.h"
#include "pike_types.h"
#include "module.h"

/*! @module Tokenizer
 */

/*! @decl enum SeverityLevel
 *!   Message severity level.
 *!
 *! @constant NOTICE
 *! @constant WARNING
 *! @constant ERROR
 *! @constant FATAL
 *!
 *! @seealso
 *!   @[compiler()->report()]
 */

#define SL_NOTICE 0
#define SL_WARNING 1
#define SL_ERROR 2
#define SL_FATAL 3

/*! @class Compiler
 */
PIKECLASS compiler
  flags ID_STATIC;
{
  /*! @decl void report(SeverityLevel severity, mixed pos, @
   *!                   string subsystem, string msg, mixed ... extra_args)
   *!   Function called to report messages.
   *!
   *! @param severity
   *!   Message severity.
   *!
   *! @param pos
   *!   Position where the message occurred.
   *!
   *! @param subsystem
   *!   Subsystem where the message was generated. Currently one of
   *!   @string
   *!     @value "preprocessor"
   *!     @value "scanner"
   *!     @value "grouping"
   *!   @endstring
   *!
   *! @param msg
   *!   Message. This is taken to be a @[sprintf()] format string
   *!   if @[extra_args] are specified.
   *!
   *! @param extra_args
   *!   Parameters to @[sprintf()] @[msg].
   *!
   *!   The default implementation reports to stderr.
   *!
   *! @note
   *!   Overload this function to change the report formatting,
   *!   or to redirect the output.
   *!
   *! @seealso
   *!   @[SeverityLevel]
   */
  PIKEFUN void report(int(0..3) severity, mixed pos,
		      string subsystem, string msg, mixed ... extra_args)
  {
    if (args > 4) {
      f_sprintf(args-3);
      args = 4;
    }
    switch(severity) {
#define SL_CASE(SYMBOL)					\
    case PIKE_CONCAT(SL_, SYMBOL):			\
      REF_MAKE_CONST_STRING(Pike_sp[-4].u.string,	\
			    #SYMBOL ":%O:%O:%O\n");	\
      break

      SL_CASE(NOTICE);
      SL_CASE(WARNING);
      SL_CASE(ERROR);
      SL_CASE(FATAL);

#undef SL_CASE

    default:
      Pike_error("Unknown severity level: %"PRINTPIKEINT"d\n", severity);
      break;
    }
    Pike_sp[-args].type = PIKE_T_STRING;
    Pike_sp[-args].subtype = 0;
    f_werror(args);
    args = 1;
  }

  /*! @class basic_tokenizer
   */
  PIKECLASS basic_tokenizer
    program_flags PROGRAM_USES_PARENT;
  {
    // String being converted.
    CVAR struct pike_string *data;

    // Position in string.
    CVAR int pos;

    // Token number in stream.
    PIKEVAR int(0..) token_num;

    // Current line.
    PIKEVAR int(1..) line_no;

    /*! @decl string current_symbol
     *!
     *!   Current symbol.
     *!
     *!   Set by @[scan()]. Is set to @tt{0@} (zero) at end of stream.
     *!
     *! @seealso
     *!   @[scan()]
     */
    PIKEVAR string current_symbol;

    // Current scanner.
    CVAR void (*scanner)(struct compiler_basic_tokenizer_struct *);

    /*! @decl void report(SeverityLevel severity, mixed pos, @
     *!                   string subsystem, string msg, mixed ... extra_args)
     *!   Function called to report messages.
     *!
     *!   This function acts as a relay to @[Tokenizer.compiler()->report()],
     *!   and exists for overloading purposes.
     *!
     *! @seealso
     *!   @[Tokenizer.compiler()->report()]
     */
    PIKEFUN void report(int(0..3) severity, mixed pos, string subsystem,
			string msg, mixed ... extra_args)
    {
      apply_external(1, f_compiler_report_fun_num, args);
    }

    /* Helper function for the most common case. */
    static void report_error(const char *msg)
    {
      push_int(2);
      push_int(THIS->line_no);
      push_constant_text("scanner");
      push_text(msg);
      apply_current(f_compiler_basic_tokenizer_report_fun_num, 4);
      pop_stack();
    }

#define gobble(C)	(((this->pos < this->data->len) && \
			  (str[this->pos] == (C)))?(this->pos++,1):0)

#define MAKE_SCANNER(SHIFT)						\
    static void PIKE_CONCAT(scan, SHIFT)				\
		     (struct compiler_basic_tokenizer_struct *this)	\
    {									\
      PIKE_CONCAT(p_wchar, SHIFT) *str = 				\
	PIKE_CONCAT(STR, SHIFT)(this->data);				\
      while (this->pos < this->data->len) {				\
	int start = this->pos;						\
	int c = str[this->pos++];					\
	switch(c) {							\
	case '\n':							\
	  this->line_no++;						\
	  /* FALL_THROUGH */						\
	case ' ': case '\t': case '\r':					\
	  /* Plain whitespace. */					\
	  continue;							\
									\
	case '\033':	/* ESC */					\
	case '\233':	/* CSI */					\
	  /* Assume ANSI/DEC escape sequence.				\
	   * Format supported:						\
	   *	    <ESC>[\040-\077]+[\100-\177]			\
	   * or								\
	   *	    <CSI>[\040-\077]*[\100-\177]			\
	   */								\
	  while ((this->pos < this->data->len) &&			\
		 (((c = str[this->pos++]) & ~0x1f) == 0x20))		\
	    ;								\
	  if ((c & ~0x3f) != 0x40) {					\
	    /* FIXME: Warning here? */					\
	    this->pos--;						\
	  }								\
	  continue;							\
									\
	case '#':							\
	  /* Preprocessor-style directive (#line, pragma, etc). */	\
	  while (this->pos < this->data->len) {				\
	    if (((c = str[this->pos++]) == '\n') || (c == '\r')) {	\
	      this->pos--;						\
	      break;							\
	    }								\
	  }								\
	  break;							\
									\
	case '0':							\
	  /* Octal, binary, hexadecimal or float number */		\
	  gobble('b')||gobble('B')||gobble('x')||gobble('X');		\
	  /* FALL_THROUGH */						\
	case '1':							\
	case '2':							\
	case '3':							\
	case '4':							\
	case '5':							\
	case '6':							\
	case '7':							\
	case '8':							\
	case '9':							\
	  /* Number. */							\
									\
	  /* Note: Exponent handling is included in			\
	   * the hexadecimal range.					\
	   */								\
	  while(this->pos < this->data->len) {				\
	    c = str[this->pos];						\
	    if ((c < '0') || ((c > '9') && (c < 'A')) ||		\
		((c > 'F') && (c < 'a')) || (c > 'f')) {		\
	      break;							\
	    }								\
	    this->pos++;						\
	  }								\
	  break;							\
									\
	case '\'':							\
	case '\"':							\
	  {								\
	    /* String or character constant. */				\
	    int d;							\
	    while ((this->pos < this->data->len) &&			\
		   ((d = str[this->pos]) != '\n') &&			\
		   (d != '\r') && (this->pos++, (d != c))) {		\
	      if (d == '\\') {						\
	        if (this->pos < this->data->len) {			\
		  d = str[this->pos];					\
		  if ((d == '\r') || (d == '\n')) {			\
		    break;						\
		  }							\
		  this->pos++;						\
	        }							\
	      }								\
	    }								\
	  }								\
	  break;							\
									\
	  /* Operators. */						\
	case ':':							\
	  gobble(':');							\
	  break;							\
									\
	case '.':							\
	  gobble('.') && gobble('.');					\
	  break;							\
									\
	case '-':							\
	  if (gobble('>')) break;					\
	  /* FALL_THROUGH */						\
	case '+':							\
	case '&':							\
	case '|':							\
	  if (gobble(c)) break;						\
	  /* FALL_THROUGH */						\
	case '^':							\
	case '*':							\
	case '%':							\
	case '=':							\
	case '!':							\
	  gobble('=');							\
	  break;							\
									\
	case '/':							\
	  if (gobble('*')) {						\
	    int no = 0;							\
	    do {							\
	      if (gobble('*') && gobble('/')) {				\
		break;							\
	      }								\
	      if (gobble('\n')) {					\
		no++;							\
	      } else {							\
		this->pos++;						\
	      }								\
	    } while (this->pos < this->data->len);			\
	    if (this->pos >= this->data->len) {				\
	      report_error("Unterminated comment.");			\
	    }								\
	    this->line_no += no;					\
	  } else if (gobble('/')) {					\
	    while ((this->pos < this->data->len) &&			\
		   (str[this->pos] != '\n')){				\
	      this->pos++;						\
	    }								\
	    if (this->pos >= this->data->len) {				\
	      report_error("Unterminated comment.");			\
	    }								\
	  } else {							\
	    gobble('=');						\
	  }								\
	  break;							\
									\
	case '>':							\
	  if (gobble(')')) break;					\
	  /* FALL_THROUGH */						\
	case '<':							\
	  gobble(c);							\
	  gobble('=');							\
	  break;							\
									\
	case '(':							\
	  gobble('<');							\
	  break;							\
									\
	case ']':							\
	case '?':							\
	case ',':							\
	case '~':							\
	case '@':							\
	case ')':							\
	case '[':							\
	case '{':							\
	case ';':							\
	case '}':							\
	  break;							\
									\
	case '`':							\
	  gobble('`');							\
	  gobble('`');							\
									\
	  if (this->pos < this->data->len) {				\
	    switch(c = str[this->pos++]) {				\
	    case '/':							\
	    case '%':							\
	    case '*':							\
	    case '&':							\
	    case '|':							\
	    case '^':							\
	    case '~':							\
	      break;							\
									\
	    case '<':							\
	    case '>':							\
	      if (gobble(c)) break;					\
	      /* FALL_THROUGH */					\
	    case '+':							\
	    case '!':							\
	    case '=':							\
	      gobble('=');						\
	      break;							\
									\
	    case '(':							\
	      if (!gobble(')')) {					\
		report_error("Illegal ` identifier. Expected `().");	\
		push_string(string_slice(this->data,			\
					 start, this->pos - start));	\
		push_constant_text(")");				\
		f_add(2);						\
	        this->current_symbol = Pike_sp[-1].u.string;		\
		Pike_sp--;						\
		return;							\
	      }								\
	      break;							\
									\
	    case '-':							\
	      if (gobble('>')) {					\
		gobble('=');						\
	      }								\
	      break;							\
									\
	    case '[':							\
	      if (!gobble(']')) {					\
		report_error("Illegal ` identifier. Expected `[].");	\
		push_string(string_slice(this->data,			\
					 start, this->pos - start));	\
		if (gobble('=')) {					\
		  push_constant_text("]=");				\
		} else {						\
		  push_constant_text("]");				\
		}							\
		f_add(2);						\
	        this->current_symbol = Pike_sp[-1].u.string;		\
		Pike_sp--;						\
		return;							\
	      }								\
	      gobble('=');						\
	      break;							\
									\
	    default:							\
	      report_error("Illegal ` identifier.");			\
	      this->pos--;						\
	      break;							\
	    }								\
	  } else {							\
	    report_error("Illegal ` identifier at end of file.");	\
	  }								\
	  break;							\
									\
	default:							\
	  if ((c >= 256) || isidchar(c)) {				\
	    /* Identifier. */						\
	    while(this->pos < this->data->len) {			\
	      if ((!((c = str[this->pos]) & ~0xff)) && !isidchar(c)) {	\
	        break;							\
	      }								\
	      this->pos++;						\
	    }								\
	    break;							\
	  }								\
									\
	  /* Error. */							\
	  push_int(2);							\
	  push_int(THIS->line_no);					\
	  push_constant_text("scanner");				\
	  push_constant_text("Illegal character (hex %02x) '%c'");	\
	  push_int(c);							\
	  push_int(c);							\
	  apply_current(f_compiler_basic_tokenizer_report_fun_num, 6);	\
	  pop_stack();							\
	  continue;							\
	}								\
	this->current_symbol = string_slice(this->data,			\
					   start, this->pos - start);	\
	return;								\
      }									\
    }

    MAKE_SCANNER(0)
    MAKE_SCANNER(1)
    MAKE_SCANNER(2)

    /*! @decl void scan()
     *!
     *!   Called to advance one token in the stream.
     *!
     *!   The new token is stored in @[current_symbol].
     *!
     *! @note
     *!   This function is not callable directly, but may be overloaded.
     */
    PIKEFUN void scan()
      flags ID_STATIC;
    {
      if (THIS->current_symbol) {
	free_string(THIS->current_symbol);
	THIS->current_symbol = NULL;
      }

      if (!THIS->scanner) {
	if (THIS->data) {
	  if (!THIS->data->size_shift) {
	    THIS->scanner = scan0;
	  } else if (THIS->data->size_shift == 1) {
	    THIS->scanner = scan1;
	  } else {
	    THIS->scanner = scan2;
	  }
	} else {
	  /* No data. */
	  return;
	}
      }
      THIS->scanner(THIS);
      if (THIS->current_symbol) {
	THIS->token_num++;
      }
    }

    /*! @decl void create(string data)
     *!
     *! Initialize the basic tokenizer.
     *!
     *! @param data
     *!   String to tokenize.
     */
    PIKEFUN void create(string data)
      flags ID_STATIC;
    {
      if (THIS->data) {
	free_string(THIS->data);
      }
      copy_shared_string(THIS->data, data);

      THIS->pos = 0;
      THIS->token_num = 0;
      THIS->line_no = 1;
      if (THIS->current_symbol) {
	free_string(THIS->current_symbol);
	THIS->current_symbol = NULL;
      }

      THIS->scanner = NULL;

      apply_current(f_compiler_basic_tokenizer_scan_fun_num, 0);
      pop_stack();
    }

    /*! @decl int(0..1) `!()
     *!
     *! Check for end of stream.
     *!
     *! @returns
     *!   Returns 1 at end of stream.
     */
    PIKEFUN int(0..1) `!()
      flags ID_STATIC;
    {
      RETURN !THIS->current_symbol;
    }

    PIKEFUN object `+=(int n)
      flags ID_STATIC;
    {
      while (n-- > 0) {
	apply_current(f_compiler_basic_tokenizer_scan_fun_num, 0);
	pop_stack();
      }
      pop_n_elems(args);
      f_this_object(0);
    }

    PIKEFUN int index()
    {
      RETURN THIS->token_num;
    }

    PIKEFUN string value()
    {
      add_ref(THIS->current_symbol);
      RETURN THIS->current_symbol;
    }

    INIT
    {
      THIS->data = NULL;
      THIS->scanner = NULL;
      THIS->pos = 0;
      THIS->token_num = 0;
      THIS->line_no = 1;
      THIS->current_symbol = NULL;
    }

    EXIT
    {
      if (THIS->data) {
	free_string(THIS->data);
	THIS->data = NULL;
      }
      if (THIS->current_symbol) {
	free_string(THIS->current_symbol);
	THIS->current_symbol = NULL;
      }
      THIS->scanner = NULL;
    }
  }

  /*! @endclass
   */
}

/*! @endclass
 */

/*! @class Token
 */
PIKECLASS Token
{
  /*! @decl string symbol
   *!
   *! Raw symbol as found in the source code.
   */
  PIKEVAR string symbol;

  /*! @decl mixed pos
   *!
   *! Position information.
   *!
   *! @note
   *!   This can be any value, but is intended to contain
   *!   information pertaining to where the symbol was found.
   *!
   *! @seealso
   *!   @[Tokenizer.Position]
   */
  PIKEVAR mixed pos;

  INIT
  {
    THIS->symbol = NULL;
    THIS->pos.type = PIKE_T_INT;
    THIS->pos.subtype = NUMBER_UNDEFINED;
    THIS->pos.u.integer = 0;
  }

  EXIT
  {
    if (THIS->symbol) {
      free_string(THIS->symbol);
      THIS->symbol = NULL;
    }
    free_svalue(&THIS->pos);
    THIS->pos.type = PIKE_T_INT;
    THIS->pos.subtype = NUMBER_UNDEFINED;
    THIS->pos.u.integer = 0;
  }

  EXTRA
  {
    struct svalue tmp = {
      PIKE_T_STRING, 0, { 0 },
    };
    MAKE_CONST_STRING(tmp.u.string, "token");
    add_constant(tmp.u.string, &tmp, 0);
  }

  PIKEFUN void create(string symbol, mixed pos)
    flags ID_STATIC;
  {
    if (THIS->symbol) {
      free_string(THIS->symbol);
      THIS->symbol = NULL;
    }
    copy_shared_string(THIS->symbol, symbol);
    assign_svalue(&THIS->pos, pos);
  }

  PIKEFUN string _sprintf(int format, mapping(string:string|int) options)
    flags ID_STATIC;
  {
    if (format == 's') {
      if (THIS->symbol) {
	ref_push_string(THIS->symbol);
      } else {
	push_text("NONE");
      }
    } else {
      push_text("%O:%s");
      push_svalue(&THIS->pos);
      if (THIS->symbol) {
	ref_push_string(THIS->symbol);
      } else {
	push_text("NONE");
      }
      f_sprintf(3);
    }
    stack_pop_n_elems_keep_top(args);
    return;
  }
}

/*! @endclass
 */

/* !class IdentifierToken
 */
PIKECLASS IdentifierToken
{
  INHERIT Token;

  EXTRA
  {
    struct svalue tmp = {
      PIKE_T_STRING, 0, { 0 },
    };
    MAKE_CONST_STRING(tmp.u.string, "identifer");
    simple_add_constant("token", &tmp, 0);
    add_integer_constant("is_identifier", 1, 0);
  }
}
/*! @endclass
 */

/*! @class OperatorToken
 */
PIKECLASS OperatorToken
{
  INHERIT Token;

  EXTRA
  {
    struct svalue tmp = {
      PIKE_T_STRING, 0, { 0 },
    };
    MAKE_CONST_STRING(tmp.u.string, "operator");
    simple_add_constant("token", &tmp, 0);
    add_integer_constant("is_operator", 1, 0);
  }
}
/*! @endclass
 */

/*! @class LiteralToken
 */
PIKECLASS LiteralToken
{
  INHERIT Token;

  PIKEVAR mixed value;

  static int literal_token_inherited_create;

  INIT
  {
    THIS->value.type = PIKE_T_INT;
    THIS->value.subtype = NUMBER_UNDEFINED;
    THIS->value.u.integer = 0;
  }

  EXIT
  {
    free_svalue(&THIS->value);
    THIS->value.type = PIKE_T_INT;
    THIS->value.subtype = NUMBER_UNDEFINED;
    THIS->value.u.integer = 0;
  }

  EXTRA
  {
    struct svalue tmp = {
      PIKE_T_STRING, 0, { 0 },
    };
    MAKE_CONST_STRING(tmp.u.string, "literal");
    simple_add_constant("token", &tmp, 0);
    add_integer_constant("is_literal", 1, 0);
    /* We want to access the inherited create(). */
    literal_token_inherited_create =
      really_low_reference_inherited_identifier(NULL, 1,
						f_Token_create_fun_num);
  }

  PIKEFUN void create(string token, mixed pos, mixed value)
    flags ID_STATIC;
  {
    assign_svalue(&THIS->value, value);
    pop_stack();
    args=2;
    apply_low(Pike_fp->current_object, literal_token_inherited_create, 2);
    args=1;
  }
}
/*! @endclass
 */

/*! @class StringToken
 */
PIKECLASS StringToken
{
  INHERIT LiteralToken;

  EXTRA
  {
    struct svalue tmp = {
      PIKE_T_STRING, 0, { 0 },
    };
    MAKE_CONST_STRING(tmp.u.string, "string_constant");
    simple_add_constant("token", &tmp, 0);
    add_integer_constant("is_string", 1, 0);

    /* Modify the type of "value". */
    simple_add_variable("value", "string", 0);
    /* FIXME: Do the same for create()? */
  }
}
/*! @endclass
 */

/*! @class IntegerToken
 */
PIKECLASS IntegerToken
{
  INHERIT LiteralToken;

  EXTRA
  {
    struct svalue tmp = {
      PIKE_T_STRING, 0, { 0 },
    };
    MAKE_CONST_STRING(tmp.u.string, "int_constant");
    simple_add_constant("token", &tmp, 0);
    add_integer_constant("is_int", 1, 0);

    /* Modify the type of "value". */
    simple_add_variable("value", "int", 0);
    /* FIXME: Do the same for create()? */
  }
}
/*! @endclass
 */

/*! @class FloatToken
 */
PIKECLASS FloatToken
{
  INHERIT LiteralToken;

  EXTRA
  {
    struct svalue tmp = {
      PIKE_T_STRING, 0, { 0 },
    };
    MAKE_CONST_STRING(tmp.u.string, "float_constant");
    simple_add_constant("token", &tmp, 0);
    add_integer_constant("is_float", 1, 0);

    /* Modify the type of "value". */
    simple_add_variable("value", "float", 0);
    /* FIXME: Do the same for create()? */
  }
}
/*! @endclass
 */

/*! @class TokenizingCompiler
 */
PIKECLASS TokenizingCompiler
{
  INHERIT compiler;

  /*! @class pike_tokenizer
   *!
   *!   Pike tokenizer.
   */
  PIKECLASS pike_tokenizer
  {
    static int tokenizing_compiler_pike_tokenizer_inherited_report = -1;

    EXTRA
    {
      /* Perform an inherit of the "basic_tokenizer" that our parent
       * contains through its inherit of "compiler".
       */
      /* FIXME: We may want to extend precompile.pike to handle
       *        this automatically.
       */
      low_inherit(compiler_basic_tokenizer_program,
		  0,
		  compiler_basic_tokenizer_program_fun_num +
		  TokenizingCompiler_program->inherits[1].identifier_level,
		  1 + 42,
		  0,
		  NULL);
      tokenizing_compiler_pike_tokenizer_inherited_report =
	really_low_reference_inherited_identifier(NULL, 1,
						  f_compiler_basic_tokenizer_report_fun_num);
    }

    /* PIKEVAR object(Token) current_token; */
    PIKEVAR string current_file;
    /* PIKEVAR object(Position) pos
       flags ID_STATIC; */

    PIKEFUN void report(int(0..3) severity, object/*(Position)*/|int|string pos,
			string subsystem, string msg, mixed ... extras)
    {
#if 0
      if ((pos->type == T_INT) && (THIS->pos)) {
	add_ref(pos->u.object = THIS->pos);
	pos->type = T_OBJECT;
	pos->subtype = 0;
      }
#endif
      apply_low(Pike_fp->current_object,
		tokenizing_compiler_pike_tokenizer_inherited_report,
		args);
    }
  }
  /*! @endclass
   */
}
/* @endclass
 */

#if 0
PIKEFUN object Compile(object tokenizer, object|void handler)
{
  struct compiler_context context;
  int res;

  if (!tokenizer->prog) {
    SIMPLE_BAD_ARG_ERROR("Compile", 1, "Tokenizer.pike_tokenizer");
  }
  add_ref(context.lexer = tokenizer);
  context.lex_value = find_identifier("value", tokenizer->prog);
  context.lex_next = FIND_LFUN(tokenizer->prog, LFUN_ADD_EQ);
  if (handler && (handler->type == PIKE_T_OBJECT) &&
      handler->u.object->prog) {
    add_ref(context.handler = handler->u.object);
    context.handle_report_msg =
      find_identifier("report_msg", handler->u.object->prog);
  } else {
    context.handler = NULL;
    context.handle_report_msg = -1;
  }

  context.result.type = T_INT;
  context.result.subtype = NUMBER_NUMBER;
  context.result.u.integer = 0;

  context.free_sval_list = NULL;
  context.sval_block_list = NULL;

  switch (tokenizer_yyparse(&context)) {
  case 0:	/* Success. */
    break;
  case 1:	/* Abort. */
  case 2:	/* Overflow. */
  default:	/* Unknown. */
    fprintf(stderr, "Compilation failed.\n");
    break;
  }

  pop_n_elems(args);
  push_svalue(&context.result);
  free_context(&context);

  return;
}
#endif /* 0 */

/*! @endmodule
 */

PIKE_MODULE_INIT
{
  {
    struct pike_string *type_name;
    struct svalue type_value;

    /* enum SeverityLevel { NOTICE, WARNING, ERROR, FATAL } */
    MAKE_CONSTANT_SHARED_STRING(type_name, "SeverityLevel");
    type_value.type = PIKE_T_TYPE;
    type_value.subtype = 0;
    type_value.u.type = CONSTTYPE(tInt03);
    add_constant(type_name, &type_value, 0);
    free_svalue(&type_value);
    free_string(type_name);

    add_integer_constant("NOTICE",  SL_NOTICE, 0);
    add_integer_constant("WARNING", SL_WARNING, 0);
    add_integer_constant("ERROR",   SL_ERROR, 0);
    add_integer_constant("FATAL",   SL_FATAL, 0);
  }

  INIT

#if 0
  init_tokenizer_yyparse();
#endif /* 0 */

  parsetree_module_init();
}

PIKE_MODULE_EXIT
{
  parsetree_module_exit();

  EXIT
}
