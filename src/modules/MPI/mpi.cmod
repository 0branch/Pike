/* -*- c -*-
|| This file is part of Pike. For copyright information see COPYRIGHT.
|| Pike is distributed under GPL, LGPL and MPL. See the file COPYING
|| for more information.
*/
#include "global.h"
#include "object.h"
#include "svalue.h"
#include "interpret.h"
#include "program.h"
#include "array.h"
#include "builtin_functions.h"

#include <mpi.h>

#include <stdio.h>

#include "module_support.h"

/*
 * TODO:
 * communicators
 * all kinds of send/recv
 * reduce
 * all_reduce (reduced result present everywhere)
 * reduce_scatter
 * gather
 * scatter
 * scan etc?
 */

struct mpi_info {
    MPI_Datatype type;
    unsigned int length;
    unsigned int type_size;
    unsigned char shift;
    void * data;
};

DECLARATIONS

PIKECLASS IntArray
{
#cmod_define pike_type int
#cmod_define c_type int
#cmod_define name_prefix Int
#cmod_define ARRAY_STORAGE OBJ2_INTARRAY
#cmod_define PUSH push_int
#cmod_define MPI_DATATYPE MPI_INT
#cmod_define MPI_SHIFT (1<<3)
#cmod_define CPIKE_TYPE PIKE_T_INT
#cmod_define CPIKE_SUBTYPE NUMBER_NUMBER
#cmod_define U_IND integer
#cmod_include "typed_array.H"
}

PIKECLASS FloatArray
{
#cmod_define pike_type float
#cmod_define c_type double
#cmod_define name_prefix Float
#cmod_define ARRAY_STORAGE OBJ2_FLOATARRAY
#cmod_define PUSH push_float
#cmod_define MPI_DATATYPE MPI_DOUBLE
#cmod_define MPI_SHIFT (2<<3)
#cmod_define CPIKE_TYPE T_FLOAT
#cmod_define CPIKE_SUBTYPE 0
#cmod_define U_IND float_number
#cmod_include "typed_array.H"
}

PIKECLASS Sentinel {
    CVAR struct mpi_info i;
    CVAR struct object * other;

    INIT {
	THIS->other = NULL;
    }

    EXIT {
	if (THIS->other) {
	    free_object(THIS->other);
	    THIS->other = NULL;
	}
	
    }
}

PMOD_EXPORT struct object * mpi_clone_sentinel(MPI_Datatype type,
					       unsigned int length,
					       unsigned char shift,
					       void * p,
					       struct object * other) {
    struct object * o = low_clone(Sentinel_program);

    OBJ2_SENTINEL(o)->i.length = length;
    OBJ2_SENTINEL(o)->i.shift = shift;
    OBJ2_SENTINEL(o)->i.type = type;
    OBJ2_SENTINEL(o)->i.data = p;
    OBJ2_SENTINEL(o)->other = other;
    add_ref(other);
    return o;
}

PIKECLASS Op {
    CVAR MPI_Op op;
}

PMOD_EXPORT struct object *mpi_clone_op(MPI_Op op)
{
    struct object *o = low_clone(Op_program);

    OBJ2_OP(o)->op = op;
    return o;
}

#cmod_define EXPORT_OP(_op_) PIKEFUN object ` ## _op_()	\
{							\
    push_object(mpi_clone_op(MPI_ ## _op_));		\
}

EXPORT_OP(MAX)
EXPORT_OP(MIN)
EXPORT_OP(SUM)
EXPORT_OP(PROD)
EXPORT_OP(LAND)
EXPORT_OP(BAND)
EXPORT_OP(LOR)
EXPORT_OP(BOR)
EXPORT_OP(LXOR)
EXPORT_OP(BXOR)
EXPORT_OP(MAXLOC)
EXPORT_OP(MINLOC)

int mpi_Reduce(struct object *sendbuf, struct object *recvbuf,
	       MPI_Op op, int root, MPI_Comm comm)
{
    unsigned char shift = OBJ2_INTARRAY(sendbuf)->i.shift;
    unsigned int length = OBJ2_INTARRAY(sendbuf)->i.length;
    int rank;

    MPI_Bcast(&shift, 1, MPI_CHAR, root, comm);
    MPI_Bcast(&length, 1, MPI_INT, root, comm);

    MPI_Comm_rank(comm, &rank);

    if (OBJ2_INTARRAY(recvbuf)->i.shift != OBJ2_INTARRAY(sendbuf)->i.shift)
	Pike_fatal("Reduce: recvbuf and sendbuf differ in shift (%d vs %d).\n",
		   (int)OBJ2_INTARRAY(recvbuf)->i.shift, (int)OBJ2_INTARRAY(sendbuf)->i.shift);
    if (OBJ2_INTARRAY(recvbuf)->i.length != OBJ2_INTARRAY(sendbuf)->i.length)
	Pike_fatal("Reduce: recvbuf and sendbuf differ in size (%u vs %u).\n",
		   OBJ2_INTARRAY(recvbuf)->i.length, OBJ2_INTARRAY(sendbuf)->i.length);

    if (rank != root) {
	if (shift != OBJ2_INTARRAY(recvbuf)->i.shift)
	    Pike_fatal("Cannot Reduce magic shift %d into buffer of magic shift %d.\n",
		       (int)shift, OBJ2_INTARRAY(recvbuf)->i.shift);
	if (length > OBJ2_INTARRAY(recvbuf)->i.length)
	    Pike_fatal("Cannot Reduce magic shift %d and length %d into buffer of length %d.\n",
		       (int)shift, length, OBJ2_INTARRAY(recvbuf)->i.length);
    }

    return MPI_Reduce(OBJ2_INTARRAY(sendbuf)->i.data,
		      OBJ2_INTARRAY(recvbuf)->i.data, length,
		      OBJ2_INTARRAY(sendbuf)->i.type, op,
		      root, comm);
}

#define GEN(_name_) int mpi_ ## _name_(struct object *sendbuf,		\
				       struct object *recvbuf,		\
				       MPI_Op op, MPI_Comm comm)	\
{									\
    unsigned char shift = OBJ2_INTARRAY(sendbuf)->i.shift;		\
    unsigned int length = OBJ2_INTARRAY(sendbuf)->i.length;		\
    int rank;								\
									\
    MPI_Bcast(&shift, 1, MPI_CHAR, 0, comm);				\
    MPI_Bcast(&length, 1, MPI_INT, 0, comm);				\
									\
    MPI_Comm_rank(comm, &rank);						\
									\
    if (OBJ2_INTARRAY(recvbuf)->i.shift					\
	    != OBJ2_INTARRAY(sendbuf)->i.shift)				\
	Pike_fatal(#_name_ ": recvbuf and sendbuf differ in shift (%d vs %d).\n",\
		   (int)OBJ2_INTARRAY(recvbuf)->i.shift,		\
		   (int)OBJ2_INTARRAY(sendbuf)->i.shift);		\
    if (OBJ2_INTARRAY(recvbuf)->i.length				\
	    != OBJ2_INTARRAY(sendbuf)->i.length)			\
	Pike_fatal(#_name_ ": recvbuf and sendbuf differ in size (%u vs %u).\n",\
		   OBJ2_INTARRAY(recvbuf)->i.length,			\
		   OBJ2_INTARRAY(sendbuf)->i.length);			\
									\
    if (rank) {								\
	if (shift != OBJ2_INTARRAY(recvbuf)->i.shift)			\
	    Pike_fatal("Cannot " #_name_ " magic shift %d into buffer of magic shift %d.\n",\
		       (int)shift, OBJ2_INTARRAY(recvbuf)->i.shift);	\
	if (length > OBJ2_INTARRAY(recvbuf)->i.length)			\
	    Pike_fatal("Cannot " #_name_ " magic shift %d and length %d into buffer of length %d.\n",\
		       (int)shift, length,				\
		       OBJ2_INTARRAY(recvbuf)->i.length);		\
    }									\
									\
    return MPI_ ## _name_(OBJ2_INTARRAY(sendbuf)->i.data,		\
		      OBJ2_INTARRAY(recvbuf)->i.data, length,		\
		      OBJ2_INTARRAY(sendbuf)->i.type, op,		\
		      comm);						\
}

GEN(Allreduce)
GEN(Scan)

#undef GEN

int mpi_Recv(struct object *buf, int source, int tag, MPI_Comm comm)
{
    unsigned char shift;
    unsigned int length;
    MPI_Status status;
    int r;

    MPI_Recv(&shift, 1, MPI_CHAR, source, tag, comm, &status);
    MPI_Recv(&length, 1, MPI_INT, status.MPI_SOURCE, tag, comm, NULL);

    if (shift != OBJ2_INTARRAY(buf)->i.shift)
	Pike_error("Trying to receive shift %d into buffer of shift %d.\n",
		   (int)shift, (int)OBJ2_INTARRAY(buf)->i.shift);
    if (OBJ2_INTARRAY(buf)->i.length < length)
#if 0
	Pike_error("Cannot receive MPI." cmod_STRFY_EVAL(name_prefix) "Array(%d) into MPI." cmod_STRFY_EVAL(name_prefix) "Array(%d).\n",
		   length, OBJ2_INTARRAY(buf)->i.length);
#else
	Pike_error("Cannot receive magic shift %d length %d into length %d.\n",
		   shift, length, OBJ2_INTARRAY(buf)->i.length);
#endif

    return MPI_Recv(OBJ2_INTARRAY(buf)->i.data, length,
		    OBJ2_INTARRAY(buf)->i.type, status.MPI_SOURCE,
		    tag, comm, NULL);
}

static int mpi_string_Recv(int source, int tag, MPI_Comm comm, struct pike_string **ps)
{
    unsigned char shift;
    unsigned int length;
    MPI_Status status;
    MPI_Datatype type;
    void *_buf;
    struct svalue sval;
    int r;

    mark_free_svalue(&sval);

    MPI_Recv(&shift, 1, MPI_CHAR, source, tag, comm, &status);
    MPI_Recv(&length, 1, MPI_INT, status.MPI_SOURCE, tag, comm,
	     NULL);


    switch (shift) {
    case 0:
    case 1:
    case 2:
	type = MPI_CHAR;
	_buf = xalloc(length+1);
	((char*)_buf)[length] = 0;
	break;
    default:
	Pike_error("Cannot receive shift %d as a string.\n", (int)shift);
    }

    r = MPI_Recv(_buf, length, type, status.MPI_SOURCE, tag,
		 comm, NULL);

    switch (shift) {
    case 0:
	*ps = make_shared_binary_string(_buf, length);
	break;
    case 1:
	*ps = make_shared_binary_string1((p_wchar1*)_buf, length >> shift);
	break;
    case 2:
	*ps = make_shared_binary_string2((p_wchar2*)_buf, length >> shift);
	break;
    }

    free(_buf);

    return r;
}

int mpi_Bcast(struct object *buf, int root, MPI_Comm comm)
{
    unsigned int length = OBJ2_INTARRAY(buf)->i.length;
    unsigned char shift = OBJ2_INTARRAY(buf)->i.shift;
    int rank;

    MPI_Bcast(&shift, 1, MPI_CHAR, root, comm);
    MPI_Bcast(&length, 1, MPI_INT, root, comm);

    MPI_Comm_rank(comm, &rank);

    if (rank != root) {
	if (shift != OBJ2_INTARRAY(buf)->i.shift)
	    Pike_fatal("Cannot (receive) broadcast of shift %d into buffer of shift %d.\n",
		       (int)shift, (int)OBJ2_INTARRAY(buf)->i.shift);
	if (length > OBJ2_INTARRAY(buf)->i.length)
	    Pike_fatal("Buffer of shift %d and size %d to small for transmission of size %d.\n",
		       (int)shift, OBJ2_INTARRAY(buf)->i.length, length);
    }

    return MPI_Bcast(OBJ2_INTARRAY(buf)->i.data, length,
		     OBJ2_INTARRAY(buf)->i.type, root, comm);
}

static int mpi_string_Bcast(struct pike_string **ps, int root, MPI_Comm comm)
{
    unsigned char shift = (*ps)->size_shift;
    unsigned int length = (*ps)->len << ((*ps)->size_shift);
    MPI_Status status;
    void *_buf;
    int r, rank;

    MPI_Bcast(&shift, 1, MPI_CHAR, root, comm);
    MPI_Bcast(&length, 1, MPI_INT, root, comm);

    MPI_Comm_rank(comm, &rank);


    if (rank != root) {
	switch (shift) {
	case 0:
	case 1:
	case 2:
	    _buf = xalloc(length+1);
	    ((char*)_buf)[length] = 0;
	    break;
	default:
	    Pike_error("Cannot receive shift %d as a string.\n", (int)shift);
	}

	r = MPI_Bcast(_buf, length, MPI_CHAR, root, comm);

	switch (shift) {
	case 0:
	    *ps = make_shared_binary_string(_buf, length);
	    break;
	case 1:
	    *ps = make_shared_binary_string1((p_wchar1*)_buf, length >> shift);
	    break;
	case 2:
	    *ps = make_shared_binary_string2((p_wchar2*)_buf, length >> shift);
	    break;
	}

	free(_buf);
    } else
	r = MPI_Bcast((*ps)->str, length, MPI_CHAR, root, comm);

    return r;
}


int mpi_Send(struct object *buf, int dest, int tag, MPI_Comm comm)
{
    MPI_Send(&OBJ2_INTARRAY(buf)->i.shift, 1, MPI_CHAR, dest, tag, comm);
    MPI_Send(&OBJ2_INTARRAY(buf)->i.length, 1, MPI_INT, dest, tag, comm);
    return MPI_Send(OBJ2_INTARRAY(buf)->i.data, OBJ2_INTARRAY(buf)->i.length,
		    OBJ2_INTARRAY(buf)->i.type, dest, tag, comm);
}

PIKECLASS Pointer
{
    CVAR struct svalue x;
    CVAR int y;

    PIKEFUN void create(mixed|void m)
	flags ID_PROTECTED;
    {
	if (m) assign_svalue(&THIS->x, m);
	pop_n_elems(args);
    }

    PIKEFUN mixed `()()
	flags ID_PROTECTED;
    {
	push_svalue(&THIS->x);
    }

    PIKEFUN mixed `()(mixed m)
	flags ID_PROTECTED;
    {
	assign_svalue(&THIS->x, m);
    }

    INIT
    {
	SET_SVAL(THIS->x, PIKE_T_INT, NUMBER_UNDEFINED, integer, 0);
    }

    EXIT
    {
	free_svalue(&THIS->x);
    }
}

PIKECLASS Comm
{
    CVAR MPI_Comm comm;

    PIKEFUN void Send(string buf, int dest, int|void tag)
    {
	unsigned char shift = buf->size_shift;
	unsigned int length = buf->len << shift;

	MPI_Send(&shift, 1, MPI_CHAR, dest, tag && tag->u.integer, THIS->comm);
	MPI_Send(&length, 1, MPI_INT, dest, tag && tag->u.integer, THIS->comm);
	MPI_Send(buf->str, length, MPI_CHAR, dest, tag && tag->u.integer, THIS->comm);

	pop_n_elems(args);
    }

    PIKEFUN void Send(object buf, int dest, int|void tag)
    {
	mpi_Send(buf, dest, tag && tag->u.integer, THIS->comm);
	pop_n_elems(args);
    }

    PIKEFUN void Recv(object buf, int source, int|void tag)
    {
	struct pike_string *ps = NULL;

	if (-1 == low_get_storage(buf->prog, Pointer_program)) {
	    /* TODO: check for valid types */
	    mpi_Recv(buf, source, tag && tag->u.integer, THIS->comm);
	    pop_n_elems(args);
	} else {
	    mpi_string_Recv(source, tag && tag->u.integer, THIS->comm, &ps);
	    pop_n_elems(args-1);
	    push_string(ps);
	    f_call_function(2);
	    pop_n_elems(1);
	}
    }

    PIKEFUN void Bcast(string buf, int root)
    {
	mpi_string_Bcast(&buf, root, THIS->comm);
    }

    PIKEFUN void Bcast(object buf, int root)
    {
	if (-1 == low_get_storage(buf->prog, Pointer_program)) {
	    mpi_Bcast(buf, root, THIS->comm);
	    pop_n_elems(args);
	} else {
	    struct pike_string *ps;

	    mpi_string_Bcast(&ps, root, THIS->comm);
	    //stack_pop_keep_top();
	    pop_n_elems(args-1);
	    push_string(ps);
	    f_call_function(2);
	    pop_n_elems(1);
	}

    }

    PIKEFUN void Reduce(object sendbuf, object recvbuf, object op, int root)
    {
	if (-1 == low_get_storage(op->prog, Op_program))
	    SIMPLE_BAD_ARG_ERROR("`+", 1, "inherits(MPI.Op)");

	mpi_Reduce(sendbuf, recvbuf, OBJ2_OP(op)->op, root, THIS->comm);
	pop_n_elems(args);
    }

#cmod_define GEN(_name_) PIKEFUN void _name_(object sendbuf,		\
					     object recvbuf, object op)	\
    {									\
	if (-1 == low_get_storage(op->prog, Op_program))		\
	    SIMPLE_BAD_ARG_ERROR("`+", 1, "inherits(MPI.Op)");		\
									\
	mpi_ ## _name_(sendbuf, recvbuf, OBJ2_OP(op)->op, THIS->comm);	\
	pop_n_elems(args);						\
    }

    GEN(Allreduce)
    GEN(Scan)

#cmod_undef GEN

    PIKEFUN void Abort(int errorcode)
    {
	MPI_Abort(THIS->comm, errorcode);
	pop_n_elems(args);
    }

    PIKEFUN void Barrier()
    {
	MPI_Barrier(THIS->comm);
    }

    PIKEFUN int rank()
    {
	int rank;

	MPI_Comm_rank(THIS->comm, &rank);
	push_int(rank);
    }

    PIKEFUN int size()
    {
	int size;

	MPI_Comm_size(THIS->comm, &size);
	push_int(size);
    }

}

/* TODO: guard against multiple calls */
PIKEFUN void Init()
{
    MPI_Init(NULL, NULL); /* MPI Specification does not use &argc, &argv
			     for anything, nor operate on it in any other
			     way. AFAIK this holds for all implementations,
			     but at least does for OpenMPI. */
}


/* TODO: guard against finalizing what has not been inited. */
PIKEFUN void Finalize()
{
    MPI_Finalize();
}

PIKEFUN object `world()
{
    static struct object *comm_world = NULL;

    if (!comm_world) {
	comm_world = clone_object(Comm_program, 0);
	OBJ2_COMM(comm_world)->comm = MPI_COMM_WORLD;
    }

    ref_push_object(comm_world);
}

PIKEFUN int `ANY_SOURCE()
{
    push_int(MPI_ANY_SOURCE);
}

PIKE_MODULE_INIT
{
  INIT;
}

PIKE_MODULE_EXIT
{
  EXIT;
} 
