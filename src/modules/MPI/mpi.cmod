/* -*- c -*-
|| This file is part of Pike. For copyright information see COPYRIGHT.
|| Pike is distributed under GPL, LGPL and MPL. See the file COPYING
|| for more information.
*/
#include "global.h"
#include "object.h"
#include "svalue.h"
#include "interpret.h"
#include "program.h"
#include "array.h"
#include "builtin_functions.h"

#include <mpi.h>

#include <stdio.h>

#include "module_support.h"

/*
 * TODO:
 * communicators
 * all kinds of send/recv
 * reduce
 * all_reduce (reduced result present everywhere)
 * reduce_scatter
 * gather
 * scatter
 * scan etc?
 */

struct mpi_info {
    unsigned int length;
    unsigned int type_size;
    unsigned int shift;
    void * data;
    MPI_Datatype type;
};

DECLARATIONS

#define IS_SENTINEL(x) ((x) && (-1 != low_get_storage((x)->prog,	\
					      IntArray_program)		\
			|| -1 != low_get_storage((x)->prog,		\
						 FloatArray_program)	\
			|| -1 != low_get_storage((x)->prog,		\
						 Sentinel_program)))

#define IS_SENTINEL_OR_PTR(x) (IS_SENTINEL(x) || -1 			\
			       != low_get_storage((x)->prog,		\
						  Pointer_program))

#define ENSURE_SENTINEL(x, fun, argnum) do { if (!IS_SENTINEL(x))	\
    SIMPLE_BAD_ARG_ERROR(fun, argnum, "inherits(MPI.IntArray)|"		\
			 "inherits(MPI.FloatArray)|"			\
			 "inherits(MPI.Sentinel)");			\
} while (0)
#define ENSURE_SENTINEL_OR_NULL(x, fun, argnum) do {			\
    if ((x) && !IS_SENTINEL(x))						\
	SIMPLE_BAD_ARG_ERROR(fun, argnum, "inherits(MPI.IntArray)|"	\
			     "inherits(MPI.FloatArray)|"		\
			     "inherits(MPI.Sentinel)|void");		\
} while (0)

#define FAIL_SENTINEL_OR_PTR(fun, argnum) do {				\
    SIMPLE_BAD_ARG_ERROR(fun, argnum, "inherits(MPI.IntArray)|"		\
			 "inherits(MPI.FloatArray)|"			\
			 "inherits(MPI.Sentinel)|string");		\
} while (0)

#define ENSURE_SENTINEL_OR_PTR(x, fun, argnum) do {			\
    if (!(IS_SENTINEL_OR_PTR(x)))					\
	FAIL_SENTINEL_OR_PTR(fun, argnum);				\
} while (0)

PIKECLASS IntArray
{
#cmod_define pike_type int
#cmod_define c_type int
#cmod_define name_prefix Int
#cmod_define ARRAY_STORAGE OBJ2_INTARRAY
#cmod_define PUSH push_int
#cmod_define MPI_DATATYPE MPI_INT
#cmod_define MPI_SHIFT (1<<3)
#cmod_define CPIKE_TYPE PIKE_T_INT
#cmod_define CPIKE_SUBTYPE NUMBER_NUMBER
#cmod_define U_IND integer
#cmod_include "typed_array.H"
}

PIKECLASS FloatArray
{
#cmod_define pike_type float
#cmod_define c_type double
#cmod_define name_prefix Float
#cmod_define ARRAY_STORAGE OBJ2_FLOATARRAY
#cmod_define PUSH push_float
#cmod_define MPI_DATATYPE MPI_DOUBLE
#cmod_define MPI_SHIFT (2<<3)
#cmod_define CPIKE_TYPE T_FLOAT
#cmod_define CPIKE_SUBTYPE 0
#cmod_define U_IND float_number
#cmod_include "typed_array.H"
}

PIKECLASS SingleArray
{
#cmod_define pike_type float
#cmod_define c_type float
#cmod_define name_prefix Single
#cmod_define ARRAY_STORAGE OBJ2_SINGLEARRAY
#cmod_define PUSH push_float
#cmod_define MPI_DATATYPE MPI_FLOAT
#cmod_define MPI_SHIFT (3<<3)
#cmod_define CPIKE_TYPE T_FLOAT
#cmod_define CPIKE_SUBTYPE 0
#cmod_define U_IND float_number
#cmod_include "typed_array.H"
}

PIKECLASS Sentinel {
    CVAR struct mpi_info i;
    CVAR struct object * other;

    INIT {
	THIS->other = NULL;
    }

    EXIT {
	if (THIS->other) {
	    free_object(THIS->other);
	    THIS->other = NULL;
	}
	
    }
}

PMOD_EXPORT struct object * mpi_clone_sentinel(MPI_Datatype type,
					       unsigned int length,
					       unsigned int shift,
					       void * p,
					       struct object * other) {
    struct object * o = low_clone(Sentinel_program);

    OBJ2_SENTINEL(o)->i.length = length;
    OBJ2_SENTINEL(o)->i.shift = shift;
    OBJ2_SENTINEL(o)->i.type = type;
    OBJ2_SENTINEL(o)->i.data = p;
    OBJ2_SENTINEL(o)->other = other;
    add_ref(other);
    return o;
}

PIKECLASS Op {
    CVAR MPI_Op op;
}

PMOD_EXPORT struct object *mpi_clone_op(MPI_Op op)
{
    struct object *o = low_clone(Op_program);

    OBJ2_OP(o)->op = op;
    return o;
}

#cmod_define EXPORT_OP(_op_) PIKEFUN object ` ## _op_()	\
{							\
    push_object(mpi_clone_op(MPI_ ## _op_));		\
}

EXPORT_OP(MAX)
EXPORT_OP(MIN)
EXPORT_OP(SUM)
EXPORT_OP(PROD)
EXPORT_OP(LAND)
EXPORT_OP(BAND)
EXPORT_OP(LOR)
EXPORT_OP(BOR)
EXPORT_OP(LXOR)
EXPORT_OP(BXOR)
EXPORT_OP(MAXLOC)
EXPORT_OP(MINLOC)

static inline int mpi_Reduce(struct object *sendbuf, struct object *recvbuf,
	       MPI_Op op, int root, MPI_Comm comm)
{
    unsigned int shift = OBJ2_INTARRAY(sendbuf)->i.shift,
		 length = OBJ2_INTARRAY(sendbuf)->i.length;
    int rank;

    MPI_Bcast(&shift, 1, MPI_INT, root, comm);
    MPI_Bcast(&length, 1, MPI_INT, root, comm);

    MPI_Comm_rank(comm, &rank);

    if (OBJ2_INTARRAY(recvbuf)->i.shift != OBJ2_INTARRAY(sendbuf)->i.shift)
	Pike_fatal("Reduce: recvbuf and sendbuf differ in shift (%u vs %u).\n",
		   OBJ2_INTARRAY(recvbuf)->i.shift, OBJ2_INTARRAY(sendbuf)->i.shift);
    if (OBJ2_INTARRAY(recvbuf)->i.length != OBJ2_INTARRAY(sendbuf)->i.length)
	Pike_fatal("Reduce: recvbuf and sendbuf differ in size (%u vs %u).\n",
		   OBJ2_INTARRAY(recvbuf)->i.length, OBJ2_INTARRAY(sendbuf)->i.length);

    if (rank != root) {
	if (shift != OBJ2_INTARRAY(recvbuf)->i.shift)
	    Pike_fatal("Cannot Reduce magic shift %u into buffer of magic shift %u.\n",
		       shift, OBJ2_INTARRAY(recvbuf)->i.shift);
	if (length > OBJ2_INTARRAY(recvbuf)->i.length)
	    Pike_fatal("Cannot Reduce magic shift %u and length %d into buffer of length %d.\n",
		       shift, length, OBJ2_INTARRAY(recvbuf)->i.length);
    }

    return MPI_Reduce(OBJ2_INTARRAY(sendbuf)->i.data,
		      OBJ2_INTARRAY(recvbuf)->i.data, length,
		      OBJ2_INTARRAY(sendbuf)->i.type, op,
		      root, comm);
}

#define GEN(_name_) static inline int mpi_ ## _name_(			\
				       struct object *sendbuf,		\
				       struct object *recvbuf,		\
				       MPI_Op op, MPI_Comm comm)	\
{									\
    unsigned int shift = OBJ2_INTARRAY(sendbuf)->i.shift,		\
		 length = OBJ2_INTARRAY(sendbuf)->i.length;		\
    int rank;								\
									\
    MPI_Bcast(&shift, 1, MPI_INT, 0, comm);				\
    MPI_Bcast(&length, 1, MPI_INT, 0, comm);				\
									\
    MPI_Comm_rank(comm, &rank);						\
									\
    if (OBJ2_INTARRAY(recvbuf)->i.shift					\
	    != OBJ2_INTARRAY(sendbuf)->i.shift)				\
	Pike_fatal(#_name_ ": recvbuf and sendbuf differ in shift (%u vs %u).\n",\
		   OBJ2_INTARRAY(recvbuf)->i.shift,			\
		   OBJ2_INTARRAY(sendbuf)->i.shift);			\
    if (OBJ2_INTARRAY(recvbuf)->i.length				\
	    != OBJ2_INTARRAY(sendbuf)->i.length)			\
	Pike_fatal(#_name_ ": recvbuf and sendbuf differ in size (%u vs %u).\n",\
		   OBJ2_INTARRAY(recvbuf)->i.length,			\
		   OBJ2_INTARRAY(sendbuf)->i.length);			\
									\
    if (rank) {								\
	if (shift != OBJ2_INTARRAY(recvbuf)->i.shift)			\
	    Pike_fatal("Cannot " #_name_ " magic shift %u into buffer of magic shift %u.\n",\
		       shift, OBJ2_INTARRAY(recvbuf)->i.shift);	\
	if (length > OBJ2_INTARRAY(recvbuf)->i.length)			\
	    Pike_fatal("Cannot " #_name_ " magic shift %u and length %d into buffer of length %d.\n",\
		       shift, length,				\
		       OBJ2_INTARRAY(recvbuf)->i.length);		\
    }									\
									\
    return MPI_ ## _name_(OBJ2_INTARRAY(sendbuf)->i.data,		\
		      OBJ2_INTARRAY(recvbuf)->i.data, length,		\
		      OBJ2_INTARRAY(sendbuf)->i.type, op,		\
		      comm);						\
}

GEN(Allreduce)
GEN(Scan)
GEN(Exscan)

#undef GEN

static inline int mpi_Recv(struct object *buf, int source, int tag, MPI_Comm comm)
{
    unsigned int shift, length;
    MPI_Status status;
    int r;

    MPI_Recv(&shift, 1, MPI_INT, source, tag, comm, &status);
    MPI_Recv(&length, 1, MPI_INT, status.MPI_SOURCE, tag, comm, NULL);

    if (shift != OBJ2_INTARRAY(buf)->i.shift)
	Pike_error("Trying to receive shift %u into buffer of shift %u.\n",
		   shift, OBJ2_INTARRAY(buf)->i.shift);
    if (OBJ2_INTARRAY(buf)->i.length < length)
#if 0
	Pike_error("Cannot receive MPI." cmod_STRFY_EVAL(name_prefix) "Array(%d) into MPI." cmod_STRFY_EVAL(name_prefix) "Array(%d).\n",
		   length, OBJ2_INTARRAY(buf)->i.length);
#else
	Pike_error("Cannot receive magic shift %u length %d into length %d.\n",
		   shift, length, OBJ2_INTARRAY(buf)->i.length);
#endif

    return MPI_Recv(OBJ2_INTARRAY(buf)->i.data, length,
		    OBJ2_INTARRAY(buf)->i.type, status.MPI_SOURCE,
		    tag, comm, NULL);
}

static inline int mpi_string_Recv(int source, int tag, MPI_Comm comm, struct pike_string **ps)
{
    unsigned int shift, length;
    MPI_Status status;
    MPI_Datatype type;
    void *_buf;
    struct svalue sval;
    int r;

    mark_free_svalue(&sval);

    MPI_Recv(&shift, 1, MPI_INT, source, tag, comm, &status);
    MPI_Recv(&length, 1, MPI_INT, status.MPI_SOURCE, tag, comm,
	     NULL);


    switch (shift) {
    case 0:
    case 1:
    case 2:
	type = MPI_CHAR;
	_buf = xalloc(length+1);
	((char*)_buf)[length] = 0;
	break;
    default:
	Pike_error("Cannot receive shift %u as a string.\n", shift);
    }

    r = MPI_Recv(_buf, length, type, status.MPI_SOURCE, tag,
		 comm, NULL);

    switch (shift) {
    case 0:
	*ps = make_shared_binary_string(_buf, length);
	break;
    case 1:
	*ps = make_shared_binary_string1((p_wchar1*)_buf, length >> shift);
	break;
    case 2:
	*ps = make_shared_binary_string2((p_wchar2*)_buf, length >> shift);
	break;
    }

    free(_buf);

    return r;
}

static inline int mpi_Bcast(struct object *buf, int root, MPI_Comm comm)
{
    unsigned int length = OBJ2_INTARRAY(buf)->i.length,
		 shift = OBJ2_INTARRAY(buf)->i.shift;
    int rank;

    MPI_Bcast(&shift, 1, MPI_INT, root, comm);
    MPI_Bcast(&length, 1, MPI_INT, root, comm);

    MPI_Comm_rank(comm, &rank);

    if (rank != root) {
	if (shift != OBJ2_INTARRAY(buf)->i.shift)
	    Pike_fatal("Cannot (receive) broadcast of shift %u into buffer of shift %u.\n",
		       shift, OBJ2_INTARRAY(buf)->i.shift);
	if (length > OBJ2_INTARRAY(buf)->i.length)
	    Pike_fatal("Buffer of shift %u and size %d to small for transmission of size %d.\n",
		       shift, OBJ2_INTARRAY(buf)->i.length, length);
    }

    return MPI_Bcast(OBJ2_INTARRAY(buf)->i.data, length,
		     OBJ2_INTARRAY(buf)->i.type, root, comm);
}

static inline int mpi_string_Bcast(struct pike_string **ps, int root, MPI_Comm comm)
{
    unsigned int shift = (*ps)->size_shift,
		 length = (*ps)->len << ((*ps)->size_shift);
    MPI_Status status;
    void *_buf;
    int r, rank;

    MPI_Bcast(&shift, 1, MPI_INT, root, comm);
    MPI_Bcast(&length, 1, MPI_INT, root, comm);

    MPI_Comm_rank(comm, &rank);


    if (rank != root) {
	switch (shift) {
	case 0:
	case 1:
	case 2:
	    _buf = xalloc(length+1);
	    ((char*)_buf)[length] = 0;
	    break;
	default:
	    Pike_error("Cannot receive shift %u as a string.\n", shift);
	}

	r = MPI_Bcast(_buf, length, MPI_CHAR, root, comm);

	switch (shift) {
	case 0:
	    *ps = make_shared_binary_string(_buf, length);
	    break;
	case 1:
	    *ps = make_shared_binary_string1((p_wchar1*)_buf, length >> shift);
	    break;
	case 2:
	    *ps = make_shared_binary_string2((p_wchar2*)_buf, length >> shift);
	    break;
	}

	free(_buf);
    } else
	r = MPI_Bcast((*ps)->str, length, MPI_CHAR, root, comm);

    return r;
}


static inline int mpi_Send(struct object *buf, int dest, int tag, MPI_Comm comm)
{
    MPI_Send(&OBJ2_INTARRAY(buf)->i.shift, 1, MPI_INT, dest, tag, comm);
    MPI_Send(&OBJ2_INTARRAY(buf)->i.length, 1, MPI_INT, dest, tag, comm);
    return MPI_Send(OBJ2_INTARRAY(buf)->i.data, OBJ2_INTARRAY(buf)->i.length,
		    OBJ2_INTARRAY(buf)->i.type, dest, tag, comm);
}

static inline int mpi_Gather(struct object *sendbuf, struct object *recvbuf, int root, MPI_Comm comm)
{
    unsigned int shift = OBJ2_INTARRAY(recvbuf)->i.shift, length;
    int rank, size;
    MPI_Status status;

    MPI_Comm_rank(comm, &rank);
    MPI_Comm_size(comm, &size);

    length = OBJ2_INTARRAY(recvbuf)->i.length / size;
    MPI_Bcast(&shift, 1, MPI_INT, root, comm);
    MPI_Bcast(&length, 1, MPI_INT, root, comm);

    if (shift != OBJ2_INTARRAY(sendbuf)->i.shift)
	Pike_error("Cannot Gather magic shift %u into buffer of magic shift %u.\n",
		   shift, OBJ2_INTARRAY(recvbuf)->i.shift);
    if (length > OBJ2_INTARRAY(sendbuf)->i.length)
	Pike_error("Cannot Gather buffer of magic shift %u, length %u into buffer of length %u.\n",
		   shift, length, OBJ2_INTARRAY(recvbuf)->i.length);

    return MPI_Gather(OBJ2_INTARRAY(sendbuf)->i.data, length, OBJ2_INTARRAY(sendbuf)->i.type,
		      OBJ2_INTARRAY(recvbuf)->i.data, length, OBJ2_INTARRAY(sendbuf)->i.type,
		      root, comm);
}

static inline int mpi_Scatter(struct object *sendbuf, struct object *recvbuf, int root, MPI_Comm comm)
{
    unsigned int shift = OBJ2_INTARRAY(sendbuf)->i.shift, length;
    int rank, size;
    MPI_Status status;

    MPI_Comm_rank(comm, &rank);
    MPI_Comm_size(comm, &size);

    length = OBJ2_INTARRAY(sendbuf)->i.length / size;
    MPI_Bcast(&shift, 1, MPI_INT, root, comm);
    MPI_Bcast(&length, 1, MPI_INT, root, comm);

    if (shift != OBJ2_INTARRAY(recvbuf)->i.shift)
	Pike_error("Cannot Scatter magic shift %u into buffer of magic shift %u.\n",
		   shift, OBJ2_INTARRAY(recvbuf)->i.shift);
    if (length > OBJ2_INTARRAY(recvbuf)->i.length)
	Pike_error("Cannot Scatter buffer of magic shift %u, length %u into buffer of length %u.\n",
		   shift, length, OBJ2_INTARRAY(recvbuf)->i.length);

    return MPI_Scatter(OBJ2_INTARRAY(sendbuf)->i.data, length, OBJ2_INTARRAY(sendbuf)->i.type,
		       OBJ2_INTARRAY(recvbuf)->i.data, length, OBJ2_INTARRAY(sendbuf)->i.type,
		       root, comm);
}

static inline int mpi_Scatterv(struct object *sendbuf, struct object *counts,
			       struct object *displ, struct object *recvbuf,
			       int root, MPI_Comm comm)
{
    unsigned int shift;
    int rank, size;
    unsigned int count;
    MPI_Status status;

    MPI_Comm_rank(comm, &rank);
    MPI_Comm_size(comm, &size);

    if (rank == root) {
	int i;

	if (!IS_SENTINEL(sendbuf))
	    Pike_error("Scatterv: root (%d) really needs a sendbuf.\n",
		       root);
	if (!IS_SENTINEL(counts))
	    Pike_error("Scatterv: root (%d) really needs a counts array.\n",
		       root);
	if (!IS_SENTINEL(displ))
	    Pike_error("Scatterv: root (%d) really needs a displacements array.\n",
		       root);

	shift = OBJ2_INTARRAY(sendbuf)->i.shift;

	if (OBJ2_INTARRAY(counts)->i.length != (unsigned int)size)
	    Pike_error("Scatterv: count array of wrong size (%u vs %U).\n",
		       OBJ2_INTARRAY(counts)->i.length, size);
	if (OBJ2_INTARRAY(displ)->i.length != (unsigned int)size)
	    Pike_error("Scatterv: displacements array of wrong size (%u vs %u).\n",
		       OBJ2_INTARRAY(displ)->i.length, size);

	for (i = 0; i < size; i++) {
	    if (((int*)OBJ2_INTARRAY(counts)->i.data)[i]
		+ ((int*)OBJ2_INTARRAY(displ)->i.data)[i]
		> (int)OBJ2_INTARRAY(sendbuf)->i.length
		|| (int)OBJ2_INTARRAY(sendbuf)->i.length < 0)
		Pike_error("counts[%u]+displ[%<u]<sizeof(sendbuf) (%u).\n",
			   i, OBJ2_INTARRAY(sendbuf)->i.length);
	}
    }


    MPI_Bcast(&shift, 1, MPI_INT, root, comm);
    MPI_Scatter(counts ? OBJ2_INTARRAY(counts)->i.data : NULL, 1, MPI_INT,
		&count, 1, MPI_INT, root, comm);

    if (shift != OBJ2_INTARRAY(recvbuf)->i.shift)
	Pike_error("Cannot Scatterv magic shift %u into buffer of magic shift %u.\n",
		   shift, OBJ2_INTARRAY(recvbuf)->i.shift);
    if (OBJ2_INTARRAY(recvbuf)->i.length < count)
	Pike_error("Scatterv: to small buffer (%u vs %u) on rank %d.\n",
		   OBJ2_INTARRAY(recvbuf)->i.length, count, rank);

    return MPI_Scatterv(sendbuf ? OBJ2_INTARRAY(sendbuf)->i.data : NULL,
			counts ? (int*)OBJ2_INTARRAY(counts)->i.data : NULL,
			displ ? (int*)OBJ2_INTARRAY(displ)->i.data : NULL,
			sendbuf ? OBJ2_INTARRAY(sendbuf)->i.type
				: OBJ2_INTARRAY(recvbuf)->i.type,
			OBJ2_INTARRAY(recvbuf)->i.data, count,
			OBJ2_INTARRAY(recvbuf)->i.type,
			root, comm);
}

static inline int mpi_Gatherv(struct object *sendbuf, struct object *recvbuf,
			      struct object *counts, struct object *displ,
			      int root, MPI_Comm comm)
{
    unsigned int shift;
    int rank, size;
    unsigned int count;
    MPI_Status status;

    MPI_Comm_rank(comm, &rank);
    MPI_Comm_size(comm, &size);

    if (rank == root) {
	int i;

	if (!IS_SENTINEL(recvbuf))
	    Pike_error("Gatherv: root (%d) really needs a recvbuf.\n",
		       root);
	if (!IS_SENTINEL(counts))
	    Pike_error("Gatherv: root (%d) really needs a counts array.\n",
		       root);
	if (!IS_SENTINEL(displ))
	    Pike_error("Gatherv: root (%d) really needs a displacements array.\n",
		       root);

	shift = OBJ2_INTARRAY(recvbuf)->i.shift;

	if (OBJ2_INTARRAY(counts)->i.length != (unsigned int)size)
	    Pike_error("Gatherv: count array of wrong size (%u vs %U).\n",
		       OBJ2_INTARRAY(counts)->i.length, size);
	if (OBJ2_INTARRAY(displ)->i.length != (unsigned int)size)
	    Pike_error("Gatherv: displacements array of wrong size (%u vs %u).\n",
		       OBJ2_INTARRAY(displ)->i.length, size);

	for (i = 0; i < size; i++) {
	    if (((int*)OBJ2_INTARRAY(counts)->i.data)[i]
		+ ((int*)OBJ2_INTARRAY(displ)->i.data)[i]
		> (int)OBJ2_INTARRAY(recvbuf)->i.length
		|| (int)OBJ2_INTARRAY(recvbuf)->i.length < 0)
		Pike_error("counts[%u]+displ[%<u]<sizeof(sendbuf) (%u).\n",
			   i, OBJ2_INTARRAY(sendbuf)->i.length);
	}
    }


    MPI_Bcast(&shift, 1, MPI_INT, root, comm);
    MPI_Scatter(counts ? OBJ2_INTARRAY(counts)->i.data : NULL, 1, MPI_INT,
		&count, 1, MPI_INT, root, comm);

    if (shift != OBJ2_INTARRAY(sendbuf)->i.shift)
	Pike_error("Cannot Gatherv magic shift %u into buffer of magic shift %u.\n",
		   OBJ2_INTARRAY(sendbuf)->i.shift, shift);
    if (OBJ2_INTARRAY(sendbuf)->i.length < count)
	Pike_error("Gatherv: to small buffer (%u vs %u) on rank %d.\n",
		   OBJ2_INTARRAY(sendbuf)->i.length, count, rank);

    return MPI_Gatherv(OBJ2_INTARRAY(sendbuf)->i.data,
		       count, OBJ2_INTARRAY(sendbuf)->i.type,
		       recvbuf ? OBJ2_INTARRAY(recvbuf)->i.data : NULL,
		       counts ? (int*)OBJ2_INTARRAY(counts)->i.data : NULL,
		       displ ? (int*)OBJ2_INTARRAY(displ)->i.data : NULL,
		       recvbuf ? OBJ2_INTARRAY(recvbuf)->i.type : MPI_INT,
		       root, comm);
}

PIKECLASS Pointer
{
    CVAR struct svalue x;
    CVAR int y;

    PIKEFUN void create(mixed|void m)
	flags ID_PROTECTED;
    {
	if (m) assign_svalue(&THIS->x, m);
	pop_n_elems(args);
    }

    PIKEFUN mixed `()()
	flags ID_PROTECTED;
    {
	push_svalue(&THIS->x);
    }

    PIKEFUN mixed `()(mixed m)
	flags ID_PROTECTED;
    {
	assign_svalue(&THIS->x, m);
    }

    INIT
    {
	SET_SVAL(THIS->x, PIKE_T_INT, NUMBER_UNDEFINED, integer, 0);
    }

    EXIT
    {
	free_svalue(&THIS->x);
    }
}

PIKECLASS Comm
{
    CVAR MPI_Comm comm;

    PIKEFUN void Send(string buf, int dest, int|void tag)
    {
	unsigned int shift = buf->size_shift,
		     length = buf->len << shift;

	MPI_Send(&shift, 1, MPI_INT, dest, tag && tag->u.integer, THIS->comm);
	MPI_Send(&length, 1, MPI_INT, dest, tag && tag->u.integer, THIS->comm);
	MPI_Send(buf->str, length, MPI_CHAR, dest, tag && tag->u.integer, THIS->comm);

	pop_n_elems(args);
    }

    PIKEFUN void Send(object buf, int dest, int|void tag)
    {
	ENSURE_SENTINEL(buf, "Send", 1);
	mpi_Send(buf, dest, tag && tag->u.integer, THIS->comm);
	pop_n_elems(args);
    }

    PIKEFUN void Recv(object buf, int source, int|void tag)
    {
	struct pike_string *ps = NULL;

	if (IS_SENTINEL(buf)) {
	    mpi_Recv(buf, source, tag && tag->u.integer, THIS->comm);
	    pop_n_elems(args);
	} else {
	    if (-1 == low_get_storage(buf->prog, Pointer_program))
		FAIL_SENTINEL_OR_PTR("Recv", 1);
	    mpi_string_Recv(source, tag && tag->u.integer, THIS->comm, &ps);
	    pop_n_elems(args-1);
	    push_string(ps);
	    f_call_function(2);
	    pop_n_elems(1);
	}
    }

    PIKEFUN void Bcast(string buf, int root)
    {
	mpi_string_Bcast(&buf, root, THIS->comm);
	pop_n_elems(args);
    }

    PIKEFUN void Bcast(object buf, int root)
    {
	if (IS_SENTINEL(buf)) {
	    mpi_Bcast(buf, root, THIS->comm);
	    pop_n_elems(args);
	} else {
	    struct pike_string *ps = NULL;

	    if (-1 == low_get_storage(buf->prog, Pointer_program))
		FAIL_SENTINEL_OR_PTR("Bcast", 1);

	    mpi_string_Bcast(&ps, root, THIS->comm);
	    //stack_pop_keep_top();
	    pop_n_elems(args-1);
	    push_string(ps);
	    f_call_function(2);
	    pop_n_elems(1);
	}

    }

    PIKEFUN void Reduce(object sendbuf, object recvbuf, object op, int root)
    {
	if (-1 == low_get_storage(op->prog, Op_program))
	    SIMPLE_BAD_ARG_ERROR("Reduce", 3, "inherits(MPI.Op)");
	ENSURE_SENTINEL(sendbuf, "Reduce", 1);
	ENSURE_SENTINEL(recvbuf, "Reduce", 2);

	mpi_Reduce(sendbuf, recvbuf, OBJ2_OP(op)->op, root, THIS->comm);
	pop_n_elems(args);
    }

#cmod_define GEN(_name_) PIKEFUN void _name_(object sendbuf,		\
					     object recvbuf, object op)	\
    {									\
	if (-1 == low_get_storage(op->prog, Op_program))		\
	    SIMPLE_BAD_ARG_ERROR(#_name_, 3, "inherits(MPI.Op)");	\
	ENSURE_SENTINEL(sendbuf, #_name_, 1);				\
	ENSURE_SENTINEL(recvbuf, #_name_, 2);				\
									\
	mpi_ ## _name_(sendbuf, recvbuf, OBJ2_OP(op)->op, THIS->comm);	\
	pop_n_elems(args);						\
    }

    GEN(Allreduce)
    GEN(Scan)
    GEN(Exscan)

#cmod_undef GEN

#cmod_define GEN(_name_) PIKEFUN void _name_(object sendbuf,		\
					    object recvbuf, int root)	\
    {									\
	ENSURE_SENTINEL(sendbuf, #_name_, 1);				\
	ENSURE_SENTINEL(recvbuf, #_name_, 2);				\
									\
	mpi_ ## _name_(sendbuf, recvbuf, root, THIS->comm);		\
	pop_n_elems(args);						\
    }

    GEN(Scatter)
    GEN(Gather)

#cmod_undef GEN

    PIKEFUN void Scatterv(object|void sendbuf, object|void counts,
			  object|void displ, object recvbuf, int root)
    {
	ENSURE_SENTINEL_OR_NULL(sendbuf, "Scatterv", 1);
	if (counts && -1 == low_get_storage(counts->prog, IntArray_program))
	    SIMPLE_BAD_ARG_ERROR("Scatterv", 2, "inherits(MPI.IntArray)");
	if (displ && -1 == low_get_storage(displ->prog, IntArray_program))
	    SIMPLE_BAD_ARG_ERROR("Scatterv", 3, "inherits(MPI.IntArray)");
	ENSURE_SENTINEL(recvbuf, "Scatterv", 4);

	mpi_Scatterv(sendbuf, counts, displ, recvbuf, root, THIS->comm);
	pop_n_elems(args);
    }

    PIKEFUN void Gatherv(object sendbuf, object|void recvbuf,
			 object|void counts, object|void displ,
			 int root)
    {
	ENSURE_SENTINEL(sendbuf, "Gatherv", 1);
	ENSURE_SENTINEL_OR_NULL(recvbuf, "Gatherv", 2);
	if (counts && -1 == low_get_storage(counts->prog, IntArray_program))
	    SIMPLE_BAD_ARG_ERROR("Gatherv", 3, "inherits(MPI.IntArray)|void");
	if (displ && -1 == low_get_storage(displ->prog, IntArray_program))
	    SIMPLE_BAD_ARG_ERROR("Gatherv", 4, "inherits(MPI.IntArray)|void");

	mpi_Gatherv(sendbuf, recvbuf, counts, displ, root, THIS->comm);
	pop_n_elems(args);
    }

    PIKEFUN void Abort(int errorcode)
    {
	MPI_Abort(THIS->comm, errorcode);
	pop_n_elems(args);
    }

    PIKEFUN void Barrier()
    {
	MPI_Barrier(THIS->comm);
    }

    PIKEFUN int rank()
    {
	int rank;

	MPI_Comm_rank(THIS->comm, &rank);
	push_int(rank);
    }

    PIKEFUN int size()
    {
	int size;

	MPI_Comm_size(THIS->comm, &size);
	push_int(size);
    }

}

/* TODO: guard against multiple calls */
PIKEFUN void Init()
{
    MPI_Init(NULL, NULL); /* MPI Specification does not use &argc, &argv
			     for anything, nor operate on it in any other
			     way. AFAIK this holds for all implementations,
			     but at least does for OpenMPI. */
}


/* TODO: guard against finalizing what has not been inited. */
PIKEFUN void Finalize()
{
    MPI_Finalize();
}

PIKEFUN object `world()
{
    static struct object *comm_world = NULL;

    if (!comm_world) {
	comm_world = clone_object(Comm_program, 0);
	OBJ2_COMM(comm_world)->comm = MPI_COMM_WORLD;
    }

    ref_push_object(comm_world);
}

PIKEFUN int `ANY_SOURCE()
{
    push_int(MPI_ANY_SOURCE);
}

PIKE_MODULE_INIT
{
  INIT;
}

PIKE_MODULE_EXIT
{
  EXIT;
} 
