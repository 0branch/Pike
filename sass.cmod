/*
|| This file is part of Pike. For copyright information see COPYRIGHT.
|| Pike is distributed under GPL, LGPL and MPL. See the file COPYING
|| for more information.
*/

// #define SASS_DEBUG

#include "config.h"
#include "global.h"
#include "interpret.h"
#include "module.h"
#include "stralloc.h"
#include "mapping.h"
#include "array.h"
#include "builtin_functions.h"
#include "svalue.h"
#include "pike_types.h"

#include <sass.h>
#include "pike_sass.h"

#undef PACKAGE_BUGREPORT
#undef PACKAGE_NAME
#undef PACKAGE_STRING
#undef PACKAGE_TARNAME
#undef PACKAGE_URL
#undef PACKAGE_VERSION

DECLARATIONS

/*! @module Tools
 */
/*! @module __Sass
 *! @appears Tools.Sass
 */

void set_options (my_opts *opts, struct Sass_Context *ctx)
{
  struct Sass_Options *s_opts = sass_context_get_options (ctx);

  sass_option_set_precision (s_opts, opts->precision);
  sass_option_set_output_style (s_opts, opts->style);

  if (opts->include_paths) {
    sass_option_set_include_path (s_opts, opts->include_paths->items[0]);

    if (opts->include_paths->len > 1) {
      for (int i = 1; i < opts->include_paths->len; i++) {
        SASS_TRACE ("Push include path: %s\n", opts->include_paths->items[i]);
        sass_option_push_include_path (s_opts, opts->include_paths->items[i]);
      }
    }
  }

  sass_option_set_omit_source_map_url (s_opts, opts->omit_map_url);
  sass_option_set_source_comments (s_opts, opts->comments);

  // if (opts->comments) {
  //   sass_option_set_omit_source_map_url (s_opts, false);
  // }

  if (opts->map_path != NULL) {
    sass_option_set_source_map_file (s_opts, opts->map_path);
    sass_option_set_omit_source_map_url (s_opts, false);
    sass_option_set_source_map_contents (s_opts, true);
  }
  else {
    sass_option_set_source_map_embed (s_opts, opts->map_embed);
  }

  if (opts->map_root != NULL) {
    sass_option_set_source_map_root (s_opts, opts->map_root);
  }
}


#define REGISTER_IMPORTER(CTX)                                    \
  do {                                                            \
    struct Sass_Options *s_opts = sass_context_get_options (CTX); \
    Sass_Importer_Entry c_imp;                                    \
    c_imp = sass_make_importer (pike_sass_importer, 0, 0);        \
    Sass_Importer_List imp_list = sass_make_importer_list (1);    \
    sass_importer_set_list_entry (imp_list, 0, c_imp);            \
    sass_option_set_c_importers (s_opts, imp_list);               \
  } while (0)


/*! @class Api
 *! @appears Tools.Sass.Compiler
 */
PIKECLASS Api
{
  CVAR my_opts* options;


  // Used to resolve external imports. Set by default from the constructor
  // in Compiler in module.pmod.
  PIKEVAR function(string:string) __importer_cb
    flags ID_PRIVATE;


  // Libsass import callback. This will be called for every @import directive
  // in the Sass files. The callback __importer_cb will be called with
  // @path as argument and if @path is an URI __importer_cb will fetch
  // it and return the data as a string. If it's not a string that's retured,
  // e.g. @path was not an URI, NULL is returned from here and libsass will
  // try to resolve @path. If it was an URI a Sass_Import_List will be
  // returned so that the contents of @path will replace the @import directive.
  Sass_Import_List pike_sass_importer (const char *path, Sass_Importer_Entry cb,
                                       struct Sass_Compiler *comp)
  {
    SASS_TRACE ("pike_sass_importer(%s)\n", path);

    if (&THIS->__importer_cb != NULL) {
      push_text (path);
      apply_svalue (&THIS->__importer_cb, 1);

      JMP_BUF recovery;

      if (SETJMP (recovery)) {
        UNSETJMP(recovery);
        MY_THROW_ERR ("%s", throw_value);
      }

      UNSETJMP (recovery);

      if (TYPEOF (Pike_sp[-1]) == T_STRING) {
        SASS_TRACE ("Got return value from import: %s\n",
                    Pike_sp[-1].u.string->str);

        Sass_Import_List list = sass_make_import_list (1);
        list[0] = sass_make_import_entry (path,
                                          strdup (Pike_sp[-1].u.string->str),
                                          0);
        return list;
      }
    }

    return NULL;
  }


  /* This is a strictly internal method that's called from the constructor of
   * the implementing class inheriting this one. The callback @fn should
   * only resolve external URI:s.
   */
  PIKEFUN void __set_importer_callback (function(string:string) fn)
  flags ID_PROTECTED;
  {
    if (fn && TYPEOF (*fn) == T_FUNCTION) {
      assign_svalue (&THIS->__importer_cb, fn);
    }
    else {
      SIMPLE_ARG_TYPE_ERROR ("fn", 1, "function");
    }
  }


  /*! @decl void set_include_path(string path)
   *! @appears Tools.Sass.Compiler.set_include_path()
   *!
   *! Set the base path of @tt{@@import@}s to @[path].
   *!
   *! @seealso
   *!  @[get_include_path()], @[push_include_path()], @[set_include_paths()]
   *!
   *! @param path
   */
  PIKEFUN void set_include_path (string path)
  {
    my_opts_set_include_path (THIS->options, path->str);
  }


  /*! @decl void unset_include_path()
   *! @appears Tools.Sass.Compiler.unset_include_path()
   *!
   *! Unset all include paths either set via @[set_include_path()] or
   *! @[push_include_path()].
   */
  PIKEFUN void unset_include_path ()
  {
    my_opts_include_paths_delete (THIS->options);
  }


  /*! @decl string get_include_path()
   *! @appears Tools.Sass.Compiler.get_include_path()
   *!
   *! Get include path of @tt{imports@}
   *!
   *! @seealso
   *!  @[set_include_path()], @[get_include_paths()]
   */
  PIKEFUN string get_include_path ()
  {
    const char *p = NULL;

    if (THIS->options->include_paths != NULL) {
      p = THIS->options->include_paths->items[0];
    }

    if (p) {
      push_text (p);
    }
    else {
      push_undefined ();
    }
  }


  /*! @decl void push_include_path(string path)
   *! @appears Tools.Sass.Compiler.push_include_path()
   *!
   *! Push path to list of include paths
   *!
   *! @param path
   */
  PIKEFUN void push_include_path (string path)
  {
    my_opts_push_include_path (THIS->options, path->str);
  }


  /*! @decl array(string) get_include_paths()
   *! @appears Tools.Sass.Compiler.get_include_paths()
   *!
   *! Returns an array of all registered include paths set either via
   *! @[set_include_path()] or @[push_include_path()]
   */
  PIKEFUN array(string) get_include_paths ()
  {
    if (THIS->options->include_paths != NULL) {
      for (int i = 0; i < THIS->options->include_paths->len; i++) {
        push_text (THIS->options->include_paths->items[i]);
      }

      f_aggregate (THIS->options->include_paths->len);
    }
    else {
      push_undefined ();
    }
  }


  /*! @decl void set_output_style(int style)
   *! @appears Tools.Sass.Compiler.set_output_style()
   *!
   *! Set the output style for the generated CSS code.
   *! Default is @[Tools.Sass.STYLE_NESTED].
   *!
   *! @seealso
   *!  @[get_output_style()]
   *!
   *! @param style
   *!  See @[Tools.Sass.STYLE_NESTED], @[Tools.Sass.STYLE_EXPANDED],
   *!  @[Tools.Sass.STYLE_COMPACT] and @[Tools.Sass.STYLE_COMPRESSED]
   */
  PIKEFUN void set_output_style (int style)
  {
    THIS->options->style = style;
  }


  /*! @decl int get_output_style(int style)
   *! @appears Tools.Sass.Compiler.get_output_style()
   *!
   *! Returns the output style of the generated CSS code.
   *!
   *! @seealso
   *!  @[set_output_style()]
   */
  PIKEFUN int get_output_style ()
  {
    RETURN (THIS->options->style);
  }


  /*! @decl void set_source_comments(bool set)
   *! @appears Tools.Sass.Compiler.set_source_comments()
   *!
   *! Emit comments in the generated CSS indicating the corresponding
   *! source line. Default is @tt{false@}.
   *!
   *! @seealso
   *!  @[get_source_comments()]
   */
  PIKEFUN void set_source_comments (int(0..1) set)
  {
    THIS->options->comments = set;
  }


  /*! @decl bool get_source_comments()
   *! @appears Tools.Sass.Compiler.get_source_comments()
   *!
   *! Getter for @[set_source_comments()].
   *!
   *! @seealso
   *!  @[set_source_comments()]
   */
  PIKEFUN int(0..1) get_source_comments ()
  {
    RETURN (THIS->options->comments);
  }


  /*! @decl void set_source_map_file(string path)
   *! @appears Tools.Sass.Compiler.set_source_map_file()
   *!
   *! Path to source map file. Enables the source map generating.
   *! Used to create sourceMappingUrl. If this isn't set no source map will
   *! be generated.
   *!
   *! @note
   *!  This only has effect in @[compile_file()].
   *!
   *! @seealso
   *!  @[get_source_map_file()], @[get_source_map_embed()],
   *!  @[set_source_map_embed()]
   */
  PIKEFUN void set_source_map_file (string path)
  {
    if (THIS->options->map_path) {
      free (THIS->options->map_path);
      THIS->options->map_path = NULL;
    }

    THIS->options->map_path = strdup (path->str);
  }


  /*! @decl string get_source_map_file()
   *! @appears Tools.Sass.Compiler.get_source_map_file()
   *!
   *! Returns the path of the source map file.
   *!
   *! @seealso
   *!  @[set_source_map_file()], @[set_source_map_embed()],
   *!  @[get_source_map_embed()]
   */
  PIKEFUN string get_source_map_file ()
  {
    const char *f = THIS->options->map_path;

    if (f) {
      push_text (f);
    }
    else {
      push_undefined ();
    }
  }


  /*! @decl void set_source_map_embed(bool embed)
   *! @appears Tools.Sass.Compiler.set_source_map_embed()
   *!
   *! Set whether embedding sourceMappingUrl as data uri or not.
   *!
   *! @seealso
   *!  @[get_source_map_embed()], @[set_source_map_file()],
   *!  @[get_source_map_file()]
   *!
   *! @param embed
   */
  PIKEFUN void set_source_map_embed (int(0..1) embed)
  {
    THIS->options->map_embed = embed;
  }


  /*! @decl bool get_source_map_embed()
   *! @appears Tools.Sass.Compiler.get_source_map_embed()
   *!
   *! Will a source map be embedded in the CSS file or not?
   *!
   *! @seealso
   *!  @[set_source_map_embed()], @[set_source_map_file()],
   *!  @[get_source_map_file()]
   */
  PIKEFUN int(0..1) get_source_map_embed ()
  {
    RETURN (THIS->options->map_embed);
  }


  /*! @decl void set_source_map_root(string path)
   *! @appears Tools.Sass.Compiler.set_source_map_root()
   *!
   *! Set the root path of the source files, relative to where the
   *! source.map file is written.
   *!
   *! @seealso
   *!  @[get_source_map_root()], @[set_source_map_file()],
   *!  @[get_source_map_file()]
   *!
   *! @param path
   */
  PIKEFUN void set_source_map_root (string path)
  {
    // if (THIS->options->map_root) {
    //   free (THIS->options->map_root);
    // }
    THIS->options->map_root = strdup (path->str);
  }


  /*! @decl string get_source_map_root()
   *! @appears Tools.Sass.Compiler.get_source_map_root()
   *!
   *! Returns the path of the source maps root.
   *!
   *! @seealso
   *!  @[set_source_map_root()], @[set_source_map_file()],
   *!  @[get_source_map_file()]
   */
  PIKEFUN string get_source_map_root ()
  {
    if (THIS->options->map_root) {
      push_text (THIS->options->map_root);
    }
    else {
      push_undefined ();
    }
  }


  /*! @decl void set_omit_source_map_url(bool embed)
   *! @appears Tools.Sass.Compiler.set_omit_source_map_url()
   *!
   *! Set whether writing sourceMappingUrl or not.
   *!
   *! @seealso
   *!  @[set_source_map_embed()], @[set_source_map_file()],
   *!  @[get_source_map_embed()], @[get_source_map_file()]
   *!
   *! @param embed
   */
  PIKEFUN void set_omit_source_map_url (int(0..1) omit)
  {
    THIS->options->omit_map_url = omit;
  }


  /*! @decl int(0..1) get_omit_source_map_url()
   *! @appears Tools.Sass.Compiler.get_omit_source_map_url()
   *!
   *! Getter for @[set_omit_source_map_url()].
   *!
   *! @seealso
   *!  @[set_omit_source_map_url()],
   *!  @[set_source_map_embed()], @[set_source_map_file()],
   *!  @[get_source_map_embed()], @[get_source_map_file()]
   */
  PIKEFUN int(0..1) get_omit_source_map_url ()
  {
    RETURN (THIS->options->omit_map_url);
  }


  /*! @decl void set_precision(int(0..) p)
   *! @appears Tools.Sass.Compiler.set_precision()
   *!
   *! Set the precision of fractional numbers. Default is @tt{5@}.
   *!
   *! @seealso
   *!  @[get_precision()]
   *!
   *! @param p
   */
  PIKEFUN void set_precision (int(0..) p)
  {
    THIS->options->precision = p;
  }


  /*! @decl int(0..) get_precision()
   *! @appears Tools.Sass.Compiler.get_precision()
   *!
   *! Returns the precision of floating point values
   *!
   *! @seealso
   *!  @[set_precision()]
   */
  PIKEFUN int(0..) get_precision ()
  {
    RETURN (THIS->options->precision);
  }


#define SASS_COMPILE_FILE_ERR(X...)    \
  do {                                 \
    sass_delete_file_context (ctx);    \
    Pike_error (X);                    \
  } while (0)


  // Compile the file input_file and return the result.
  // This method is over ridden in the the pmod.
  PIKEFUN mapping(string:string) compile_file (string input_file)
  {
    SASS_TRACE ("compile_file(%s)\n", input_file->str);

    struct Sass_File_Context *ctx;
    struct Sass_Context      *ctx_out;

    ctx = sass_make_file_context (strdup (input_file->str));
    ctx_out = sass_file_context_get_context (ctx);

    set_options (THIS->options, ctx_out);

    REGISTER_IMPORTER (ctx_out);

    int err = sass_compile_file_context (ctx);

    if (err) {
      const char *errstr = strdup (sass_context_get_error_message (ctx_out));
      SASS_COMPILE_FILE_ERR ("Sass compile error (code: %d):\n%s\n",
                             err, errstr);
    }

    const char *scss = sass_context_get_output_string (ctx_out);

    if (scss) {
      const char *smap = NULL;
      struct Sass_Options *s_opts = sass_context_get_options (ctx_out);

      if (sass_option_get_source_map_file (s_opts)) {
        smap = sass_context_get_source_map_string (ctx_out);

        if ((err = sass_context_get_error_status (ctx_out))) {
          const char *errstr = strdup (sass_context_get_error_message (ctx_out));
          SASS_COMPILE_FILE_ERR ("Failed generating source map (code: %ld): %s",
                                 err, errstr);
        }
      }

      push_constant_text ("css"); push_text (scss);
      push_constant_text ("map");

      if (smap != NULL) {
        push_text (smap);
      }
      else {
        push_undefined ();
      }

      f_aggregate_mapping (4);
    }
    else  {
      push_undefined ();
    }

    sass_delete_file_context (ctx);
  }


#define SASS_COMPILE_STRING_ERR(X...)  \
  do {                                 \
    sass_delete_data_context (ctx);    \
    Pike_error (X);                    \
  } while (0)


  // Compile the string source and return a string.
  // This method is over ridden in the pmod
  PIKEFUN string(8bit) compile_string (string(8bit) source)
  {
    struct Sass_Data_Context *ctx;
    struct Sass_Context      *ctx_out;

    ctx = sass_make_data_context (strdup (source->str));
    ctx_out = sass_data_context_get_context (ctx);

    set_options (THIS->options, ctx_out);

    REGISTER_IMPORTER (ctx_out);

    sass_compile_data_context (ctx);

    int err = sass_context_get_error_status (ctx_out);

    if (err) {
      const char *errstr = strdup (sass_context_get_error_message (ctx_out));
      SASS_COMPILE_STRING_ERR ("Sass compile error (code: %ld):\n%s",
                               err, errstr);
    }

    const char *out = sass_context_get_output_string (ctx_out);
    push_text (out);

    sass_delete_data_context (ctx);
  }

  INIT {
    SASS_TRACE ("INIT __Sass.Api\n");
    THIS->options = my_opts_create ();
    memset (THIS->options, 0, sizeof (my_opts));
  }

  EXIT {
    my_opts_delete (THIS->options);
    SASS_TRACE ("EXIT __Sass.Api\n");
  }
}
/*! @endclass */


/*! @decl string libsass_version()
 *!
 *! Returns the @tt{libsass@} version this module was compiled against
 */
PIKEFUN string libsass_version()
{
  push_text (libsass_version ());
}


/*! @decl string sass2scss_version()
 *!
 *! Returns the @tt{sass2scss@} version this module was compiled against
 */
PIKEFUN string sass2scss_version()
{
  push_text (sass2scss_version ());
}


#if HAVE_LIBSASS_LANGUAGE_VERSION
/* Returns the @tt{language@} version of Sass this module was compiled against
*/
PIKEFUN string libsass_language_version()
{
  push_text (libsass_language_version ());
}
#endif


PIKE_MODULE_INIT
{
  /*! @decl constant LIBSASS_VERSION = ""
   *!
   *! The @tt{libsass@} version, as a string, this module was compiled agains.
   */

  add_string_constant ("LIBSASS_VERSION",   LIBSASS_VERSION, 0);

  /*! @decl constant STYLE_NESTED = 1
   *! @decl constant STYLE_EXPANDED = 1
   *! @decl constant STYLE_COMPACT = 1
   *! @decl constant STYLE_COMPRESSED = 1
   *!
   *! Styling of output. Use as argument to @[Compiler.set_output_style()]
   *!
   *! @string
   *! @value STYLE_NESTED
   *! The default setting. The output will look like:
   *! @code
   *! a {
   *!   property: value;
   *!   other-property: value; }
   *! b {
   *!   property: value; }
   *! @endcode
   *!
   *! @value STYLE_EXPANDED
   *! Fully expanded output:
   *! @code
   *! a {
   *!   property: value;
   *!   other-property: value;
   *! }
   *! b {
   *!   property: value;
   *! }
   *! @endcode
   *!
   *! @value STYLE_COMPACT
   *! Somewhat minified output:
   *! @code
   *! a { property: value; other-prop: value }
   *! b { property: value; }
   *! @endcode
   *!
   *! @value STYLE_COMPRESSED
   *! Minified output
   *! @code
   *! a{property:value;other-property:value}b{property:value}
   *! @endcode
   *! @endstring
   */

  add_integer_constant ("STYLE_NESTED",     SASS_STYLE_NESTED,     0);
  add_integer_constant ("STYLE_EXPANDED",   SASS_STYLE_EXPANDED,   0);
  add_integer_constant ("STYLE_COMPACT",    SASS_STYLE_COMPACT,    0);
  add_integer_constant ("STYLE_COMPRESSED", SASS_STYLE_COMPRESSED, 0);

  /*! @decl constant HTTP_IMPORT_NONE = 0
   *! @decl constant HTTP_IMPORT_GREEDY = 1
   *! @decl constant HTTP_IMPORT_ANY = 2
   *!
   *! Description:
   *!
   *! @string
   *! @value HTTP_IMPORT_NONE
   *!  Default value of @[Compiler.http_import]. Prohibits imports over HTTP.
   *! @value HTTP_IMPORT_GREEDY
   *!  Allow imports over HTTP only if the returned content type is
   *!  @tt{text/scss@}.
   *! @value HTTP_IMPORT_ANY
   *!  Anything goes.
   *! @endstring
   */

  add_integer_constant ("HTTP_IMPORT_NONE",   0, 0);
  add_integer_constant ("HTTP_IMPORT_GREEDY", 1, 0);
  add_integer_constant ("HTTP_IMPORT_ANY",    2, 0);

  INIT
}


PIKE_MODULE_EXIT
{
  EXIT
}

/*! @endmodule
 */
/*! @endmodule
 */
