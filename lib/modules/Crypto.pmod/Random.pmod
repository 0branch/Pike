#pike __REAL_VERSION__
#pragma strict_types
#require constant(Nettle.Yarrow)

//! This module contains stuff to that tries to give you the
//! best possible random generation.

protected class RND
{
  inherit Nettle.Fortuna;

  protected function(int:string(8bit)) source;

  protected void create()
  {
#if constant(Nettle.NT)
    source = Nettle.NT.CryptContext(0, 0, Nettle.NT.PROV_RSA_FULL,
                                    Nettle.NT.CRYPT_VERIFYCONTEXT )->read;
#else
    source = Stdio.File("/dev/urandom")->read;
#endif

    reseed(source(32)+predef::random_string(32));
  }

  System.Timer last_seed = System.Timer();
  void reseed(string(8bit)data)
  {
    last_seed->get();
    ::reseed(data);
  }

  string(8bit) random_string(int(0..) len)
  {
    if( last_seed->peek()>0.1 )
      reseed(source(32));
    return ::random_string(len);
  }
}

protected RND rnd_obj;
protected function(int(0..):string(8bit)) rnd_func = rnd_bootstrap;
protected string(8bit) rnd_bootstrap(int(0..) len) {
  rnd_obj = RND();
  rnd_func = rnd_obj->random_string;
  return rnd_func(len);
}

//! Returns a string of length @[len] with random content. The
//! content is generated by a Yarrow random generator that is
//! constantly updated with output from /dev/random on UNIX and
//! CryptGenRandom on NT. The Yarrow random generator is fed
//! at least the amount of random data from its sources as it
//! outputs, thus doing its best to give at least good pseudo-
//! random data on operating systems with bad /dev/random.
string(8bit) random_string(int(0..) len) {
  return rnd_func(len);
}

//! Returns a @[Gmp.mpz] object with a random value between @expr{0@}
//! and @[top]. Uses @[random_string].
Gmp.mpz random(int(0..) top) {
  return [object(Gmp.mpz)]( Gmp.mpz(rnd_func( (int(0..))ceil( log((float)top)/
                                                              log(2.0) ) ),
				    256) % top);
}

//! Inject additional entropy into the random generator.
//! @param data
//!   The random string.
void add_entropy(string(8bit) data) {
  if(rnd_obj)
    rnd_obj->reseed(data);
}
