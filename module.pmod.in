/*
  Author: Pontus Ã–stlund <https://profiles.google.com/poppanator>
*/

//! Sass is a scripting language that is interpreted into Cascading Style
//! Sheets (CSS). This module is a glue for @tt{libsass@}.
//!
//! @seealso
//!  SASS @url{http://sass-lang.com/@}

#pike __REAL_VERSION__
#require constant(Tools@module@)

//! @ignore
inherit Tools@module@;
//! @endignore

//! Sass/SCSS compiler.
//!
//! @example
//! @code
//! Tools.Sass.Compiler compiler = Tools.Sass.Compiler();
//!
//! // Allow for HTTP imports, disallowed by default.
//! compiler->http_import = Tools.Sass.HTTP_IMPORT_ANY;
//!
//! // Minify the output and create a source map file.
//! compiler->set_options(([
//!   "output_style" : Tools.Sass.STYLE_COMPRESSED,
//!   "source_map_file" : "path/to/write/source.map"
//! ]));
//!
//! if (mixed e = catch(compiler->compile_file("input.scss", "output.css"))) {
//!   werror("Failed compiling input.scss to output.css\n");
//! }
//! @endcode
class Compiler
{
  // NOTE: The only reason for this wrapper class is to be able to explicily
  //       destruct the real compiler. There's a cyclic reference between
  //       the compiler and the import callback in the real compiler so it
  //       won't be destructed when it runs out of scope. If it can be solved
  //       internally in the Low_Compiler this class no longer has a purpose

  //! @ignore
  protected Low_Compiler compiler;

  protected void create()
  {
    compiler = Low_Compiler();
  }

#define SETTER(T,P) \
  public void ` ## P ## =(T value) { compiler-> ## P = value; }

#define GETTER(T,P) \
  public T ` ## P ## () { return compiler-> ## P; }

#define GETTER_SETTER(T,P) \
  GETTER(T,P) \
  SETTER(T,P)

  GETTER_SETTER(int(0..2),              http_import)
  GETTER_SETTER(multiset(string(8bit)), http_import_allow_ct)
  GETTER_SETTER(bool,                   check_file_access)
  GETTER_SETTER(string(8bit),           include_path)
  GETTER_SETTER(int(0..3),              output_style)
  GETTER_SETTER(string(8bit),           source_map_file)
  GETTER_SETTER(string(8bit),           source_map_root)
  GETTER_SETTER(int(0..),               precision)
  GETTER_SETTER(int(0..1),              source_comments)
  GETTER_SETTER(int(0..1),              source_map_embed)
  GETTER_SETTER(int(0..1),              omit_source_map_url)

  mapping(string(8bit):string(8bit)) compile_file(string(8bit) input_file)
  {
    return compiler->compile_file(input_file);
  }

  variant void compile_file(string(8bit) input_file, string(8bit) output_file)
  {
    compiler->compile_file(input_file, output_file);
  }

  string(8bit) compile_string(string(8bit) source)
  {
    return compiler->compile_string(source);
  }

  void set_options(mapping(string(8bit):string(8bit)|int) opts)
  {
    compiler->set_options(opts);
  }

  protected void _destruct()
  {
    if (compiler) {
      destruct(compiler);
    }
  }
  //! @endignore
}


class Low_Compiler
{
  //! @ignore
  inherit Tools@module@.Api;
  //! @endignore

  //! @appears Tools.Sass.Compiler.http_import
  //!
  //! If a Sass file is importing an external URI this flag determines if
  //! thats allowed at all, or if the content type of the imported file has
  //! to be in @[http_import_allow_ct], or if anything goes.
  //! Default is @[HTTP_IMPORT_NONE].
  //!
  //! @seealso
  //!  @[HTTP_IMPORT_NONE], @[HTTP_IMPORT_GREEDY] and
  //!  @[HTTP_IMPORT_ANY].
  public int(0..2) http_import = HTTP_IMPORT_NONE;

  //! @appears Tools.Sass.Compiler.http_import_allow_ct
  //!
  //! List of allowed content types if @[http_import] is set to
  //! @[HTTP_IMPORT_GREEDY]. The default is to allow @tt{text/scss@} and
  //! @tt{text/sass@}.
  public multiset(string(8bit)) http_import_allow_ct =
    (< "text/scss", "text/sass" >);

  //! @appears Tools.Sass.Compiler.check_file_access
  //!
  //! Should file access be tested right away when paths are set or should that
  //! be left to Sass to handle? The default value is @tt{true@}.
  public bool check_file_access = true;


  //! @ignore
  protected void create()
  {
    // __set_importer_callback(__resolve_import);
    this::__importer_cb = __resolve_import;
  }
  //! @endignore


  //! @ignore
  //! Resolve external imports in sass/scss files.
  protected string(8bit) __resolve_import(string(8bit) path)
  {
    Standards.URI uri;

    // If it's not an URI we assume it's a local import and we let Sass handle
    // it. This could of course be a, by mistake, malformed URI, but then Sass
    // will eventually throw.
    if (catch (uri = Standards.URI(path))) {
      return UNDEFINED;
    }

    if (http_import == HTTP_IMPORT_NONE) {
      error("Imports over HTTP not allowed!\n");
    }

    Protocols.HTTP.Query q = Protocols.HTTP.get_url(uri);

    if (q->status / 100 != 2) {
      error("Bad HTTP status (%d) for @import %q!\n",
            q->status, (string) uri);
    }

    array(string) ct_parts = map(q->headers["content-type"]/";",
                                 String.trim_all_whites);

    if (http_import == HTTP_IMPORT_GREEDY) {
      if (!http_import_allow_ct[ct_parts[0]]) {
        error("Returned content type from import (%s) was %q. "
              "Expected %s!\n", uri, ct_parts[0],
              String.implode_nicely((array)http_import_allow_ct, "or"));
      }
    }

    string(8bit) data = q->data();

    if (sizeof(ct_parts) > 1) {
      sscanf(ct_parts[1], "%*s=%s", string charset);
      // In case of charset="utf-8" or charset='utf-8', remove the "fnutts"
      if (charset && charset[0] < 65) {
        charset = charset[1..<1];
      }
    }

    return data;
  }
  //! @endignore


  // Documented in the CMOD
  void `include_path=(string(8bit) path)
  {
    if (check_file_access && stringp(path) && !Stdio.exist(path)) {
      error("Include path %q does not exist!\n", path);
    }

    ::include_path = path;
  }


  // Documented in the CMOD
  string(8bit) `include_path()
  {
    return ::include_path;
  }

  //! @appears Tools.Sass.Compiler.compile_file
  //!
  //! Compile the file @[input_file] and return the result
  //!
  //! @param input_file
  //!  The SCSS file to compile
  //!
  //! @returns
  //!  A mapping with the generated CSS and source mapping file if such is
  //!  set to be generated
  //!
  //!  @mapping
  //!   @member string(8bit) "css"
  //!    The generated CSS
  //!   @member string(8bit) "map"
  //!    The generated source mapping data
  //!  @endmapping
  mapping(string(8bit):string(8bit)) compile_file(string(8bit) input_file)
  {
    if (check_file_access && !Stdio.exist(input_file)) {
      error("Input file %q does not exist or isn't accessible!\n",
            input_file);
    }

    return ::compile_file(input_file);
  }

  //! @appears Tools.Sass.Compiler.compile_file
  //!
  //! Compile the file @[input_file] and write the result to @[output_file].
  //! If a source mapping file is set to be generated either via
  //! @[set_options()] or @[source_map_file] it will be written as per
  //! the value set in the option.
  //!
  //! @param input_file
  //!  The SCSS file to compile
  //! @param output_file
  //!  The name of the CSS file to save the result in.
  variant void compile_file(string(8bit) input_file, string(8bit) output_file)
  {
    if (check_file_access && !Stdio.exist(input_file)) {
      error("Input file %q does not exist or isn't accessible!\n",
            input_file);
    }

    mapping(string(8bit):string(8bit)) val = ::compile_file(input_file);
    Stdio.write_file(output_file, val->css);

    if (val->map && source_map_file) {
      Stdio.write_file(source_map_file, val->map);
    }
  }

  //! @appears Tools.Sass.Compiler.set_options
  //!
  //! Set options to the SASS compiler.
  //!
  //! @param opts
  //!  @mapping
  //!   @member int "output_style"
  //!    Any of the @[STYLE_NESTED], @[STYLE_EXPANDED], @[STYLE_COMPACT]
  //!    or @[STYLE_COMPRESSED] constants. See also @[output_style].
  //!
  //!   @member string(8bit) "include_path"
  //!    Path to root of incude files. See also @[include_path].
  //!
  //!   @member string(8bit) "source_map_file"
  //!    File to write source map file to.
  //!    See also @[source_map_file].
  //!
  //!   @member bool "source_comments"
  //!    Turn on/off comments in the output containing info about the source
  //!    file - line numbers and such. Default of @tt{false@}. See also
  //!    @[source_comments].
  //!
  //!   @member bool "source_map_embed"
  //!    Turn on/off if a source map should be embedded in the output or not.
  //!    Default is @tt{false@}. See also @[source_map_embed].
  //!
  //!   @member string(8bit) "source_map_root"
  //!    Set the root path of the source files, relative to where the
  //!    source.map file is written.
  //!    See also @[source_map_root]
  //!
  //!   @member bool "omit_source_map_url"
  //!    Omit the #sourceMappingURL or not.
  //!    See also @[omit_source_map_url]
  //!
  //!   @member int "precision"
  //!    Floating point precision. See also @[precision].
  //!  @endmapping
  void set_options(mapping(string(8bit):string(8bit)|int) opts)
  {
    foreach (opts; string opt; string|int val) {
      switch (opt)
      {
        case "output_style":
          if (!(< STYLE_NESTED, STYLE_COMPRESSED, STYLE_COMPACT,
                  STYLE_EXPANDED >)[val])
          {
            error("Unrecognized output style value!\n");
          }
          output_style = val;
          break;

        case "include_path":
          include_path = val;
          break;

        case "source_map_file":
          source_map_file = val;
          break;

        case "source_map_embed":
          source_map_embed = val;
          break;

        case "source_map_root":
          source_map_root = val;
          break;

        case "omit_source_map_url":
          omit_source_map_url = val;
          break;

        case "source_comments":
          source_comments = val;
          break;

        case "precision":
          precision = val;
          break;

        default:
          error("Unknown option %O!\n", opt);
      }
    }
  }
}
