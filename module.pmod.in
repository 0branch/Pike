/*
  Author: Pontus Ã–stlund <https://profiles.google.com/poppanator>
*/

//! Sass is a scripting language that is interpreted into Cascading Style
//! Sheets (CSS). This module is a glue for @tt{libsass@}.
//!
//! @seealso
//!  SASS @url{http://sass-lang.com/@}

#pike __REAL_VERSION__
#require constant(Tools@module@)

//! @ignore
inherit Tools@module@;
//! @endignore

//! Sass/SCSS compiler.
//!
//! @example
//! @code
//! Tools.Sass.Compiler compiler = Tools.Sass.Compiler();
//!
//! // Allow for HTTP imports, disallowed by default.
//! compiler->http_import = Tools.Sass.HTTP_IMPORT_ANY;
//!
//! // Minify the output and create a source map file.
//! compiler->set_options(([
//!   "output_style" : Tools.Sass.STYLE_COMPRESSED
//!   "source_map_file" : "path/to/write/source.map"
//! ]));
//!
//! if (mixed e = catch(compiler->compile_file("input.scss", "output.css"))) {
//!   werror("Failed compiling input.scss to output.css\n");
//! }
//! @endcode
class Compiler
{
  //! @ignore
  inherit Tools@module@.Api;
  //! @endignore

  //! If a Sass file is importing an external URI this flag determines if
  //! thats allowed at all, or if the content type of the imported file has
  //! to be text/scss or if anything goes. Default is @[HTTP_IMPORT_NONE].
  //!
  //! @seealso
  //!  @[HTTP_IMPORT_NONE], @[HTTP_IMPORT_GREEDY] and
  //!  @[HTTP_IMPORT_ANY].
  public int(0..2) http_import = HTTP_IMPORT_NONE;


  //! Should file access be tested right away when paths are set or should that
  //! be left to Sass to handle? The default value is @tt{true@}.
  public bool check_file_access = true;


  //! @ignore
  protected void create()
  {
    ::__set_importer_callback(__resolve_import);
  }
  //! @endignore


  //! @ignore
  //! Resolve external imports in sass/scss files.
  protected string __resolve_import(string path)
  {
    Standards.URI uri;

    // If it's not an URI we assume it's a local import and we let Sass handle
    // it. This could of course be a, by mistake, malformed URI, but then Sass
    // will eventually throw.
    if (catch (uri = Standards.URI(path))) {
      return UNDEFINED;
    }

    if (http_import == HTTP_IMPORT_NONE) {
      error("Imports over HTTP not allowed!\n");
    }

    Protocols.HTTP.Query q = Protocols.HTTP.get_url(uri);

    if (q->status != 200) {
      error("Bad HTTP status (%d) for @import %q!\n",
            q->status, (string) uri);
    }

    array(string) ct_parts = map(q->headers["content-type"]/";",
                                 String.trim_all_whites);

    if (http_import == HTTP_IMPORT_GREEDY) {
      if (ct_parts[0] != "text/scss") {
        error("Returned content type from import (%s) was %q. "
              "Expected \"text/scss\"!\n",
              uri, ct_parts[0]);
      }
    }

    string(8bit) data = q->data();

    if (sizeof(ct_parts) > 1) {
      sscanf(ct_parts[1], "%*s=%s", string charset);
      // In case of charset="utf-8" or charset='utf-8', remove the "fnutts"
      if (charset && charset[0] < 65) {
        charset = charset[1..<1];
      }
    }

    return data;
  }
  //! @endignore


  // Documented in the CMOD
  void `include_path=(string(8bit) path)
  {
    if (check_file_access && !Stdio.exist(path)) {
      error("Include path %q does not exist!\n", path);
    }

    ::include_path = path;
  }


  // Documented in the CMOD
  string `include_path()
  {
    return ::include_path;
  }


  //! Compile the file @[input_file] and return the result
  //!
  //! @param input_file
  //!  The SCSS file to compile
  //!
  //! @returns
  //!  A mapping with the generated CSS and source mapping file if such is
  //!  set to be generated
  //!
  //!  @mapping
  //!   @member string "css"
  //!    The generated CSS
  //!   @member string "map"
  //!    The generated source mapping data
  //!  @endmapping
  mapping(string:string) compile_file(string input_file)
  {
    if (check_file_access && !Stdio.exist(input_file)) {
      error("Input file %q does not exist or isn't accessible!\n",
            input_file);
    }

    mapping(string:string) val = ::compile_file(input_file);
    return val;
  }

  //! Compile the file @[input_file] and write the result to @[output_file].
  //! If a source mapping file is set to be generated either via
  //! @[set_options()] or @[set_source_map_file()] it will be written as per
  //! the value set in the option.
  //!
  //! @param input_file
  //!  The SCSS file to compile
  //! @param output_file
  //!  The name of the CSS file to save the result in.
  variant void compile_file(string input_file, string output_file)
  {
    if (check_file_access && !Stdio.exist(input_file)) {
      error("Input file %q does not exist or isn't accessible!\n",
            input_file);
    }

    mapping(string:string) val = ::compile_file(input_file);
    Stdio.write_file(output_file, val->css);

    if (val->map && source_map_file) {
      Stdio.write_file(source_map_file, val->map);
    }
  }


  //! Compile the string @[source]
  //!
  //! @note
  //!  If the @[source] contain @tt{@@import@} directives you have to
  //!  explicitly set the include path via @[set_include_path()].
  //!
  //! @param source
  //!  The string to compile
  string(8bit) compile_string(string(8bit) source)
  {
    string(8bit) out = ::compile_string(source);
    return out;
  }


  //! Set options to the SASS compiler. @[opts]
  //!
  //! @param opts
  //!  @mapping
  //!   @member int "output_style"
  //!    Any of the @[STYLE_NESTED], @[STYLE_EXPANDED], @[STYLE_COMPACT]
  //!    or @[STYLE_COMPRESSED] constants. See also @[output_style].
  //!
  //!   @member string "include_path"
  //!    Path to root of incude files. See also @[include_path].
  //!
  //!   @member string "source_map_file"
  //!    File to write source map file to.
  //!    See also @[source_map_file].
  //!
  //!   @member bool "source_comments"
  //!    Turn on/off comments in the output containing info about the source
  //!    file - line numbers and such. Default of @tt{false@}. See also
  //!    @[source_comments].
  //!
  //!   @member bool "source_map_embed"
  //!    Turn on/off if a source map should be embedded in the output or not.
  //!    Default is @tt{false@}. See also @[source_map_embed].
  //!
  //!   @member string "source_map_root"
  //!    Set the root path of the source files, relative to where the
  //!    source.map file is written.
  //!    See also @[source_map_root]
  //!
  //!   @member bool "omit_source_map_url"
  //!    Omit the #sourceMappingURL or not.
  //!    See also @[omit_source_map_url]
  //!  @endmapping
  void set_options(mapping(string:string|int) opts)
  {
    foreach (opts; string opt; string|int val) {
      switch (opt)
      {
        case "output_style":
          if (!intp(val)) {
            error("Value to `output_style` must be an integer!\n");
          }
          output_style = val;
          break;

        case "include_path":
          if (!stringp(val)) {
            error("Value to `include_path` must be a string!\n");
          }
          include_path = val;
          break;

        case "source_map_file":
          if (!stringp(val)) {
            error("Value to `source_map_file` must be a string!\n");
          }
          source_map_file = val;
          break;

        case "source_map_embed":
          if (!intp(val)) {
            error("Value to  `source_map_embed` must be an int(0..1)!\n");
          }
          source_map_embed = val;
          break;

        case "source_map_root":
          if (!stringp(val)) {
            error("Value to `source_map_root` must be a string!\n");
          }
          source_map_root = val;
          break;

        case "omit_source_map_url":
          if (!intp(val)) {
            error("Value to `omit_source_map_url` must be an integer!\n");
          }
          omit_source_map_url = val;
          break;

        case "source_comments":
          if (!intp(val)) {
            error("Value to `source_comments` must be an integer!\n");
          }
          source_comments = val;
          break;

        default:
          error("Unknown option %O!\n", opt);
      }
    }
  }
}
